#!/usr/bin/env python3

import os

core_path_ext = os.path.join(os.path.dirname(os.path.abspath(__file__)) , 'mate_src')

import sys, csv, itertools, math, platform, random, warnings, timeit
import numpy as np
from scipy.interpolate import interp1d
from scipy import optimize
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from matplotlib.collections import PatchCollection
import matplotlib.colors as colors
from matplotlib.pyplot import Figure
import matplotlib.patheffects as pe
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar
from PyQt5 import QtGui, QtCore
from PyQt5.QtWidgets import *

#Importing external functions

sys.path.append(core_path_ext)

from cond_models.dry_odd import * #Dry conductivity of NAMS with specialized functions
from cond_models.ol_wet_odd import * #Whole models of olivine with specialized functions
from cond_models.ol_diffusion import * #Hydrogen diffusion functions of olivine
from cond_models.opx_wet_odd import * #Whole models of opx with specialized functions
from cond_models.opx_diffusion import * #Hydrogen diffusion functions of opx
from cond_models.cpx_wet_odd import * #Whole models of cpx with specialized functions
from cond_models.cpx_diffusion import * #Hydrogen diffusion functions of cpx
from cond_models.gt_wet_odd import * #Whole models of garnet with specialized functions
from cond_models.gt_diffusion import * #Hydrogen diffusion functions of garnet
from cond_models.pl_odd import * #Conductivity functions of phlogopites
from cond_models.amp_odd import * #Conductivity functions of amphiboles
from cond_models.melt_odd import * #Conductivity functions of melts
from cond_models.sp_chr_odd import * #Conductivity functions of spinel-chromites
from min_sol.ol_sol import * #Olivine solubility models
from thermal.adiabat import * #Adiabat models
from solidus_models.solidus import * #Dry solidus models
from solidus_models.wet_solidus import * #Wet solidus models
from solidus_models.carbon_solidus import * #Carbon solidus models

warnings.filterwarnings("ignore", category=RuntimeWarning) #ignoring many RuntimeWarning printouts that are utterly useless

#Color coding class for fancy-colored print-outs.
class bcolors:
	BLUE = '\033[94m'
	GREEN = '\033[92m'
	RED = '\033[91m'
	B = '\033[0m'
	NC ='\x1b[0m'

#Version 1.5, June. 2023.
#MATE - (M)antle (A)nalysis (T)ools for (E)lectromagnetics
#Program written by Sinan Ozaydin (School of Geosciences, University of Sydney 
#, Australia).

#Indentation method: hard tabs ('\t')

#Works with Python3
#Required libraries: numpy,scipy,matplotlib,PyQt5

#Installation of libraries:
#In Linux (mac included) distros through terminal:
#pip install numpy,scipy,matplotlib,PyQt5
#In Windows skip sudo.

print(bcolors.GREEN + '#############################################')
print(' ')
print(' ')
print(' ')
print(bcolors.GREEN + '                  MATE 1.5')
print(' ')
print(bcolors.BLUE + '            Mantle Analysis Tools')
print('                     for')
print('               Electromagnetics')
print(' ')
print(' ')
print(' ')
print(bcolors.GREEN + '#############################################')
print(bcolors.BLUE + 'developed by Sinan Ozaydin,' + bcolors.RED +  ' School of Geosciences, University of Sydney')
print(' ')
print(' ')
print(bcolors.NC + 'for questions, email: sinan.ozaydin@protonmail.com or sinan.ozaydin@sydney.edu.au')
print('Initializing the software...')

class MATE(QMainWindow):

	def __init__(self, core_path = core_path_ext, parent = None):

		super(MATE,self).__init__(parent)

		self.core_path = core_path
		self.working_path = os.getcwd()

		if platform.system() == 'Windows':
			self.commandmv = 'move'
		else:
			self.commandmv = 'mv'

		args_input = sys.argv
		if len(args_input) == 1:
			MATE.arguments_load = False
			MATE.composition_args_path = False
		else:
			MATE.arguments_load = True
			try:
				MATE.composition_args_path = args_input[1]
			except IndexError:
				pass

		self.setMinimumSize(1800,1000)
		self.setStyleSheet("QMainWindow{background-color: #c1ccc1;border: 1px solid black}")
		self.setWindowTitle("MATE")
		self.setWindowIcon(QtGui.QIcon(self.core_path + '/mate.png'))

		#Defining Menubar items
		mainMenu = self.menuBar()
		mainMenu.setNativeMenuBar(False)
		mainMenu.setStyleSheet("QMenuBar{background-color: #889489;border: 1px solid black}")
		fileMenu = mainMenu.addMenu('Main')
		mainMenu.setStyleSheet("QMenuBar{background-color: #889489;border: 1px solid black}")
		geotMenu = mainMenu.addMenu('Thermobarometry')
		geotMenu.setStyleSheet("QMenu{background-color: #9098a3;border: 1px solid black}")
		fugMenu = mainMenu.addMenu('Oxygen Fugacity')
		fugMenu.setStyleSheet("QMenu{background-color: #9098a3;border: 1px solid black}")
		drycondMenu = mainMenu.addMenu('Dry Conductivity')
		drycondMenu.setStyleSheet("QMenu{background-color: #9098a3;border: 1px solid black}")
		watercalibMenu = mainMenu.addMenu('Water Calibration Correction')
		watercalibMenu.setStyleSheet("QMenu{background-color: #9098a3;border: 1px solid black}")
		waterdataMenu = mainMenu.addMenu('Water Data')
		waterdataMenu.setStyleSheet("QMenu{background-color: #9098a3;border: 1px solid black}")
		stabilityMenu = mainMenu.addMenu('Mineral Stabilities')
		stabilityMenu.setStyleSheet("QMenu{background-color: #9098a3;border: 1px solid black}")
		meltsolidusMenu = mainMenu.addMenu('Melt Solidus')
		meltsolidusMenu.setStyleSheet("QMenu{background-color: #9098a3;border: 1px solid black}")
		grainbMenu = mainMenu.addMenu('Grain-Boundary Properties')
		grainbMenu.setStyleSheet("QMenu{background-color: #9098a3;border: 1px solid black}")
		modelMenu = mainMenu.addMenu('Import Resistivity Profile')
		modelMenu.setStyleSheet("QMenu{background-color: #9098a3;border: 1px solid black}")
		figureMenu = mainMenu.addMenu('Figures')
		figureMenu.setStyleSheet("QMenu{background-color: #9098a3;border: 1px solid black}")
		solverMenu = mainMenu.addMenu('Solver')
		solverMenu.setStyleSheet("QMenu{background-color: #9098a3;border: 1px solid black}")
		writeMenu = mainMenu.addMenu('Write Data')
		writeMenu.setStyleSheet("QMenu{background-color: #9098a3;border: 1px solid black}")

		#ENV FILE BUTTON
		infoMain = QAction("&Info", self)
		infoMain.setShortcut("Ctrl+O")
		infoMain.triggered.connect(self.info_main)
		fileMenu.addAction(infoMain)

		#EXIT FILE BUTTON
		exitButton = QAction('Exit', self)
		exitButton.setShortcut('Ctrl+Q')
		exitButton.setStatusTip('Exit application')
		exitButton.triggered.connect(self.quit)
		fileMenu.addAction(exitButton)

		#GEOTHERM FILE BUTTON
		openXenProp = QAction("&Xenolith File Properties", self)
		openXenProp.triggered.connect(self.xen_properties_popup)
		geotMenu.addAction(openXenProp)
		self.xen_pop = None

		openGeothFile = QAction("&Import Xenolith P-T", self)
		openGeothFile.triggered.connect(self.geotherm_open)
		geotMenu.addAction(openGeothFile)

		#FUGACITY OPTIONS MENU

		openFugButton = QAction("&Oxygen Fugacity Selection", self)
		openFugButton.triggered.connect(self.fo2_properties_popup)
		fugMenu.addAction(openFugButton)
		self.fo2_pop = None

		loadFugButton = QAction("&Input Oxygen Fugacity Data", self)
		loadFugButton.triggered.connect(self.load_fo2_data)
		fugMenu.addAction(loadFugButton)
		self.fo2_load_pop = None

		infoFugButton = QAction("&Info", self)
		infoFugButton.triggered.connect(self.info_fugacity)
		fugMenu.addAction(infoFugButton)
		self.fo2_info_pop = None

		#DRY CONDUCTIVITY MENU
		dryPreferences = QAction("&Dry Conductivity Preferences",self)
		dryPreferences.triggered.connect(self.dry_cond_popup)
		self.dry_cond_popup = None
		drycondMenu.addAction(dryPreferences)

		#WATER CALIBRATIONS MENU

		olcalibButton = QAction("&Olivine Water Calibration - Conductivity",self)
		olcalibButton.triggered.connect(self.ol_calib_popup)
		self.ol_calib_pop = None
		pxcalibButton = QAction("&Px-Gt Water Calibration - Conductivity",self)
		pxcalibButton.triggered.connect(self.px_calib_popup)
		self.px_calib_pop = None
		olsolcalibButton = QAction("&Olivine Water Calibration - Solubility",self)
		olsolcalibButton.triggered.connect(self.ol_sol_calib_popup)
		self.ol_sol_calib_pop = None
		watercalibMenu.addAction(olcalibButton)
		watercalibMenu.addAction(pxcalibButton)
		watercalibMenu.addAction(olsolcalibButton)

		#ADDING WATER DATA MENU
		addwaterButton = QAction("&Add Water Content Measurement",self)
		addwaterButton.triggered.connect(self.add_water_measurement)
		waterdataMenu.addAction(addwaterButton)
		self.add_water_pop = None

		#MELT SOLIDUS MENU

		solidusSelectionButton = QAction("&Solidus Selection",self)
		solidusSelectionButton.triggered.connect(self.select_solidus)
		meltsolidusMenu.addAction(solidusSelectionButton)
		self.melt_solidus_pop = None
		
		solidusPlotButton = QAction("&Other Solidus Plot",self)
		solidusPlotButton.triggered.connect(self.select_plot_solidus)
		meltsolidusMenu.addAction(solidusPlotButton)
		self.melt_solidusPlot_pop = None

		meltFracSelectionButton = QAction("&Melt Fraction Gradient",self)
		meltFracSelectionButton.triggered.connect(self.select_melt_fraction_gradient)
		meltsolidusMenu.addAction(meltFracSelectionButton)
		self.melt_frac_pop = None

		#MINERAL STABILITIES MENU
		amphiboleButton = QAction("&Amphibole Stability",self)
		amphiboleButton.triggered.connect(self.amp_stab_popup)
		stabilityMenu.addAction(amphiboleButton)
		self.amp_popup = None

		spinelButton = QAction("&Spinel Stability",self)
		spinelButton.triggered.connect(self.sp_stab_popup)
		stabilityMenu.addAction(spinelButton)
		self.sp_popup = None

		#GRAIN SIZE MENU

		gsizeButton = QAction("&Grain Size Properties",self)
		gsizeButton.triggered.connect(self.grain_size_popup)
		grainbMenu.addAction(gsizeButton)
		self.gsize_popup = None

		#SAVE FIGURES BUTTON

		plotslct = QAction("Plot T Graphs of Selected Models", self)
		plotslct.triggered.connect(self.generate_Tcondplot)

		plot_other_comp = QAction("Plot Other Compositional Parameters", self)
		plot_other_comp.triggered.connect(self.generate_composition_plot)

		figureProp = QAction("Figure Properties", self)
		figureProp.triggered.connect(self.figure_prop_popup)
		self.figprop_popup = None

		saveFigure = QAction("Save Figures", self)
		saveFigure.triggered.connect(self.save_figures)

		figureMenu.addAction(plotslct)
		figureMenu.addAction(plot_other_comp)
		figureMenu.addAction(figureProp)
		figureMenu.addAction(saveFigure)

		#ModEM-Model FILE BUTTON

		#csv-mt file
		csvMTButton = QAction('Open csv MT profile', self)
		csvMTButton.triggered.connect(self.csvMt_open)
		modelMenu.addAction(csvMTButton)

		ModEMButton = QAction('Open ModEM Model', self)
		ModEMButton.setStatusTip('Open ModEM file')
		ModEMButton.triggered.connect(self.ModEM_model_open)
		modelMenu.addAction(ModEMButton)

		#ModEM-Data FILE BUTTON

		ModEMButton = QAction('Open ModEM Data', self)
		ModEMButton.setStatusTip('Open ModEM file')
		ModEMButton.triggered.connect(self.ModEM_data_open)
		modelMenu.addAction(ModEMButton)

		ModelCurve = QAction('ModEM Curve Selection', self)
		ModelCurve.triggered.connect(self.model_curve_select_open)
		modelMenu.addAction(ModelCurve)

		ModelPrefButton = QAction('Preferences', self)
		ModelPrefButton.triggered.connect(self.model_pref_open)
		modelMenu.addAction(ModelPrefButton)
		self.mt_input_popup = None

		#info-box_model
		infoBoxMTinputButton = QAction('Info', self)
		infoBoxMTinputButton.triggered.connect(self.InfoBoxMT)
		modelMenu.addAction(infoBoxMTinputButton)

		#Solver MENU
		solverButton = QAction('Export water solution to the input file.', self)
		solverButton.triggered.connect(self.import_solution_to_comp)
		solverMenu.addAction(solverButton)

		solverSelection = QAction('Conductivity forward model selection', self)
		solverSelection.triggered.connect(self.forward_model_selection)
		solverMenu.addAction(solverSelection)
		self.fwd_model_pop= None

		solverSelection_2 = QAction('Conductivity exported model selection', self)
		solverSelection_2.triggered.connect(self.exported_model_selection)
		solverMenu.addAction(solverSelection_2)
		self.exported_model_pop = None

		solverBatchOutput = QAction('Export batch process parameter selection file', self)
		solverBatchOutput.triggered.connect(self.write_batch_process_output)
		solverMenu.addAction(solverBatchOutput)

		watSolver = QAction('Water solver properties', self)
		watSolver.triggered.connect(self.wat_solver_properties)
		solverMenu.addAction(watSolver)
		self.wat_solver = None

		xenSolver = QAction('Geotherm solver properties', self)
		xenSolver.triggered.connect(self.xen_solver_properties)
		solverMenu.addAction(xenSolver)
		self.xen_solver = None

		meltSolver = QAction('Melt fraction solver properties', self)
		meltSolver.triggered.connect(self.melt_fraction_solver_properties)
		solverMenu.addAction(meltSolver)
		self.melt_frac_solver = None

		#Write FILE BUTTON

		WriteDataButton = QAction('Write Data', self)
		WriteDataButton.triggered.connect(self.write_data)
		writeMenu.addAction(WriteDataButton)

		self.mt_curve_popup = None

		self.home()

	def home(self):

		#Setting up initial variables.

		self.data_existence = False
		self.composition_readfile = False
		self.xenolith_existence = False
		MATE.loaded_file = False

		MATE.plot_style_list = ['ggplot', 'default', 'classic','bmh', 'fast', 'seaborn', 'seaborn-colorblind',
		'seaborn-deep','seaborn-pastel', 'seaborn-dark','fivethirtyeight','grayscale']
		MATE.plot_style_selection = 0

		MATE.dz = 1000.0 #Default interpretation thickness.

		self.drawn = 0
		self.drawn_1 = 0
		self.drawn_11 = 0
		self.drawn_3 = 0
		self.drawn_4 = 0
		self.drawn_5 = 0

		#Setting up class variables for making global

		MATE.q_0 = 40.0
		MATE.T_0 = 273.0
		MATE.A_upper_crust = 1e-3
		MATE.A_lower_crust = 0.4e-3 #mW/m^3
		MATE.hr = 10.0 * 1000.0
		MATE.moho = 38.0 * 1000.0
		MATE.lab = 200 * 1000.0

		#Setting up initial logical parameters
		#These are the parameters like which methods are being used initially.

		MATE.thermal_cond_method = '3' #1 is checked which is composition dependent thermal conductivity

		MATE.al_method = '0' #0 default : Al in opx is valid
		MATE.fe_method = '1' #1 default: Fe is valid
		MATE.pl_method = '1' #1 default: entering Phlg invalid
		MATE.amp_method = '1' #1 default: entering amph invalid
		MATE.melt_method = '1' #1 default: entring melt invalid.
		MATE.part_px_method = '1' #1 defualt:

		self.melt_calc_from_zero_melt = True

		MATE.watermelt_solve_method = 0

		MATE.comp_handling = '0'
		MATE.comp_type = '0'

		MATE.z_xen_method = '0'
		MATE.z_xen_method_2 = '0'
		MATE.xen_temp_err = 50.0
		MATE.xen_pressure_err = 0.3

		MATE.geotherm_inp_temp_method = '1'

		MATE.o2_buffer = 0

		MATE.ol_calib = 3
		MATE.px_calib = 2
		MATE.ol_sol_calib = 3

		MATE.solidus_dry_model_selection = 0
		MATE.solidus_wet_model_selection = 0
		MATE.solidus_carbon_model_selection = 0
		self.solidus_dry_calculated = False
		self.solidus_wet_calculated = False
		self.solidus_carbon_calculated = False

		MATE.melt_fraction_function_names = ['Hirschmann2009 dF/dT = -40P + 450']
		MATE.melt_fraction_functions = ['(-40 * self.p) + 450.0']
		MATE.melt_fraction_function_selection = 0

		self.melt_solution = False

		MATE.model_method_list = ['Proton+Polaron+Ionic', 'Proton Only']
		MATE.model_method_ol = 0
		MATE.model_method_opx = 0
		MATE.model_method_cpx = 0
		MATE.model_method_gt = 0
		MATE.model_method = [MATE.model_method_ol,MATE.model_method_opx,MATE.model_method_cpx,MATE.model_method_gt]
		MATE.ol_cond_selection = 0
		MATE.opx_cond_selection = 0
		MATE.cpx_cond_selection = 0
		MATE.gt_cond_selection = 0
		MATE.px_cond_method = 0
		MATE.amp_cond_selection = 0
		MATE.pl_cond_selection = 0
		MATE.sp_chr_cond_selection = 0
		MATE.melt_cond_selection = 0

		MATE.melt_partitions_calculated = False
		MATE.mineral_partitions_calculated = False

		MATE.px_display_item = 0

		MATE.al_opx_model_select = 0

		MATE.ol_dry_selection = 0
		MATE.opx_dry_selection = 0
		MATE.cpx_dry_selection = 0
		MATE.gt_dry_selection = 0

		MATE.phs_mix_method = 0

		MATE.phs_melt_mix_method = 0

		MATE.mt_input_selection = 0
		self.ModEM_dat_read = False
		self.ModEM_model_read = False
		MATE.ModEM_data_submit = False
		self.csv_MT_read = False
		self.water_end = False

		MATE.plot_sel_modem = 120
		MATE.curve_method = 0
		MATE.station_name_select = 0

		MATE.sol_method = 0
		MATE.sol_plot = False

		MATE.amph_stab_select = 0

		MATE.mt_model_errs = False
		MATE.modem_mt_err_method = 1
		MATE.mt_err_method = 0
		MATE.mt_err_val = 0.25
		MATE.mt_err_val_str = str(0.25)

		MATE.D_gb = 0.1
		self.delta = 1e-9 #in m
		MATE.GB_ol_select = 0
		MATE.GB_gt_select = 0

		MATE.trange_method = 1
		MATE.trange_list = ['Yes','No']

		MATE.sol_plot_method = 0
		MATE.sol_plot_type_list = ['Colored Fields','Dashed Line']

		MATE.sol_plot_scale_method = 0
		MATE.sol_plot_scale_list = ['Linear', 'Log']

		MATE.bulk_water_method = 0
		MATE.bulk_water_method_list = ['Yes','No']

		MATE.condrange_method = 0
		MATE.condrange_list = ['Yes','No']

		MATE.condlinestyle_select = 0
		MATE.condlinestyle_list = ['-','--','-.',':']

		self.upper_bound_load = False
		self.lower_bound_load = False

		MATE.condlinewidth = 2.0

		MATE.condplotlim_down = -1
		MATE.condplotlim_up = 7

		MATE.hydr_part_method = 1

		MATE.sol_model_pref = ['Yes','No']
		MATE.sol_model_pref_select = 1

		MATE.add_water_method = 0
		MATE.water_file_read = False

		MATE.solver_search_ratio = 0.1
		MATE.water_search_increment_start = 4.0

		self.last_draw_method = 0

		MATE.boundslist = ['No Bounds', 'HS Bounds', 'Parallel-Series Bounds']
		MATE.bounds_select = 0

		self.write_out = False

		MATE.lodge_check = False

		self.water_error_calculated = False

		MATE.spinel_stab_select = 1
		MATE.P_sp_manual = None
		MATE.adiabat_options = ['No Adiabat', 'Katsura2022']
		MATE.adiabat_selection = 1

		self.fo2_input = False
		self.water_inverted = False

		MATE.w_inp_method = '0'
		MATE.cond_uncert_method = '0'

		MATE.waterplotlim_up = 600.0
		MATE.geotherm_up = 1800.0
		MATE.geotherm_asked = False

		MATE.heat_flow_search_start = 35
		MATE.heat_flow_search_end = 45
		MATE.heat_flow_search_incr = 0.25

		MATE.res_profile_plot_list = []
		MATE.res_profile_max_plot_list = []
		MATE.res_profile_min_plot_list = []
		MATE.z_depth_plot_list = []
		
		#Wallace_Green Oxidised solidus curve points in P-T(C)
		self.Wallace_Green_1988_T = [1003.6,1015.5,1024.7,1034.8,1044.9,1053.1,1061.4,1066,1068.8,1069.8,1048.9,
		1027.1,1008,991.61,980.71,972.56,972.61,972.67,971.82,971.87,973.75,978.34,986.6,993.04,999.47,1010.5,
		1023.3,1033.4,1047.1,1063.6,1078.2,1090.1,1103.8,1113.9,1125.8,1135.9,1148.7,1164.3,1183.5]
		self.Wallace_Green_1988_P = [0.019069,0.24061,0.45282,0.67428,0.90495,1.1539,1.3845,1.6242,1.8269,1.9098,
		1.8996,1.9078,1.9253,1.943,1.9701,2.0526,2.1908,2.3473,2.513,2.6695,2.817,2.9553,3.1675,3.3611,3.564,3.7855,
		4.0531,4.2838,4.5607,4.81,5.0593,5.2993,5.5578,5.7884,6.01,6.213,6.5083,6.8405,7.2005]
		
		MATE.solidus_wg_plot = False
		
		self.Foley_2022_T = [1011.6,1273.5]
		self.Foley_2022_P = [1.4147,4.9454]
		
		MATE.solidus_foley_plot = False
		
		self.Green_2010_T = [1140,1093.8,1053.8,1030.8,1010.8,996.92,989.23,984.62,978.46,976.92,970.77,970.77,975.38,
		980,987.69,996.92,1004.6,1020,1033.8,1047.7,1069.2,1092.3,1110.8,1140,1167.7,1195.4,1223.1,1238.5,1256.9,1278.5,
		1300,1324.6,1350.8,1376.9,1398.5,1407.7]
		self.Green_2010_P = [0.02381,0.095238,0.16667,0.2381,0.36508,0.48413,0.66667,0.80159,0.93651,1.0714,1.254,1.4841,
		1.7143,1.9048,2.1032,2.2619,2.3968,2.5714,2.7381,2.8889,3.0794,3.246,3.3968,3.5873,3.7698,3.9524,4.1349,4.2698,
		4.4444,4.6508,4.873,5.1905,5.5238,5.8968,6.2619,6.4683]
		
		MATE.solidus_green2010_plot = False
		
		self.color_list_csv = []

		MATE.csv_file_selection = 0
		MATE.text = "Depth(km),H2O_bulk(ppm),CO2_melt(ppm),ol_frac,opx_frac,cpx_frac,gt_frac,sp_chr_frac,pl_frac,amp_frac,cond_frac,cond_cond(ohm_m),melt_mass_frac,XFe-ol,XFe-opx,XFe-cpx,XFe-gt,m_ol,m_opx,m_cpx,m_gt,m_sp_chr,m_pl,m_amp,m_cond,m_melt,Al-opx(wt%),Ti-ol(wt%),NaO_melt(wt%),K2O_melt(wt%),t_k_cond(W/mK),fl_pl(wt%),ol_gs(mm),heat_prod(mW/m^2)\n"

		#Setting up the global list where the model parameters will be appended.

		self.T_list = []
		self.bulk_cond_max_list = []
		self.bulk_cond_min_list = []
		self.bulk_cond_list = []
		self.linestyle_list = []
		self.linewidth_list = []
		self.h2o_bulk_list = []
		self.h2o_list = []
		self.h2o_max_list = []
		self.h2o_min_list = []
		self.ol_h2o_list = []
		self.ol_h2o_max_list = []
		self.ol_h2o_min_list = []
		self.opx_h2o_list = []
		self.opx_h2o_max_list = []
		self.opx_h2o_min_list = []
		self.cpx_h2o_list = []
		self.cpx_h2o_max_list = []
		self.cpx_h2o_min_list = []
		self.px_h2o_list = []
		self.px_h2o_max_list = []
		self.px_h2o_min_list = []
		self.gt_h2o_list = []
		self.gt_h2o_max_list = []
		self.gt_h2o_min_list = []
		self.amp_h2o_list = []
		self.amp_h2o_max_list = []
		self.amp_h2o_min_list = []
		self.pl_h2o_list = []
		self.pl_h2o_max_list = []
		self.pl_h2o_min_list = []
		self.melt_h2o_list = []
		self.melt_h2o_max_list = []
		self.melt_h2o_min_list = []

		#Reading parameter files...

		self.read_cond_models()
		self.read_cond_dry_models()
		self.read_params()

		#Defining buttons on the MainWindow
		properties_mark = QLabel(self)
		properties_mark.setText('Setup')
		properties_mark.setStyleSheet("QLabel {font:bold};fontsize: 10pt;color: red")
		properties_mark.move(65,35)

		comp_btn = QPushButton('Composition Entry',self)
		comp_btn.move(10,65)
		comp_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #c8cccc}")
		comp_btn.clicked.connect(self.comp_popup)
		self.d_pop = None

		depth_btn = QPushButton('Depth Range',self)
		depth_btn.move(10,100)
		depth_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #c8cccc}")
		depth_btn.clicked.connect(self.depth_popup)
		self.depth_pop = None

		descomp_btn = QPushButton('Composition Setup',self)
		descomp_btn.move(10,135)
		descomp_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #c8cccc}")
		descomp_btn.clicked.connect(self.descomp_popup)
		self.editor_pop = None

		geot_btn = QPushButton('Geotherm',self)
		geot_btn.move(10,170)
		geot_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #c8cccc}")
		geot_btn.clicked.connect(self.geotherm_popup)

		part_btn = QPushButton('Water Partitioning', self)
		part_btn.move(10,205)
		part_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #c8cccc}")
		part_btn.clicked.connect(self.partition_popup)
		self.p_pop = None

		sol_btn = QPushButton('Water Solubility', self)
		sol_btn.move(10,240)
		sol_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #c8cccc}")
		sol_btn.clicked.connect(self.solubility_open)
		self.sol_input_popup = None

		cond_btn = QPushButton('Conductivity Models', self)
		cond_btn.move(10,275)
		cond_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #c8cccc}")
		cond_btn.clicked.connect(self.conductivity_popup)
		self.cond_pop = None

		mix_btn = QPushButton('Phase-Mixing', self)
		mix_btn.move(10,310)
		mix_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #c8cccc}")
		mix_btn.clicked.connect(self.phase_mixing_popup)
		self.phs_mix_popup = None

		plotting_mark = QLabel(self)
		plotting_mark.setText('Calculating')
		plotting_mark.setStyleSheet("QLabel {font:bold};fontsize: 10pt;color: red")
		plotting_mark.move(45,345)

		self.act_comp_btn = QPushButton('Plot Composition',self)
		self.act_comp_btn.move(10,380)
		self.act_comp_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #93db88}")
		self.act_comp_btn.clicked.connect(self.plot_composition_button)

		self.geot_btn = QPushButton('Plot Geotherm',self)
		self.geot_btn.move(10,415)
		self.geot_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #93db88}")
		self.geot_btn.clicked.connect(self.plot_geotherm_button)

		geot_btn_reset = QPushButton('Geotherm Reset',self)
		geot_btn_reset.move(10,450)
		geot_btn_reset.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #e8b1a0}")
		geot_btn_reset.clicked.connect(self.reset_geotherm)

		self.plt_water_btn = QPushButton('Plot Water',self)
		self.plt_water_btn.move(10,485)
		self.plt_water_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #93db88}")
		self.plt_water_btn.clicked.connect(self.plot_water_button)

		plt_water_btn_reset = QPushButton('Water Reset',self)
		plt_water_btn_reset.move(10,520)
		plt_water_btn_reset.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #e8b1a0}")
		plt_water_btn_reset.clicked.connect(self.plot_water_reset)

		self.plt_cond_btn = QPushButton('Plot Conductivity',self)
		self.plt_cond_btn.move(10,555)
		self.plt_cond_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #93db88}")
		self.plt_cond_btn.clicked.connect(self.plot_conductivity_button)

		plt_cond_btn_reset = QPushButton('Conductivity Reset',self)
		plt_cond_btn_reset.move(10,590)
		plt_cond_btn_reset.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #e8b1a0}")
		plt_cond_btn_reset.clicked.connect(self.plot_conductivity_reset)

		self.store_lower_bound_btn = QPushButton('Store Lower-Bound',self)
		self.store_lower_bound_btn.move(10,625)
		self.store_lower_bound_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #7daedb}")
		self.store_lower_bound_btn.clicked.connect(self.store_lower_bound_cond)

		self.store_upper_bound_btn = QPushButton('Store Upper-Bound',self)
		self.store_upper_bound_btn.move(10,660)
		self.store_upper_bound_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #7daedb}")
		self.store_upper_bound_btn.clicked.connect(self.store_upper_bound_cond)

		plot_bounds_btn = QPushButton('Plot Field',self)
		plot_bounds_btn.move(10,695)
		plot_bounds_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #93db88}")
		plot_bounds_btn.clicked.connect(self.plot_bounds)

		solve_geotherm_butn = QPushButton('Solve Geotherm',self)
		solve_geotherm_butn.move(10,730)
		solve_geotherm_butn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #bf490f}")
		solve_geotherm_butn.clicked.connect(self.solve_for_geotherm)

		solve_melt_fraction_butn = QPushButton('Solve Melt Fraction',self)
		solve_melt_fraction_butn.move(10,765)
		solve_melt_fraction_butn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #870000}")
		solve_melt_fraction_butn.clicked.connect(self.solve_for_melt_fraction)

		solve_butn = QPushButton('Solve Water',self)
		solve_butn.move(10,800)
		solve_butn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #663794}")
		solve_butn.clicked.connect(self.solve_for_water)

		solve_butn = QPushButton('Solve Water+Melt',self)
		solve_butn.move(10,835)
		solve_butn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #a12b91}")
		solve_butn.clicked.connect(self.solve_for_water_melt)

		plt_reset_btn = QPushButton('Clear All',self)
		plt_reset_btn.move(10,870)
		plt_reset_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #de5d5d}")
		plt_reset_btn.clicked.connect(self.reset_all_plot)

		plt_legend_btn = QPushButton('Plot Legend',self)
		plt_legend_btn.move(10,905)
		plt_legend_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #ddb62b}")
		plt_legend_btn.clicked.connect(self.plot_legend)

		self.progressBar = QProgressBar(self)
		self.progressBar.setGeometry(10, 950, 150, 30)

		#Setting up the blank canvas on the main page.

		self.canvas_widget = QFrame(self)
		self.canvas_widget.setGeometry(200,50,1550,925)
		self.canvas_widget.setStyleSheet("border:1.25px solid #768795")
		self.canvaslayout = QVBoxLayout(self.canvas_widget)

		#Using the internal matplotlib style ggplot
		plt.style.use('ggplot')
		self.fig = Figure()
		self.fig.patch.set_facecolor('#EFF0F1')

		self.canvas = FigureCanvas(self.fig)
		self.toolbar = NavigationToolbar(self.canvas, self)
		self.toolbar.setStyleSheet("QToolBar { border: 0px ; : #889DAE}")
		self.canvaslayout.addWidget(self.toolbar)
		self.canvaslayout.addWidget(self.canvas)

		self.show()

	#Some local functions that is used in simple calculations read_csv,find_nearest,interception

	def read_csv(self,filename,delim):

		#Simple function for reading csv files and give out filtered output for given delimiter (delim)

		file_obj = open(filename,'rt',encoding = "utf8") #Creating file object
		file_csv = csv.reader(file_obj,delimiter = delim) #Reading the file object with csv module, delimiter assigned to ','
		data = [] #Creating empty array to append data

		#Appending data from csb object
		for row in file_csv:
			data.append(row)

		#Filtering data for None elements read.
		for j in range(0,len(data)):
			data[j] = list(filter(None,data[j]))
		data = list(filter(None,data))

		return data

	def find_nearest(self,array,value):

		#Function ot find nearest value from an array
		idx = (np.abs(array-value)).argmin()

		return array[idx]

	def interception(self,y1,y2):
		#Local function to calculate the interception point of arrays that have
		#used same temperature variation as paramaeter:(y1(T),y2(T))
		idx = np.argwhere(np.diff(np.sign(y1 - y2)) != 0)

		return idx

	def read_cond_models(self):

		#A function that reads conductivity model files and get the data.

		self.ol_cond_data = self.read_csv(os.path.join(self.core_path, 'cond_models' , 'ol.csv'),delim = ',')
		self.opx_cond_data = self.read_csv(os.path.join(self.core_path, 'cond_models' , 'opx.csv'),delim = ',')
		self.cpx_cond_data = self.read_csv(os.path.join(self.core_path, 'cond_models' , 'cpx.csv'),delim = ',')
		self.gt_cond_data = self.read_csv(os.path.join(self.core_path, 'cond_models' , 'gt.csv'),delim = ',')
		self.sp_chr_cond_data = self.read_csv(os.path.join(self.core_path, 'cond_models' , 'sp_chr.csv'),delim = ',')
		self.amp_cond_data = self.read_csv(os.path.join(self.core_path, 'cond_models' , 'amp.csv'),delim = ',')
		self.pl_cond_data = self.read_csv(os.path.join(self.core_path, 'cond_models' , 'phlg.csv'),delim = ',')
		self.melt_cond_data = self.read_csv(os.path.join(self.core_path, 'cond_models' , 'melt.csv'),delim = ',')

		self.cond_data_array = [self.ol_cond_data,self.opx_cond_data,self.cpx_cond_data,self.gt_cond_data,self.amp_cond_data,self.pl_cond_data,self.sp_chr_cond_data,self.melt_cond_data]

		len_ol = len(self.ol_cond_data) - 1
		len_opx = len(self.opx_cond_data) - 1
		len_cpx = len(self.cpx_cond_data) - 1
		len_gt = len(self.gt_cond_data) - 1
		len_sp_chr = len(self.sp_chr_cond_data) - 1
		len_amp = len(self.amp_cond_data) - 1
		len_pl = len(self.pl_cond_data) - 1
		len_melt = len(self.melt_cond_data) - 1

		#Creating empty arrays for appending new data.
		MATE.name = [[None] * len_ol , [None] * len_opx,[None] * len_cpx, [None] * len_gt,[None] * len_amp,[None] * len_pl, [None] * len_sp_chr, [None] * len_melt]
		MATE.type = [[None] * len_ol , [None] * len_opx,[None] * len_cpx, [None] * len_gt,[None] * len_amp,[None] * len_pl, [None] * len_sp_chr, [None] * len_melt]
		MATE.t_min = [[None] * len_ol , [None] * len_opx, [None] * len_cpx, [None] * len_gt,[None] * len_amp,[None] * len_pl, [None] * len_sp_chr, [None] * len_melt]
		MATE.t_max = [[None] * len_ol , [None] * len_opx, [None] * len_cpx, [None] * len_gt,[None] * len_amp,[None] * len_pl, [None] * len_sp_chr, [None] * len_melt]
		self.p_min = [[None] * len_ol , [None] * len_opx, [None] * len_cpx, [None] * len_gt,[None] * len_amp,[None] * len_pl, [None] * len_sp_chr, [None] * len_melt]
		self.p_max = [[None] * len_ol , [None] * len_opx, [None] * len_cpx, [None] * len_gt,[None] * len_amp,[None] * len_pl, [None] * len_sp_chr, [None] * len_melt]
		self.w_calib = [[None] * len_ol , [None] * len_opx, [None] * len_cpx, [None] * len_gt,[None] * len_amp,[None] * len_pl, [None] * len_sp_chr, [None] * len_melt]
		self.mg_cond = [[None] * len_ol , [None] * len_opx, [None] * len_cpx, [None] * len_gt,[None] * len_amp,[None] * len_pl, [None] * len_sp_chr, [None] * len_melt]
		self.sigma_i = [[None] * len_ol , [None] * len_opx, [None] * len_cpx, [None] * len_gt,[None] * len_amp,[None] * len_pl,[None] * len_sp_chr, [None] * len_melt]
		self.sigma_i_err = [[None] * len_ol , [None] * len_opx, [None] * len_cpx, [None] * len_gt,[None] * len_amp,[None] * len_pl,[None] * len_sp_chr, [None] * len_melt]
		self.h_i = [[None] * len_ol , [None] * len_opx, [None] * len_cpx, [None] * len_gt,[None] * len_amp,[None] * len_pl,[None] * len_sp_chr, [None] * len_melt]
		self.h_i_err =[[None] * len_ol , [None] * len_opx, [None] * len_cpx, [None] * len_gt,[None] * len_amp,[None] * len_pl,[None] * len_sp_chr, [None] * len_melt]
		self.sigma_pol = [[None] * len_ol , [None] * len_opx, [None] * len_cpx, [None] * len_gt,[None] * len_amp,[None] * len_pl,[None] * len_sp_chr, [None] * len_melt]
		self.sigma_pol_err = [[None] * len_ol , [None] * len_opx, [None] * len_cpx, [None] * len_gt,[None] * len_amp,[None] * len_pl,[None] * len_sp_chr, [None] * len_melt]
		self.h_pol = [[None] * len_ol , [None] * len_opx, [None] * len_cpx, [None] * len_gt,[None] * len_amp,[None] * len_pl,[None] * len_sp_chr, [None] * len_melt]
		self.h_pol_err = [[None] * len_ol , [None] * len_opx, [None] * len_cpx, [None] * len_gt,[None] * len_amp,[None] * len_pl,[None] * len_sp_chr, [None] * len_melt]
		self.sigma_p = [[None] * len_ol , [None] * len_opx, [None] * len_cpx, [None] * len_gt,[None] * len_amp,[None] * len_pl,[None] * len_sp_chr, [None] * len_melt]
		self.sigma_p_err = [[None] * len_ol , [None] * len_opx, [None] * len_cpx, [None] * len_gt,[None] * len_amp,[None] * len_pl,[None] * len_sp_chr, [None] * len_melt]
		self.h_p = [[None] * len_ol , [None] * len_opx, [None] * len_cpx, [None] * len_gt,[None] * len_amp,[None] * len_pl,[None] * len_sp_chr, [None] * len_melt]
		self.h_p_err = [[None] * len_ol , [None] * len_opx, [None] * len_cpx, [None] * len_gt,[None] * len_amp,[None] * len_pl,[None] * len_sp_chr, [None] * len_melt]
		self.r = [[None] * len_ol , [None] * len_opx, [None] * len_cpx, [None] * len_gt,[None] * len_amp,[None] * len_pl,[None] * len_sp_chr, [None] * len_melt]
		self.r_err = [[None] * len_ol , [None] * len_opx, [None] * len_cpx, [None] * len_gt,[None] * len_amp,[None] * len_pl,[None] * len_sp_chr, [None] * len_melt]
		self.alpha_p = [[None] * len_ol , [None] * len_opx, [None] * len_cpx, [None] * len_gt,[None] * len_amp,[None] * len_pl,[None] * len_sp_chr, [None] * len_melt]
		self.alpha_p_err = [[None] * len_ol , [None] * len_opx, [None] * len_cpx, [None] * len_gt,[None] * len_amp,[None] * len_pl,[None] * len_sp_chr, [None] * len_melt]
		self.wtype = [[None] * len_ol , [None] * len_opx, [None] * len_cpx, [None] * len_gt,[None] * len_amp,[None] * len_pl,[None] * len_sp_chr, [None] * len_melt]
		self.dens_mat = [[None] * len_ol , [None] * len_opx, [None] * len_cpx, [None] * len_gt,[None] * len_amp,[None] * len_pl,[None] * len_sp_chr, [None] * len_melt]

		#Filling up the arrays.
		for i in range(0,len(MATE.type)):
			count = 1
			for j in range(0,len(MATE.type[i])):
				MATE.name[i][count-1] = self.cond_data_array[i][count][0]
				MATE.type[i][count-1] = self.cond_data_array[i][count][1]
				MATE.t_min[i][count-1] = float(self.cond_data_array[i][count][2])
				MATE.t_max[i][count-1] = float(self.cond_data_array[i][count][3])
				self.p_min[i][count-1] = float(self.cond_data_array[i][count][4])
				self.p_max[i][count-1] = float(self.cond_data_array[i][count][5])
				self.w_calib[i][count-1] = int(self.cond_data_array[i][count][6])
				self.mg_cond[i][count-1] = float(self.cond_data_array[i][count][7])
				self.sigma_i[i][count-1] = float(self.cond_data_array[i][count][8])
				self.sigma_i_err[i][count-1] = float(self.cond_data_array[i][count][9])
				self.h_i[i][count-1] = float(self.cond_data_array[i][count][10])
				self.h_i_err[i][count-1] = float(self.cond_data_array[i][count][11])
				self.sigma_pol[i][count-1] = float(self.cond_data_array[i][count][12])
				self.sigma_pol_err[i][count-1] = float(self.cond_data_array[i][count][13])
				self.h_pol[i][count-1] = float(self.cond_data_array[i][count][14])
				self.h_pol_err[i][count-1] = float(self.cond_data_array[i][count][15])
				self.sigma_p[i][count-1] = float(self.cond_data_array[i][count][16])
				self.sigma_p_err[i][count-1] = float(self.cond_data_array[i][count][17])
				self.h_p[i][count-1] = float(self.cond_data_array[i][count][18])
				self.h_p_err[i][count-1] = float(self.cond_data_array[i][count][19])
				self.r[i][count-1] = float(self.cond_data_array[i][count][20])
				self.r_err[i][count-1] = float(self.cond_data_array[i][count][21])
				self.alpha_p[i][count-1] = float(self.cond_data_array[i][count][22])
				self.alpha_p_err[i][count-1] = float(self.cond_data_array[i][count][23])
				self.wtype[i][count-1] = int(self.cond_data_array[i][count][24])
				self.dens_mat[i][count-1] = float(self.cond_data_array[i][count][25])

				count += 1

	def read_cond_dry_models(self):

		#A function that reads the dry conductivity models from the external csv files.
		self.ol_dry_cond_data = self.read_csv(os.path.join(self.core_path, 'cond_models' , 'ol_dry.csv'),delim = ',')
		self.opx_dry_cond_data = self.read_csv(os.path.join(self.core_path, 'cond_models' , 'opx_dry.csv'),delim = ',')
		self.cpx_dry_cond_data = self.read_csv(os.path.join(self.core_path, 'cond_models' , 'cpx_dry.csv'),delim = ',')
		self.gt_dry_cond_data = self.read_csv(os.path.join(self.core_path, 'cond_models' , 'gt_dry.csv'),delim = ',')

		self.cond_dry_data_array = [self.ol_dry_cond_data,self.opx_dry_cond_data,self.cpx_dry_cond_data,self.gt_dry_cond_data]

		MATE.name_dry = [[None] * (len(self.ol_dry_cond_data)-1) , [None] * (len(self.opx_dry_cond_data) - 1),[None] * (len(self.cpx_dry_cond_data) - 1), [None] * (len(self.gt_dry_cond_data)-1)]
		MATE.type_dry = [[None] * (len(self.ol_dry_cond_data)-1) , [None] * (len(self.opx_dry_cond_data) - 1),[None] * (len(self.cpx_dry_cond_data) - 1), [None] * (len(self.gt_dry_cond_data)-1)]
		MATE.t_min_dry = [[None] * (len(self.ol_dry_cond_data)-1) , [None] * (len(self.opx_dry_cond_data) - 1),[None] * (len(self.cpx_dry_cond_data) - 1), [None] * (len(self.gt_dry_cond_data)-1)]
		MATE.t_max_dry = [[None] * (len(self.ol_dry_cond_data)-1) , [None] * (len(self.opx_dry_cond_data) - 1),[None] * (len(self.cpx_dry_cond_data) - 1), [None] * (len(self.gt_dry_cond_data)-1)]
		self.p_min_dry = [[None] * (len(self.ol_dry_cond_data)-1) , [None] * (len(self.opx_dry_cond_data) - 1),[None] * (len(self.cpx_dry_cond_data) - 1), [None] * (len(self.gt_dry_cond_data)-1)]
		self.p_max_dry = [[None] * (len(self.ol_dry_cond_data)-1) , [None] * (len(self.opx_dry_cond_data) - 1),[None] * (len(self.cpx_dry_cond_data) - 1), [None] * (len(self.gt_dry_cond_data)-1)]
		self.mg_cond_dry = [[None] * (len(self.ol_dry_cond_data)-1) , [None] * (len(self.opx_dry_cond_data) - 1),[None] * (len(self.cpx_dry_cond_data) - 1), [None] * (len(self.gt_dry_cond_data)-1)]
		self.sigma_i_dry = [[None] * (len(self.ol_dry_cond_data)-1) , [None] * (len(self.opx_dry_cond_data) - 1),[None] * (len(self.cpx_dry_cond_data) - 1), [None] * (len(self.gt_dry_cond_data)-1)]
		self.sigma_i_dry_err = [[None] * (len(self.ol_dry_cond_data)-1) , [None] * (len(self.opx_dry_cond_data) - 1),[None] * (len(self.cpx_dry_cond_data) - 1), [None] * (len(self.gt_dry_cond_data)-1)]
		self.h_i_dry = [[None] * (len(self.ol_dry_cond_data)-1) , [None] * (len(self.opx_dry_cond_data) - 1),[None] * (len(self.cpx_dry_cond_data) - 1), [None] * (len(self.gt_dry_cond_data)-1)]
		self.h_i_dry_err =[[None] * (len(self.ol_dry_cond_data)-1) , [None] * (len(self.opx_dry_cond_data) - 1),[None] * (len(self.cpx_dry_cond_data) - 1), [None] * (len(self.gt_dry_cond_data)-1)]
		self.sigma_pol_dry = [[None] * (len(self.ol_dry_cond_data)-1) , [None] * (len(self.opx_dry_cond_data) - 1),[None] * (len(self.cpx_dry_cond_data) - 1), [None] * (len(self.gt_dry_cond_data)-1)]
		self.sigma_pol_dry_err = [[None] * (len(self.ol_dry_cond_data)-1) , [None] * (len(self.opx_dry_cond_data) - 1),[None] * (len(self.cpx_dry_cond_data) - 1), [None] * (len(self.gt_dry_cond_data)-1)]
		self.h_pol_dry = [[None] * (len(self.ol_dry_cond_data)-1) , [None] * (len(self.opx_dry_cond_data) - 1),[None] * (len(self.cpx_dry_cond_data) - 1), [None] * (len(self.gt_dry_cond_data)-1)]
		self.h_pol_dry_err = [[None] * (len(self.ol_dry_cond_data)-1) , [None] * (len(self.opx_dry_cond_data) - 1),[None] * (len(self.cpx_dry_cond_data) - 1), [None] * (len(self.gt_dry_cond_data)-1)]

		for i in range(0,len(self.cond_dry_data_array)):
			count = 1
			for j in range(0,len(self.cond_dry_data_array[i])-1):

				MATE.name_dry[i][count-1] = self.cond_dry_data_array[i][count][0]
				MATE.type_dry[i][count-1] = self.cond_dry_data_array[i][count][1]
				MATE.t_min_dry[i][count-1] = float(self.cond_dry_data_array[i][count][2])
				MATE.t_max_dry[i][count-1] = float(self.cond_dry_data_array[i][count][3])
				self.p_min_dry[i][count-1] = float(self.cond_dry_data_array[i][count][4])
				self.p_max_dry[i][count-1] = float(self.cond_dry_data_array[i][count][5])
				self.mg_cond_dry[i][count-1] = float(self.cond_dry_data_array[i][count][6])
				self.sigma_i_dry[i][count-1] = float(self.cond_dry_data_array[i][count][7])
				self.sigma_i_dry_err[i][count-1] = float(self.cond_dry_data_array[i][count][8])
				self.h_i_dry[i][count-1] = float(self.cond_dry_data_array[i][count][9])
				self.h_i_dry_err[i][count-1] = float(self.cond_dry_data_array[i][count][10])
				self.sigma_pol_dry[i][count-1] = float(self.cond_dry_data_array[i][count][11])
				self.sigma_pol_dry_err[i][count-1] = float(self.cond_dry_data_array[i][count][12])
				self.h_pol_dry[i][count-1] = float(self.cond_dry_data_array[i][count][13])
				self.h_pol_dry_err[i][count-1] = float(self.cond_dry_data_array[i][count][14])
				count += 1

	def read_params(self):

		#READING THE PARAMETERS IN PARAMS.CSV WHICH ARE GENERAL PHYSICAL CONSTANTS
		#AND PROPERTIES OF MATERIALS

		params_dat = self.read_csv(os.path.join(self.core_path, 'params.csv'), delim = ',')

		self.g = float(params_dat[0][1]) # in kg/
		self.R = float(params_dat[1][1])
		self.rho_crust = float(params_dat[2][1])
		self.rho_mantle = float(params_dat[3][1])
		self.rho_forst = float(params_dat[4][1])
		self.rho_fayal = float(params_dat[5][1])
		self.rho_enst = float(params_dat[6][1])
		self.rho_ferrosil = float(params_dat[7][1])
		self.rho_diop = float(params_dat[8][1])
		self.rho_heden = float(params_dat[9][1])
		self.rho_pyrop = float(params_dat[10][1])
		self.rho_alm = float(params_dat[11][1])
		self.rho_sp_chr = float(params_dat[12][1])
		self.rho_amph = float(params_dat[13][1])
		self.rho_phlg = float(params_dat[14][1])
		self.avog = float(params_dat[15][1])
		self.boltz = float(params_dat[16][1])
		self.el_q = float(params_dat[17][1])
		MATE.spreadsheet = str(params_dat[18][1])
		self.mu = 4.0 * np.pi * 10**(-7)

		#READING THE GEOTHERM CALCULATION PARAMETERS FROM HASTEROK AND CHAPMAN (2011) -

		hasterok_vanilla_dat = self.read_csv(os.path.join(self.core_path, 'thermal', 'hasterok_vanilla.csv'), delim = ',')

		self.k0_upper_1 = float(hasterok_vanilla_dat[0][1])
		self.k0_upper_2 = float(hasterok_vanilla_dat[1][1])
		self.k0_mid_1 = float(hasterok_vanilla_dat[2][1])
		self.k0_mid_2 = float(hasterok_vanilla_dat[3][1])
		self.k0_low_1 = float(hasterok_vanilla_dat[4][1])
		self.k0_low_2 =float(hasterok_vanilla_dat[5][1])
		self.k0_mantle_sp = float(hasterok_vanilla_dat[6][1])
		self.k0_mantle_gt = float(hasterok_vanilla_dat[7][1])

		self.k1_upper_1 = float(hasterok_vanilla_dat[8][1])
		self.k1_upper_2 = float(hasterok_vanilla_dat[9][1])
		self.k1_mid_1 = float(hasterok_vanilla_dat[10][1])
		self.k1_mid_2 = float(hasterok_vanilla_dat[11][1])
		self.k1_low_1 = float(hasterok_vanilla_dat[12][1])
		self.k1_low_2 = float(hasterok_vanilla_dat[13][1])
		self.k1_mantle_sp = float(hasterok_vanilla_dat[14][1])
		self.k1_mantle_gt =float(hasterok_vanilla_dat[15][1])

		self.k2_upper_1 = float(hasterok_vanilla_dat[16][1])
		self.k2_upper_2 = float(hasterok_vanilla_dat[17][1])
		self.k2_mid_1 = float(hasterok_vanilla_dat[18][1])
		self.k2_mid_2 = float(hasterok_vanilla_dat[19][1])
		self.k2_low_1 = float(hasterok_vanilla_dat[20][1])
		self.k2_low_2 = float(hasterok_vanilla_dat[21][1])
		self.k2_mantle_sp = float(hasterok_vanilla_dat[22][1])
		self.k2_mantle_gt = float(hasterok_vanilla_dat[23][1])

		self.k3_upper_1 = float(hasterok_vanilla_dat[24][1])
		self.k3_upper_2 = float(hasterok_vanilla_dat[25][1])
		self.k3_mid_1 = float(hasterok_vanilla_dat[26][1])
		self.k3_mid_2 = float(hasterok_vanilla_dat[27][1])
		self.k3_low_1 = float(hasterok_vanilla_dat[28][1])
		self.k3_low_2 = float(hasterok_vanilla_dat[29][1])
		self.k3_mantle_sp = float(hasterok_vanilla_dat[30][1])
		self.k3_mantle_gt = float(hasterok_vanilla_dat[31][1])
		self.t_criterion = float(hasterok_vanilla_dat[32][1])

		self.thermal_data = self.read_csv(os.path.join(self.core_path, 'thermal', 'thermal.csv'), delim = ',')

		self.k_0 = []
		self.k_1 = []
		self.k_2 = []
		self.n_thermal = []
		self.lambda_r_max = []
		self.omega_thermal = []
		self.T_ref = []
		self.rho_thermal = []
		self.K_T = []
		self.K_T2 = []

		for i in range(1,len(self.thermal_data)):

			self.k_0.append(float(self.thermal_data[i][1]))
			self.k_1.append(float(self.thermal_data[i][2]))
			self.k_2.append(float(self.thermal_data[i][3]))
			self.n_thermal.append(float(self.thermal_data[i][4]))
			self.lambda_r_max.append(float(self.thermal_data[i][5]))
			self.omega_thermal.append(float(self.thermal_data[i][6]))
			self.T_ref.append(float(self.thermal_data[i][7]))
			self.rho_thermal.append(float(self.thermal_data[i][8]))
			self.K_T.append(float(self.thermal_data[i][9]))
			self.K_T2.append(float(self.thermal_data[i][10]))

		#WATER PARTITIONING PARAMETERS OF PYROXENES

		self.px_data = self.read_csv(os.path.join(self.core_path, 'water_part', 'px_part.csv'), delim = ',')

		MATE.d_px_items = []
		MATE.d_px_type = []
		self.d_px_function = []
		self.d_px_function_2 = []
		self.d_px_change = []
		for i in range(4,len(self.px_data)):
			MATE.d_px_items.append("Type " + self.px_data[i][1] + ' - ' + self.px_data[i][-1])
			MATE.d_px_type.append(self.px_data[i][1])
			if self.px_data[i][1] == '0' or self.px_data[i][1] == '1' or self.px_data[i][1] == '3':
				self.d_px_function.append(self.px_data[i][2])
				self.d_px_function_2.append(None)
				self.d_px_change.append(None)
			elif self.px_data[i][1] == '2':
				self.d_px_function.append(self.px_data[i][2])
				self.d_px_function_2.append(self.px_data[i][3])
				self.d_px_change.append(self.px_data[i][4])
			elif self.px_data[i][1] == '4':
				self.d_px_function.append(self.px_data[i][2]) #In this case only a constant value
				self.d_px_function_2.append(None) #In this case error rate
				self.d_px_change.append(None)

		MATE.px_part_select = 0

		#WATER PARTITIONING PARAMETERS OF OPX

		self.opx_data = self.read_csv(os.path.join(self.core_path, 'water_part', 'opx_part.csv'), delim = ',')

		MATE.d_opx_items = []
		MATE.d_opx_type = []
		self.dopx_function = []
		self.dopx_function_2 = []
		self.dopx_change = []

		for i in range(1,len(self.opx_data)):
			MATE.d_opx_items.append("Type " + self.opx_data[i][1] + ' - ' + self.opx_data[i][-1])
			MATE.d_opx_type.append(self.opx_data[i][1])
			self.dopx_function.append(self.opx_data[i][2])
			self.dopx_function_2.append(self.opx_data[i][3])
			self.dopx_change.append(float(self.opx_data[i][4]))

		MATE.opx_part_select = 0
		MATE.opx_display = MATE.d_opx_items[MATE.opx_part_select]

		#WATER PARTITIONIN PARAMETERS OF CPX

		self.cpx_data = self.read_csv(os.path.join(self.core_path, 'water_part', 'cpx_part.csv'), delim = ',')

		MATE.d_cpx_items = []
		MATE.d_cpx_type = []
		self.dcpx_function = []
		self.dcpx_function_2 = []
		self.dcpx_change = []

		for i in range(1,len(self.cpx_data)):
			MATE.d_cpx_items.append("Type " + self.cpx_data[i][1] + ' - ' +self.cpx_data[i][-1])
			MATE.d_cpx_type.append(self.cpx_data[i][1])
			self.dcpx_function.append(self.cpx_data[i][2])
			self.dcpx_function_2.append(self.cpx_data[i][3])
			self.dcpx_change.append(float(self.cpx_data[i][4]))

		MATE.cpx_part_select = 0
		MATE.cpx_display = MATE.d_cpx_items[MATE.cpx_part_select]

		#WATER PARTITIONING PARAMETERS OF GT

		self.gt_data = self.read_csv(os.path.join(self.core_path, 'water_part', 'gt_part.csv'), delim = ',')

		MATE.d_gt_items = []
		MATE.d_gt_type = []
		self.d_gt_function = []
		self.d_gt_function_2 = []

		for i in range(1,len(self.gt_data)):

			MATE.d_gt_items.append("Type " + self.gt_data[i][1] + ' - ' +self.gt_data[i][-1])
			MATE.d_gt_type.append(self.gt_data[i][1])
			self.d_gt_function.append(self.gt_data[i][2])
			self.d_gt_function_2.append(self.gt_data[i][3])

		MATE.gt_part_select = 0
		MATE.gt_display = MATE.d_gt_items[MATE.gt_part_select]

		#WATER PARTITIONING PARAMETERS OF AMP

		self.amp_data = self.read_csv(os.path.join(self.core_path, 'water_part', 'amp_part.csv'), delim = ',')

		MATE.d_amp_items = []
		MATE.d_amp_type = []
		self.d_amp_function = []
		self.d_amp_function_2 = []

		for i in range(1,len(self.amp_data)):

			MATE.d_amp_items.append("Type " + self.amp_data[i][1] + ' - ' +self.amp_data[i][-1])
			MATE.d_amp_type.append(self.amp_data[i][1])
			self.d_amp_function.append(self.amp_data[i][2])
			self.d_amp_function_2.append(self.amp_data[i][3])

		MATE.amp_part_select = 0
		MATE.amp_display = MATE.d_amp_items[MATE.amp_part_select]

		#WATER PARTITIONING PARAMETERS OF PHLG

		self.pl_data = self.read_csv(os.path.join(self.core_path, 'water_part', 'pl_part.csv'), delim = ',')

		MATE.d_pl_items = []
		MATE.d_pl_type = []
		self.d_pl_function = []
		self.d_pl_function_2 = []

		for i in range(1,len(self.pl_data)):

			MATE.d_pl_items.append("Type " + self.pl_data[i][1] + ' - ' +self.pl_data[i][-1])
			MATE.d_pl_type.append(self.pl_data[i][1])
			self.d_pl_function.append(self.pl_data[i][2])
			self.d_pl_function_2.append(self.pl_data[i][3])

		MATE.pl_part_select = 0
		MATE.pl_display = MATE.d_pl_items[MATE.pl_part_select]

		#WATER PARTITIONING PARAMETERS OF OLIVINE AND MELT

		self.ol_melt_data = self.read_csv(os.path.join(self.core_path, 'water_part', 'ol_melt_part.csv'), delim = ',')

		MATE.d_melt_ol_items = []
		MATE.d_melt_ol_type = []
		self.d_melt_ol_function = []
		self.d_melt_ol_function_2 = []

		for i in range(1,len(self.ol_melt_data)):

			MATE.d_melt_ol_items.append("Type " + self.ol_melt_data[i][1] + ' - ' +self.ol_melt_data[i][-1])
			MATE.d_melt_ol_type.append(self.ol_melt_data[i][1])
			self.d_melt_ol_function.append(self.ol_melt_data[i][2])
			self.d_melt_ol_function_2.append(self.ol_melt_data[i][3])

		MATE.ol_melt_part_select = 0
		MATE.ol_melt_display = MATE.d_melt_ol_items[MATE.ol_melt_part_select]

		#WATER PARTITIONING PARAMETERS OF ORTHOPYROXENE AND MELT

		self.opx_melt_data = self.read_csv(os.path.join(self.core_path, 'water_part', 'opx_melt_part.csv'), delim = ',')

		MATE.d_melt_opx_items = []
		MATE.d_melt_opx_type = []
		self.d_melt_opx_function = []
		self.d_melt_opx_function_2 = []
		self.d_melt_opx_change = []

		for i in range(1,len(self.opx_melt_data)):

			MATE.d_melt_opx_items.append("Type " + self.opx_melt_data[i][1] + ' - ' +self.opx_melt_data[i][-1])
			MATE.d_melt_opx_type.append(self.opx_melt_data[i][1])
			self.d_melt_opx_function.append(self.opx_melt_data[i][2])
			self.d_melt_opx_function_2.append(self.opx_melt_data[i][3])
			self.d_melt_opx_change.append(self.opx_melt_data[i][4])

		MATE.opx_melt_part_select = 0
		MATE.opx_melt_display = MATE.d_melt_opx_items[MATE.opx_melt_part_select]

		#WATER PARTITIONING PARAMETERS OF CLINOPYROXENE AND MELT

		self.cpx_melt_data = self.read_csv(os.path.join(self.core_path, 'water_part', 'cpx_melt_part.csv'), delim = ',')

		MATE.d_melt_cpx_items = []
		MATE.d_melt_cpx_type = []
		self.d_melt_cpx_function = []
		self.d_melt_cpx_function_2 = []
		self.d_melt_cpx_change = []

		for i in range(1,len(self.cpx_melt_data)):

			MATE.d_melt_cpx_items.append("Type " + self.cpx_melt_data[i][1] + ' - ' +self.cpx_melt_data[i][-1])
			MATE.d_melt_cpx_type.append(self.cpx_melt_data[i][1])
			self.d_melt_cpx_function.append(self.cpx_melt_data[i][2])
			self.d_melt_cpx_function_2.append(self.cpx_melt_data[i][3])
			self.d_melt_cpx_change.append(self.cpx_melt_data[i][4])

		MATE.cpx_melt_part_select = 0
		MATE.cpx_melt_display = MATE.d_melt_cpx_items[MATE.cpx_melt_part_select]

		#WATER PARTITIONING PARAMETERS OF GARNET AND MELT

		self.gt_melt_data = self.read_csv(os.path.join(self.core_path, 'water_part', 'gt_melt_part.csv'), delim = ',')

		MATE.d_melt_gt_items = []
		MATE.d_melt_gt_type = []
		self.d_melt_gt_function = []
		self.d_melt_gt_function_2 = []

		for i in range(1,len(self.gt_melt_data)):

			MATE.d_melt_gt_items.append("Type " + self.gt_melt_data[i][1] + ' - ' +self.gt_melt_data[i][-1])
			MATE.d_melt_gt_type.append(self.gt_melt_data[i][1])
			self.d_melt_gt_function.append(self.gt_melt_data[i][2])
			self.d_melt_gt_function_2.append(self.gt_melt_data[i][3])

		MATE.gt_melt_part_select = 0
		MATE.gt_melt_display = MATE.d_melt_gt_items[MATE.gt_melt_part_select]

		#AL-opx solubility models from alopx.csv

		self.al_model_data = self.read_csv(os.path.join(self.core_path, 'al_models', 'alopx.csv'),delim = ',')

		MATE.al_opx_model_items = []
		MATE.al_opx_model_function = []
		MATE.al_opx_model_pcrit = []
		MATE.al_opx_model_display = []

		for i in range(1,len(self.al_model_data)):

			MATE.al_opx_model_items.append(self.al_model_data[i][0])
			MATE.al_opx_model_function.append(self.al_model_data[i][1])
			MATE.al_opx_model_pcrit.append(float(self.al_model_data[i][2]))
			MATE.al_opx_model_display.append(self.al_model_data[i][3])

		#Amphibole stability fileds from amp_st.csv

		self.amp_st_data = self.read_csv(os.path.join(self.core_path, 'min_stab', 'amp_st.csv'),delim = ',')

		MATE.amph_stab_list = []
		self.P_amph = []

		for i in range(1,len(self.amp_st_data)):
			MATE.amph_stab_list.append(self.amp_st_data[i][0])
			self.P_amph.append(float(self.amp_st_data[i][1]))

		#Reading ol_gb.csv where grainboundary diffusion of olivine resides.
		self.ol_gb_data = self.read_csv(os.path.join(self.core_path, 'cond_models', 'ol_gb.csv'),delim = ',')

		MATE.GB_ol_list = []
		self.D_ol_GB = []
		self.E_ol_GB = []
		self.E_err_ol_GB = []
		self.ol_calib_GB = []

		for i in range(1,len(self.ol_gb_data)):
			MATE.GB_ol_list.append(self.ol_gb_data[i][0])
			self.D_ol_GB.append(float(self.ol_gb_data[i][1]))
			self.E_ol_GB.append(float(self.ol_gb_data[i][2]))
			self.E_err_ol_GB.append(float(self.ol_gb_data[i][3]))
			self.ol_calib_GB.append(int(self.ol_gb_data[i][4]))

		#Reading gt_gb.csv where grainboundary diffusion of garnet-spinel resides.
		self.gt_gb_data = self.read_csv(os.path.join(self.core_path, 'cond_models', 'gt_gb.csv'),delim = ',')

		MATE.GB_gt_list = []
		self.D_gt_GB = []
		self.E_gt_GB = []
		self.E_err_gt_GB = []

		for i in range(1,len(self.gt_gb_data)):
			MATE.GB_gt_list.append(self.gt_gb_data[i][0])
			self.D_gt_GB.append(float(self.gt_gb_data[i][1]))
			self.E_gt_GB.append(float(self.gt_gb_data[i][2]))
			self.E_err_gt_GB.append(float(self.gt_gb_data[i][3]))

		#Reading ol_sol.csv to take solubility model information

		self.ol_sol_data = self.read_csv(os.path.join(self.core_path, 'min_sol', 'ol_sol.csv'),delim = ',')

		MATE.name_ol_sol = []
		self.ol_sol_fug_dep = []
		self.ol_sol_wcalib = []

		for i in range(1,len(self.ol_sol_data)):
			MATE.name_ol_sol.append(self.ol_sol_data[i][0])
			self.ol_sol_fug_dep.append(self.ol_sol_data[i][1])
			self.ol_sol_wcalib.append(self.ol_sol_data[i][2])
			#RETURNHERE - add the other lists once you decide

		#Reading calibration correction factors from the file.

		correction_factor_dat = self.read_csv(os.path.join(self.core_path, 'water_calib.csv'), delim = ',')

		self.pat2with = float(correction_factor_dat[0][1])
		self.bell2with = float(correction_factor_dat[1][1])
		self.pat2bell = float(correction_factor_dat[2][1])
		self.with2bell = 1.0/self.bell2with
		self.bell2path = 1.0/self.pat2bell
		self.with2pat = 1.0/self.pat2with
		self.pat2bell95 = float(correction_factor_dat[3][1])
		self.bell952pat = 1.0/self.pat2bell95

		#Reading the solidus models from the file.

		self.solidus_dry_model_data = self.read_csv(os.path.join(self.core_path, 'solidus_models', 'solidus.csv'), delim = ',')

		MATE.solidus_dry_model_names = []
		MATE.solidus_dry_model_type = []

		for i in range(1,len(self.solidus_dry_model_data)):

			MATE.solidus_dry_model_names.append(self.solidus_dry_model_data[i][0])
			MATE.solidus_dry_model_type.append(int(self.solidus_dry_model_data[i][1]))

		#Reading the solidus models from the file.

		self.solidus_wet_model_data = self.read_csv(os.path.join(self.core_path, 'solidus_models', 'wet_solidus.csv'), delim = ',')

		MATE.solidus_wet_model_names = []
		MATE.solidus_wet_model_type = []

		for i in range(1,len(self.solidus_wet_model_data)):

			MATE.solidus_wet_model_names.append(self.solidus_wet_model_data[i][0])
			MATE.solidus_wet_model_type.append(int(self.solidus_wet_model_data[i][1]))

		#Reading the solidus models from the file.

		self.solidus_carbon_model_data = self.read_csv(os.path.join(self.core_path, 'solidus_models', 'carbon_solidus.csv'), delim = ',')

		MATE.solidus_carbon_model_names = []
		MATE.solidus_carbon_model_type = []

		for i in range(1,len(self.solidus_carbon_model_data)):
			MATE.solidus_carbon_model_names.append(self.solidus_carbon_model_data[i][0])
			MATE.solidus_carbon_model_type.append(int(self.solidus_carbon_model_data[i][1]))

	def read_xen_pt(self):

		self.xen_data = self.read_csv(self.xen_pt_file_name[0],delim = ',')

		self.depth_xen = []
		self.p_xen = []
		self.T_xen = []

		try:
			for i in range(1,len(self.xen_data)):
				try:
					if MATE.z_xen_method == '0':
						self.p_xen.append(float(self.xen_data[i][1]))
					else:
						self.depth_xen.append(float(self.xen_data[i][1]))

					if MATE.z_xen_method_2 == '0':
						self.T_xen.append(float(self.xen_data[i][0])) #Already Kelvin
					else:
						self.T_xen.append(float(self.xen_data[i][0]) + 273.0) #Now Kelvin
				except ValueError:
					QMessageBox.about(self,'Warning!','There is an element in the file that can not be transformed into floating number...')
					return
		except IndexError:
			QMessageBox.about(self,'Warning!','Structure of the csv file seems to be wrong.')
			return

		QMessageBox.about(self,'Success',str(self.xen_pt_file_name[0]) + ' file was succesfully imported to the program!')
		self.xenolith_existence = True

	def geotherm_open(self):

		self.xen_pt_file_name = QFileDialog.getOpenFileName(self, 'Open File')

		if self.xen_pt_file_name[0] != '':

			self.read_xen_pt()

		else:
			pass

	def xen_properties_popup(self):

		if self.xen_pop is None:
			self.xen_pop = XEN_POP()
			self.xen_pop.setGeometry(QtCore.QRect(100, 100, 100, 100))
		self.xen_pop.show()

	def geotherm_popup(self):

		self.g_pop = G_POP()
		self.g_pop.setGeometry(QtCore.QRect(1000, 100, 100, 100))
		self.g_pop.show()

	def partition_popup(self):

		if self.p_pop is None:
			self.p_pop = PART_POP()
			self.p_pop.setGeometry(QtCore.QRect(1000, 450, 1000, 100))
		self.p_pop.show()

	def conductivity_popup(self):

		if self.cond_pop is None:
			self.cond_pop = COND_POP()
			self.cond_pop.setGeometry(QtCore.QRect(1000, 700, 100, 100))
		self.cond_pop.show()

	def comp_popup(self):

		if self.editor_pop is None:
			self.editor_pop = COMP_EDITOR()
			self.editor_pop.setGeometry(QtCore.QRect(100, 100, 1350, 650))
		self.editor_pop.show()

	def descomp_popup(self):

		if self.d_pop is None:
			self.d_pop = DES_COMP()
			self.d_pop.setGeometry(QtCore.QRect(100, 100, 100, 100))
		self.d_pop.show()

	def depth_popup(self):

		if self.depth_pop is None:
			self.depth_pop = DEPTH_FIX()
			self.depth_pop.setGeometry(QtCore.QRect(100, 500, 100, 100))
		self.depth_pop.show()

	def fo2_properties_popup(self):

		if self.fo2_pop is None:
			self.fo2_pop = FUG_POP()
			self.fo2_pop.setGeometry(QtCore.QRect(100, 100, 100, 100))
		self.fo2_pop.show()

	def load_fo2_data(self):

		if MATE.o2_buffer == 5:

			self.csv_fo2_file_name = QFileDialog.getOpenFileName(self, 'Open File')

			if self.csv_fo2_file_name[0] != '':

				self.read_csv_fo2_file()

			else:
				pass

		else:

			QMessageBox.about(self, 'Warning!', "You have to select - LOAD DATA log(FMQ) format - selection to load a file.")


	def ol_calib_popup(self):

		if self.ol_calib_pop is None:
			self.ol_calib_pop = OL_CALIB_POP()
			self.ol_calib_pop.setGeometry(QtCore.QRect(100, 100, 100, 100))
		self.ol_calib_pop.show()


	def ol_sol_calib_popup(self):

		if self.ol_sol_calib_pop is None:
			self.ol_sol_calib_pop = OL_CALIB_SOL_POP()
			self.ol_sol_calib_pop.setGeometry(QtCore.QRect(100, 100, 100, 100))
		self.ol_sol_calib_pop.show()

	def add_water_measurement(self):

		if self.add_water_pop is None:
			self.add_water_pop = ADD_WATER_POP()
			self.add_water_pop.setGeometry(QtCore.QRect(100, 100, 100, 100))
		self.add_water_pop.show()

	def select_solidus(self):

		if self.melt_solidus_pop is None:
			self.melt_solidus_pop = SELECT_SOLIDUS_POP()
			self.melt_solidus_pop.setGeometry(QtCore.QRect(200, 200, 300, 100))
		self.melt_solidus_pop.show()
		
	def select_plot_solidus(self):
		
		if self.melt_solidusPlot_pop is None:
			self.melt_solidusPlot_pop = SELECT_SOLIDUS_PLOT_POP()
			self.melt_solidusPlot_pop.setGeometry(QtCore.QRect(200, 200, 300, 100))
		self.melt_solidusPlot_pop.show()
	
	def select_melt_fraction_gradient(self):

		if self.melt_frac_pop is None:
			self.melt_frac_pop = SELECT_MELT_FRAC_POP()
			self.melt_frac_pop.setGeometry(QtCore.QRect(200, 200, 300, 100))
		self.melt_frac_pop.show()

	def px_calib_popup(self):

		if self.px_calib_pop is None:
			self.px_calib_pop = PX_CALIB_POP()
			self.px_calib_pop.setGeometry(QtCore.QRect(100, 100, 100, 100))
		self.px_calib_pop.show()

	def dry_cond_popup(self):

		if self.dry_cond_popup is None:
			self.dry_popup = DRY_POP()
			self.dry_popup.setGeometry(QtCore.QRect(100, 200, 300, 100))
		self.dry_popup.show()

	def phase_mixing_popup(self):

		if self.phs_mix_popup is None:
			self.phs_mix_popup = PHS_POP()
			self.phs_mix_popup.setGeometry(QtCore.QRect(600, 700, 100, 100))
		self.phs_mix_popup.show()

	def model_pref_open(self):

		if self.mt_input_popup is None:
			self.mt_input_popup = MT_INPUT()
			self.mt_input_popup.setGeometry(QtCore.QRect(100, 100, 100, 100))
		self.mt_input_popup.show()

	def solubility_open(self):

		if self.sol_input_popup is None:
			self.sol_input_popup = SOL_POP()
			self.sol_input_popup.setGeometry(QtCore.QRect(100, 100, 300, 100))
		self.sol_input_popup.show()

	def amp_stab_popup(self):

		if self.amp_popup is None:
			self.amp_popup = AMP_POP()
			self.amp_popup.setGeometry(QtCore.QRect(100, 100, 300, 100))
		self.amp_popup.show()

	def sp_stab_popup(self):

		if self.sp_popup is None:
			self.sp_popup = SP_POP()
			self.sp_popup.setGeometry(QtCore.QRect(100, 100, 300, 100))
		self.sp_popup.show()

	def grain_size_popup(self):

		if self.gsize_popup is None:
			self.gsize_popup = GSIZE_POP()
			self.gsize_popup.setGeometry(QtCore.QRect(100, 100, 300, 100))
		self.gsize_popup.show()

	def figure_prop_popup(self):

		if self.figprop_popup is None:
			self.figprop_popup = FIGPROP_POP()
			self.figprop_popup.setGeometry(QtCore.QRect(100, 100, 300, 100))
		self.figprop_popup.show()

	def model_curve_select_open(self):

		if MATE.mt_input_selection == 0:

			if (self.ModEM_dat_read == True) and (self.ModEM_model_read == True):

				if self.mt_curve_popup is None:
					self.mt_curve_popup = MODEM_CURVE()
					self.mt_curve_popup.setGeometry(QtCore.QRect(100, 100, 100, 100))
				self.mt_curve_popup.show()
			else:

				QMessageBox.about(self, 'Warning!', "You have to import .dat and .rho files first to use this function.")
		else:
			QMessageBox.about(self, 'Warning!', "You have to select ModEM as input from model preferences in order to use this function.")

	def info_main(self):

		QMessageBox.about(self, 'INFO GENERAL',"It is suggested that users should go through the Setup and Calculation sections from top to bottom to produce reliable analysis. "\
		"Here's a quick summary of what all these buttons and functions do:\n\n"\
		"- Composition setup: Define whether amphibole and phlogipite are "\
		"present and how Al in opx is treated.\n"
		"- Composition entry: Define compositional layers in the lithosphere by "
		"direct entry or uploading a .csv file.\n"
		"- Depth Range: Define the depth to the Moho and the maximum depth of calculation.\n"
		"- Geotherm: Define parameters such as surface heat flow and heat production "
		"used to calculate the geotherm.\n"
		"- Water partitioning: Choose which models will be used to partition hydrogen between "
		"the minerals.\n"
		"- Water solubility: Choose whether to plot maximum hydrogen storage capacities of "
		"the minerals and which model defines these capacities.\n"
		"- Conductivity models: Choose which models will be used to calculate the electrical "
		"conductivities of the minerals.\n"
		"- Phase mixing: Choose which geometric model will be used to calculate the whole rock "
		"electrical conductivity from the individual minerals.\n"
		"- Note that where the value of a parameter is visible in a box next to the "
		"name of that parameter (e.g., the Moho and LAB depths), those parameters "
		"cannot be edited directly from this box. The parameter name must be clicked "
		"on and the value can be edited from there.\n\n"\
		"Once the setup is complete, plot the results by using the 'Calculating' section.\n"
		"- After you have entered a composition, each time you press"\
		" the Plot Geotherm, Plot Water or Plot Conductivity buttons"\
		" a list of values is appended to a list, but only the"\
		" latest element of the list will be used in the calculations on the"\
		" next levels. For instance: At Level 1 (geotherm level),"\
		" let's say we have two sets of T values appended to it."\
		" At the next levels,"\
		" water and conductivity calculations will calculate the values"\
		" based on last element on the geotherm level. To clear these lists"\
		" individually, user has to press associated reset buttons."\
		" Whether a list contains elements or not is indicated with"\
		" change to a darker color on plot buttons.")

	def info_fugacity(self):

		QMessageBox.about(self, "INFO","This section provides the user to select"\
		"a desired oxygen fugacity model for the mantle.\n\n"\
		"Some of the commonly used buffers are selected."\
		"The user can also enter a data with the following csv format (comma separated):\n\n"\
		"Depth(km),log(fo2) (difference from the FMQ buffer)\n\n"\
		"The first line has to be a header. Similar data on Woodland and Koch (2003,EPSL)")

	def ModEM_model_open(self):

		self.ModEM_model_file_name = QFileDialog.getOpenFileName(self, 'Open File')

		if self.ModEM_model_file_name[0] != '':

			self.read_ModEM_rho()

		else:
			pass

	def ModEM_data_open(self):

		self.ModEM_data_file_name = QFileDialog.getOpenFileName(self, 'Open File')

		if self.ModEM_data_file_name[0] != '':

			self.read_ModEM_dat()
		else:
			pass

	def csvMt_open(self):

		self.csv_MT_file_name = QFileDialog.getOpenFileName(self, 'Open File')

		if self.csv_MT_file_name[0] != '':

			self.read_csv_MT_file()

		else:
			pass

	def InfoBoxMT(self):

		QMessageBox.about(self, "INFO","This section provides the user to select"\
		"csv file profile format is as follows:\n\n"\
		"Depth(km),Resistivity,ResistivityMIN,ResistivityMAX\n\n"\
		"Uploading more files result in more profiles. However, calculations are made on the last uploaded one.")

	def adjust_composition(self):

		#Interpolating the data for to be appear continous from crust to lab
		#with increments of MATE.dz in meters.100 m is also suggested for
		#calculating thermal conductivity properly in Hasterok and Chapman (2010)

		self.h2o_fugacity_calculated = False

		comp_text_data = str(MATE.text).splitlines()
		self.layer_data = []

		self.depth_comp = []
		self.h2o_comp = []
		self.co2_comp = []
		self.ol_frac_comp = []
		self.opx_frac_comp = []
		self.cpx_frac_comp = []
		self.gt_frac_comp = []
		self.sp_chr_frac_comp = []
		self.pl_frac_comp = []
		self.amp_frac_comp = []
		self.cond_frac_comp = []
		self.cond_cond_comp = []
		self.melt_frac_comp = []
		self.fe_ol_comp = []
		self.fe_opx_comp = []
		self.fe_cpx_comp = []
		self.fe_gt_comp = []
		self.al_opx_comp = []
		self.ti_ol_comp = []
		self.na2o_melt_comp = []
		self.k2o_melt_comp = []
		self.ol_m_comp = []
		self.opx_m_comp = []
		self.cpx_m_comp = []
		self.gt_m_comp = []
		self.sp_chr_m_comp = []
		self.pl_m_comp = []
		self.amp_m_comp = []
		self.cond_m_comp = []
		self.cond_t_k_comp = []
		self.melt_m_comp = []
		self.flu_comp = []
		self.ol_gs_comp = []
		self.heat_prod_mantle = []

		for i in range(1,len(comp_text_data)):

			self.layer_data.append(comp_text_data[i].split(','))

		self.continue_adjusting = 1

		for i in range(0,len(self.layer_data)):
			for j in range(0,len(self.layer_data[i])):
				try:
					float(self.layer_data[i][j])
					if float(self.layer_data[i][j]) < 0.0:
						self.continue_adjusting = 0
						QMessageBox.about(self,"Warning!","There is an entered value for a parameters that is smaller than zero, which can not be the case. Correct this value to continue.")
						break
					if float(self.layer_data[0][0])*1000.0 != MATE.moho:
						self.continue_adjusting = 0
						QMessageBox.about(self,"Warning!","Entered Moho depth from the -Depth Range- section is not same as the depth of the first layer. Please fix this to continue.")
						break
					if i !=0:
						if float(self.layer_data[i][0]) <= float(self.layer_data[i-1][0]):
							self.continue_adjusting = 0
							QMessageBox.about(self,"Warning!","Layers depths are not in right order. The value decreased on the next layer or the same within some layer.")
							break
				except ValueError:
					QMessageBox.about(self,"Warning!","There are some elements in the composition file that can not be converted to floating numbers.\n" +\
					"Please enter all the parameters as numbers that can be converted to floating numbers.")
					self.continue_adjusting = 0

			if self.continue_adjusting == 0:

				break

		if self.continue_adjusting == 1:

			for i in range(0,len(self.layer_data)):

				if i < len(self.layer_data)-1:

					self.depth_comp.append(float(self.layer_data[i][0]) * 1000.0)
					self.depth_comp.append((float(self.layer_data[i+1][0]) * 1000.0) - MATE.dz)

				else:
					self.depth_comp.append(float(self.layer_data[i][0]) * 1000.0)
					self.depth_comp.append(MATE.lab)

				for j in range(0,2):

					self.h2o_comp.append(float(self.layer_data[i][1]))
					self.co2_comp.append(float(self.layer_data[i][2]))
					self.ol_frac_comp.append(float(self.layer_data[i][3]) / 100.0) #converting to perc to fraction
					self.opx_frac_comp.append(float(self.layer_data[i][4]) / 100.0)
					self.cpx_frac_comp.append(float(self.layer_data[i][5]) / 100.0)
					self.gt_frac_comp.append(float(self.layer_data[i][6]) / 100.0)
					self.sp_chr_frac_comp.append(float(self.layer_data[i][7]) / 100.0)
					self.pl_frac_comp.append(float(self.layer_data[i][8]) / 100.0)
					self.amp_frac_comp.append(float(self.layer_data[i][9]) / 100.0)
					self.cond_frac_comp.append(float(self.layer_data[i][10]) / 100.0)
					self.cond_cond_comp.append(1.0 / float(self.layer_data[i][11])) #converting to conductivity
					self.melt_frac_comp.append(float(self.layer_data[i][12]) / 100.0)
					self.fe_ol_comp.append(float(self.layer_data[i][13]))
					self.fe_opx_comp.append(float(self.layer_data[i][14]))
					self.fe_cpx_comp.append(float(self.layer_data[i][15]))
					self.fe_gt_comp.append(float(self.layer_data[i][16]))
					self.ol_m_comp.append(float(self.layer_data[i][17]))
					self.opx_m_comp.append(float(self.layer_data[i][18]))
					self.cpx_m_comp.append(float(self.layer_data[i][19]))
					self.gt_m_comp.append(float(self.layer_data[i][20]))
					self.sp_chr_m_comp.append(float(self.layer_data[i][21]))
					self.pl_m_comp.append(float(self.layer_data[i][22]))
					self.amp_m_comp.append(float(self.layer_data[i][23]))
					self.cond_m_comp.append(float(self.layer_data[i][24]))
					self.melt_m_comp.append(float(self.layer_data[i][25]))
					self.al_opx_comp.append(float(self.layer_data[i][26]))
					self.ti_ol_comp.append(float(self.layer_data[i][27]))
					self.na2o_melt_comp.append(float(self.layer_data[i][28]))
					self.k2o_melt_comp.append(float(self.layer_data[i][29]))
					self.cond_t_k_comp.append(float(self.layer_data[i][30]))
					self.flu_comp.append(float(self.layer_data[i][31]))
					self.ol_gs_comp.append(float(self.layer_data[i][32])*1e-3) #converting to mm to m
					self.heat_prod_mantle.append(float(self.layer_data[i][33]))

			self.depth_comp_plot = self.depth_comp[::2]

			if len(self.depth_comp) % 2 == 0:
				self.depth_comp_plot.append(self.depth_comp[-1])

			f_ol = interp1d(self.depth_comp,self.ol_frac_comp)
			f_opx = interp1d(self.depth_comp,self.opx_frac_comp)
			f_cpx = interp1d(self.depth_comp,self.cpx_frac_comp)
			f_gt = interp1d(self.depth_comp,self.gt_frac_comp)
			f_sp_chr = interp1d(self.depth_comp,self.sp_chr_frac_comp)
			f_pl = interp1d(self.depth_comp,self.pl_frac_comp)
			f_amp = interp1d(self.depth_comp,self.amp_frac_comp)
			f_cond = interp1d(self.depth_comp,self.cond_frac_comp)
			f_cond_cond = interp1d(self.depth_comp,self.cond_cond_comp)
			f_melt = interp1d(self.depth_comp,self.melt_frac_comp)
			f_fe_ol = interp1d(self.depth_comp,self.fe_ol_comp)
			f_fe_opx = interp1d(self.depth_comp,self.fe_opx_comp)
			f_fe_cpx = interp1d(self.depth_comp,self.fe_cpx_comp)
			f_fe_gt = interp1d(self.depth_comp,self.fe_gt_comp)
			if MATE.al_method == '0':
				f_al_opx = interp1d(self.depth_comp,self.al_opx_comp)
			f_ti_ol = interp1d(self.depth_comp,self.ti_ol_comp)
			f_na2o_melt = interp1d(self.depth_comp,self.na2o_melt_comp)
			f_k2o_melt = interp1d(self.depth_comp,self.k2o_melt_comp)
			f_ol_m = interp1d(self.depth_comp,self.ol_m_comp)
			f_opx_m = interp1d(self.depth_comp,self.opx_m_comp)
			f_cpx_m = interp1d(self.depth_comp,self.cpx_m_comp)
			f_gt_m = interp1d(self.depth_comp,self.gt_m_comp)
			f_sp_chr_m = interp1d(self.depth_comp,self.sp_chr_m_comp)
			f_pl_m = interp1d(self.depth_comp,self.pl_m_comp)
			f_amp_m = interp1d(self.depth_comp,self.amp_m_comp)
			f_cond_m = interp1d(self.depth_comp,self.cond_m_comp)
			f_melt_m = interp1d(self.depth_comp,self.melt_m_comp)
			f_h2o = interp1d(self.depth_comp,self.h2o_comp)
			f_co2 = interp1d(self.depth_comp,self.co2_comp)
			f_cond_t_k = interp1d(self.depth_comp,self.cond_t_k_comp)
			f_flu = interp1d(self.depth_comp,self.flu_comp)
			f_ol_gs = interp1d(self.depth_comp,self.ol_gs_comp)
			f_heat_prod_mantle = interp1d(self.depth_comp,self.heat_prod_mantle)

			self.composition_readfile = True
			self.depth_mantle = []
			kilometer_mode = (MATE.lab - MATE.moho) % MATE.dz
			self.depth_mantle.append(MATE.moho)
			if kilometer_mode != 0:
				self.depth_mantle.append(kilometer_mode)
			for i in range(0, int((MATE.lab - MATE.moho) / MATE.dz)):
				self.depth_mantle.append(MATE.dz)
			self.depth_mantle = np.array(self.depth_mantle)
			self.depth_mantle = np.cumsum(self.depth_mantle)

			self.ol_frac = f_ol(self.depth_mantle)
			self.opx_frac = f_opx(self.depth_mantle)
			self.cpx_frac = f_cpx(self.depth_mantle)
			self.gt_frac = f_gt(self.depth_mantle)
			self.sp_chr_frac = f_sp_chr(self.depth_mantle)
			self.pl_frac = f_pl(self.depth_mantle)
			self.amp_frac = f_amp(self.depth_mantle)
			self.cond_frac = f_cond(self.depth_mantle)
			self.cond_cond = f_cond_cond(self.depth_mantle)
			self.melt_mass_frac = f_melt(self.depth_mantle)
			self.fe_ol = f_fe_ol(self.depth_mantle)
			self.fe_opx = f_fe_opx(self.depth_mantle)
			self.fe_cpx = f_fe_cpx(self.depth_mantle)
			self.fe_gt = f_fe_gt(self.depth_mantle)

			if MATE.al_method == '0':
				self.al_opx = f_al_opx(self.depth_mantle)
			else:
				self.al_opx = None

			self.ti_ol = f_ti_ol(self.depth_mantle)
			self.na2o_melt = f_na2o_melt(self.depth_mantle)
			self.k2o_melt = f_k2o_melt(self.depth_mantle)

			self.ol_m = f_ol_m(self.depth_mantle)
			self.opx_m = f_opx_m(self.depth_mantle)
			self.cpx_m = f_cpx_m(self.depth_mantle)
			self.gt_m = f_gt_m(self.depth_mantle)
			self.sp_chr_m = f_sp_chr_m(self.depth_mantle)
			self.pl_m = f_pl_m(self.depth_mantle)
			self.amp_m = f_amp_m(self.depth_mantle)
			self.cond_m = f_cond_m(self.depth_mantle)
			self.melt_m = f_melt_m(self.depth_mantle)

			self.h2o = f_h2o(self.depth_mantle)
			self.co2 = f_co2(self.depth_mantle)
			self.cond_t_k = f_cond_t_k(self.depth_mantle)
			self.flu = f_flu(self.depth_mantle)
			self.ol_gs = f_ol_gs(self.depth_mantle)
			self.heat_prod_mantle = f_heat_prod_mantle(self.depth_mantle)
			self.d_z = []

			for i in range(0,int(MATE.moho/1e3)):
				self.ol_frac = np.insert(self.ol_frac,0,-999)
				self.opx_frac = np.insert(self.opx_frac,0,-999)
				self.cpx_frac = np.insert(self.cpx_frac,0,-999)
				self.gt_frac = np.insert(self.gt_frac,0,-999)
				self.sp_chr_frac = np.insert(self.sp_chr_frac,0,-999)
				self.pl_frac = np.insert(self.pl_frac,0,-999)
				self.amp_frac = np.insert(self.amp_frac,0,-999)
				self.cond_frac = np.insert(self.cond_frac,0,-999)
				self.cond_cond = np.insert(self.cond_cond,0,-999)
				self.melt_mass_frac = np.insert(self.melt_mass_frac,0,-999)
				self.h2o = np.insert(self.h2o,0,-999)
				self.co2 = np.insert(self.co2,0,-999)
				self.cond_t_k = np.insert(self.cond_t_k,0,-999)
				self.flu = np.insert(self.flu,0,-999)
				self.ol_gs = np.insert(self.ol_gs,0,-999)
				self.heat_prod_mantle = np.insert(self.heat_prod_mantle,0,-999)
				self.fe_ol = np.insert(self.fe_ol,0,-999)
				self.fe_opx = np.insert(self.fe_opx,0,-999)
				self.fe_cpx = np.insert(self.fe_cpx,0,-999)
				self.fe_gt = np.insert(self.fe_gt,0,-999)

				if MATE.al_method == '0':
					self.al_opx = np.insert(self.al_opx,0,-999)

				self.ti_ol = np.insert(self.ti_ol,0,-999)
				self.na2o_melt = np.insert(self.na2o_melt,0,-999)
				self.k2o_melt = np.insert(self.k2o_melt,0,-999)

				self.ol_m = np.insert(self.ol_m,0,-999)
				self.opx_m = np.insert(self.opx_m,0,-999)
				self.cpx_m = np.insert(self.cpx_m,0,-999)
				self.gt_m = np.insert(self.gt_m,0,-999)
				self.sp_chr_m = np.insert(self.sp_chr_m,0,-999)
				self.pl_m = np.insert(self.pl_m,0,-999)
				self.amp_m = np.insert(self.amp_m,0,-999)
				self.cond_m = np.insert(self.cond_m,0,-999)
				self.melt_m = np.insert(self.melt_m,0,-999)

			self.d_z.append([1e3] * int((MATE.moho) / 1e3))
			if kilometer_mode != 0:
				self.d_z.append([kilometer_mode])
			self.d_z.append([MATE.dz] * int((MATE.lab - MATE.moho + kilometer_mode) / MATE.dz))
			self.d_z = np.asarray(list(itertools.chain(*self.d_z)))
			self.depth = np.cumsum(np.asarray(self.d_z))
			self.depth = np.insert(self.depth,0,0.0)

			self.idx_moho, = np.where(self.depth == MATE.moho)
			self.idx_moho = int(self.idx_moho)

			#Deciding on phlogopite, amphibole and melt methods
			#depending on the entered composition...
			if np.mean(self.pl_frac[self.idx_moho:]) > 0.0:
				MATE.pl_method = '0'
			else:
				MATE.pl_method = '1'

			if np.mean(self.amp_frac[self.idx_moho:]) > 0.0:
				MATE.amp_method = '0'
			else:
				MATE.amp_method = '1'

			if np.mean(self.melt_mass_frac[self.idx_moho:]) > 0.0:
				MATE.melt_method = '0'
			else:
				MATE.melt_method = '1'


			if MATE.melt_method == '0':

				self.idx_melt_zero = []
				for i in range(self.idx_moho, len(self.melt_mass_frac)):
					if self.melt_mass_frac[i] == 0.0:
						self.idx_melt_zero.append(i)

			self.data_existence = True

	def calculate_pressure(self):

		#Calculating pressure by simply using crustal and mantle density set values.
		#For crust 2.85 g/cm^3, for mantle 3.34 g/cm^3. P = z x rho x g
		#These density values selected to accompany the empirical relations of
		#Hasterok (2010)

		if self.data_existence == True:

			#Calculating the Fe-Mg endmember density dependent on entered
			#Mg number.
			ol_function = np.polyfit([1.0,0],[self.rho_forst,self.rho_fayal], deg = 1)
			opx_function = np.polyfit([1.0,0.0],[self.rho_enst,self.rho_ferrosil], deg = 1)
			cpx_function = np.polyfit([1.0,0.0],[self.rho_diop,self.rho_heden], deg = 1)
			gt_function = np.polyfit([1.0,0.0],[self.rho_pyrop,self.rho_alm], deg = 1)

			self.rho_ol = ((ol_function[0] * (1.0 - self.fe_ol)) + ol_function[1])
			self.rho_opx = ((opx_function[0] * (1.0 - self.fe_opx)) + opx_function[1])
			self.rho_cpx = ((cpx_function[0] * (1.0 - self.fe_cpx)) + cpx_function[1])
			self.rho_gt = ((gt_function[0] * (1.0 - self.fe_gt)) + gt_function[1])

			self.p = np.zeros(len(self.depth)) #Setting up rho array
			self.density_mantle = np.zeros(len(self.depth))

			for i in range(1,len(self.depth)):
				if self.depth[i] <= self.moho:
					self.p[i] = self.d_z[i-1] * self.rho_crust * self.g
					self.density_mantle[i] = self.rho_crust
				else:
					if MATE.thermal_cond_method == '0':
						self.p[i] = self.d_z[i-1] * self.rho_mantle * self.g
						self.density_mantle[i] = self.rho_mantle
					else:
						self.density_mantle[i] = ((self.ol_frac[i] * self.rho_ol[i]) + (self.gt_frac[i] * self.rho_gt[i]) +\
						 (self.sp_chr_frac[i] * self.rho_sp_chr) +\
						 (self.opx_frac[i] * self.rho_opx[i]) + (self.cpx_frac[i] * self.rho_cpx[i]) +\
						 (self.pl_frac[i] * self.rho_phlg) + (self.amp_frac[i] * self.rho_amph)+\
						 (self.cond_frac[i] * 2200.0))

						self.p[i] = self.d_z[i-1] * self.g * self.density_mantle[i]


			self.p = np.cumsum(self.p) / 1e12 #Converting to GPA

			self.dT_dF = eval(MATE.melt_fraction_functions[MATE.melt_fraction_function_selection]) #melt_fraction estimation gradient from Hirschmann 2009
			
	def calculate_geotherm(self):

		#Creating the depth array for calculating the 1-d steady state geotherm
		#by using different intervals for 1.Upper crust where heat generation
		#is high 2. Lower crust where it is intermediate and 3. Lithosperic mantle
		#where it is negligible but does not hurt to calculate.
		#Local function for calculating thermal conductivity, from Hasterok (2010), PhD
		#Thesis.

		self.h2o_fugacity_calculated = False

		def calculate_k_st(k0,k1,k2,k3,T,P):

			k = (k0 + (k1 / T) + (k2 * T**2.0)) * (1 + (k3 * P))

			return k

		#Local function for calculating geometric mixing of different thermal conductivities
		#taken from Clauser & Huenges (1995).

		def geometric_mixing(fractions,conductivities):

			mixture = np.ones(len(conductivities))
			mixture[0] = (conductivities[0]**fractions[0])
			for i in range(1,len(conductivities)):
				mixture[i] = (conductivities[i]**fractions[i]) * mixture[i-1]

			return mixture[-1]

		#Local function for calculating lattice contribution of thermal conductivity
		#taken from Hasterok & Chapman (2011).

		def calculate_k_lat(k_0,k_1,k_2,n_thermal,frac,K_T,K_T_der,T,P):

			k_init = k_0 + (k_1 * frac) + (k_2 * frac**2.0)

			k_lat = 1000.0 * k_init * ((298.0 / T)**n_thermal) * (1.0 + ((K_T_der * P) / K_T))

			return k_lat

		#Local function for calculating radiative contribution of thermal conductivity
		#taken from Hasterok & Chapman (2011).

		def calculate_k_rad(lambda_r_max,omega,T,T_ref):

			k_rad = 500.0 * lambda_r_max * (1 + math.erf((T - T_ref) / omega))

			return k_rad

		#Setting up parameters as numpy arrays at length of self.d_z (layers)
		self.T = np.zeros(len(self.depth)) #Temperature in Kelvin
		self.q = np.zeros(len(self.depth)) #Heat flow
		self.A_list = np.zeros(len(self.depth)) #Heat generation
		self.k = np.zeros(len(self.depth)) #Thermal conductivity
		#Setting up the first layers
		self.T[0] = MATE.T_0 #Temperature at surface
		self.q[0] = MATE.q_0 #Heat flow at surface
		self.k[0] = (self.k0_upper_1 + (self.k1_upper_1 / self.T[0]) + (self.k2_upper_1 * self.T[0]**2.0)) #Thermal
		#conductivity at surface, calculated via Hasterok (2010, PhD thesis).

		#Logical parameter that will be changed when sp-garnet transition
		#going to be intercepted.
		transition_sp_search = True

		if MATE.thermal_cond_method == '3':
			MATE.hr = 16 * 1e3
			MATE.A_upper_crust = (MATE.q_0*0.26) / 16000.0

		#Setting up for loop that will iterate for number of layers.
		for i in range(0,len(self.depth)):
			#If conditionals setting the heat production parameters based on given input.


			if self.depth[i] <= MATE.hr:
				self.A_list[i] = MATE.A_upper_crust
			elif (self.depth[i] > MATE.hr) and (self.depth[i] <= MATE.moho):
				self.A_list[i] = MATE.A_lower_crust
			elif (self.depth[i] > MATE.moho) and (self.depth[i] <= MATE.lab):
				self.A_list[i] = self.heat_prod_mantle[i]

			if i != 0:

				#Solving the temperature with formula (?)
				self.T[i] = self.T[i-1] + ((self.q[i-1] * self.d_z[i-1]) / self.k[i-1]) - ((self.A_list[i-1] * self.d_z[i-1]**2.0) / (2.0 * self.k[i-1]))
				T_avg = (self.T[i-1] + self.T[i]) / 2.0 #Averaging T

				if self.spinel_stab_select == 1:
					self.p_spinel = 1.4209 + np.exp((3.9073 * 1e-3 * self.T) - 6.8041)  #Spinel-Garnet transition line calculated with self.T
					#Taken from Hasterok & Chapman (2011)
					self.p_spinel = self.p_spinel[np.nonzero(self.T)] #Getting rid of zeros
				elif self.spinel_stab_select == 2:
					self.p_spinel = np.ones(len(self.T)) * MATE.P_sp_manual
					self.p_spinel = self.p_spinel[np.nonzero(self.T)]

				#Calculating T-dependent thermal conductivity
				#If conditionals for different empirical parameters for critical temperature (Hasterok, 2010)
				if MATE.thermal_cond_method == '0':
					if self.T[i] <= self.t_criterion:
						if self.depth[i] <= self.hr:
							self.k[i] = calculate_k_st(self.k0_upper_1,self.k1_upper_1,self.k2_upper_1,self.k3_upper_1,T_avg,self.p[i])
						elif (self.depth[i] > self.hr) and (self.depth[i] <= self.moho):
							self.k[i] = calculate_k_st(self.k0_low_1,self.k1_low_1,self.k2_low_1,self.k3_low_1,T_avg,self.p[i])
						else:
							#In the mantle searching for sp-gt transition
							if transition_sp_search == True:
								idx_sp = self.interception(self.p_spinel,self.p[:len(self.p_spinel)])
								if len(idx_sp) > 0:
									#If producted geotherm intercepts P-T line of sp-gt transition
									#change logical parameter to False for changing to gt.
									transition_sp_search = False
									self.depth_spinel = self.depth[i] #Depth of transition
									self.p_spinel_trans = self.p[i]
									self.index_spinel = i
								self.k[i] = calculate_k_st(self.k0_mantle_sp,self.k1_mantle_sp,self.k2_mantle_sp,self.k3_mantle_sp,T_avg,self.p[i])
							else:
								self.k[i] = calculate_k_st(self.k0_mantle_gt,self.k1_mantle_gt,self.k2_mantle_gt,self.k3_mantle_gt,T_avg,self.p[i])
					else:
						#Same if tree for temperatures bigger than critical temperature : (self.t_criterion)
						if self.depth[i] <= self.hr:
							self.k[i] = calculate_k_st(self.k0_upper_2,self.k1_upper_2,self.k2_upper_2,self.k3_upper_2,T_avg,self.p[i])
						elif (self.depth[i] > self.hr) and (self.depth[i] <= self.moho):
							self.k[i] = calculate_k_st(self.k0_low_2,self.k1_low_2,self.k2_low_2,self.k3_low_2,T_avg,self.p[i])
						else:
							if transition_sp_search == True:
								idx_sp = self.interception(self.p_spinel,self.p[:len(self.p_spinel)])
								if len(idx_sp) > 0:
									transition_sp_search = False
									self.depth_spinel = self.depth[i]
									self.p_spinel_trans = self.p[i]
								self.k[i] = calculate_k_st(self.k0_mantle_sp,self.k1_mantle_sp,self.k2_mantle_sp,self.k3_mantle_sp,T_avg,self.p[i])
							else:
								self.k[i] = calculate_k_st(self.k0_mantle_gt,self.k1_mantle_gt,self.k2_mantle_gt,self.k3_mantle_gt,T_avg,self.p[i])

				elif MATE.thermal_cond_method == '1' or MATE.thermal_cond_method == '3':

					if self.T[i] <= self.t_criterion:
						#Crust is the same composition as before from the studies method denoted with '0'
						k0_up = self.k0_upper_1
						k1_up = self.k1_upper_1
						k2_up = self.k2_upper_1
						k3_up = self.k3_upper_1
						k0_low = self.k0_low_1
						k1_low = self.k1_low_1
						k2_low = self.k2_low_1
						k3_low = self.k3_low_1
					else:
						k0_up = self.k0_upper_2
						k1_up = self.k1_upper_2
						k2_up = self.k2_upper_2
						k3_up = self.k3_upper_2
						k0_low = self.k0_low_2
						k1_low = self.k1_low_2
						k2_low = self.k2_low_2
						k3_low = self.k3_low_2

					if self.depth[i] <= self.hr:

						self.k[i] = calculate_k_st(k0_up,k1_up,k2_up,k3_up,T_avg,self.p[i])

					elif (self.depth[i] > self.hr) and (self.depth[i] <= self.moho):

						self.k[i] = calculate_k_st(k0_low,k1_low,k2_low,k3_low,T_avg,self.p[i])

					else:

						#In the mantle searching for sp-gt transition
						if transition_sp_search == True:
							idx_sp = self.interception(self.p_spinel,self.p[:len(self.p_spinel)])
							idx_gt = 8 #information index of spinel from csv file

							if len(idx_sp) > 0:
								#If producted geotherm intercepts P-T line of sp-gt transition
								#change logical parameter to False for changing to gt.
								transition_sp_search = False
								self.depth_spinel = self.depth[i] #Depth of transition
								self.p_spinel_trans = self.p[i] #pressure value of sp-gt transition
								self.index_spinel = i #Index of the sp-gt transition
						else:
							idx_gt = 9 #information index of garnet from csv file

						k_lat_ol = calculate_k_lat(self.k_0[7],self.k_1[7],self.k_2[7],self.n_thermal[7],1.0-self.fe_ol[i],self.K_T[7],self.K_T2[7],T_avg,self.p[i])
						k_lat_opx = calculate_k_lat(self.k_0[6],self.k_1[6],self.k_2[6],self.n_thermal[6],1.0-self.fe_opx[i],self.K_T[6],self.K_T2[6],T_avg,self.p[i])
						k_lat_cpx = calculate_k_lat(self.k_0[5],self.k_1[5],self.k_2[5],self.n_thermal[5],1.0-self.fe_cpx[i],self.K_T[5],self.K_T2[5],T_avg,self.p[i])
						k_lat_gt = calculate_k_lat(self.k_0[idx_gt],self.k_1[idx_gt],self.k_2[idx_gt],self.n_thermal[idx_gt],1.0-self.fe_gt[i],self.K_T[idx_gt],self.K_T2[idx_gt],T_avg,self.p[i])
						if MATE.pl_method == '0':
							k_lat_pl = calculate_k_lat(self.k_0[10],self.k_1[10],self.k_2[10],self.n_thermal[10],0.0,self.K_T[10],self.K_T2[10],T_avg,self.p[i])
						if MATE.amp_method == '0':
							k_lat_amp = calculate_k_lat(self.k_0[11],self.k_1[11],self.k_2[11],self.n_thermal[11],0.0,self.K_T[11],self.K_T2[11],T_avg,self.p[i])
						k_rad_ol = calculate_k_rad(self.lambda_r_max[7],self.omega_thermal[7],T_avg,self.T_ref[7])
						k_rad_opx = calculate_k_rad(self.lambda_r_max[6],self.omega_thermal[6],T_avg,self.T_ref[6])
						k_rad_cpx = calculate_k_rad(self.lambda_r_max[5],self.omega_thermal[5],T_avg,self.T_ref[5])
						k_ol = k_lat_ol + k_rad_ol
						k_opx = k_lat_opx + k_rad_opx
						k_cpx = k_lat_cpx + k_rad_cpx
						k_gt = k_lat_gt

						if MATE.pl_method == '0':
							k_pl = k_lat_pl
						else:
							k_pl = 0.0
						if MATE.amp_method == '0':
							k_amp = k_lat_amp
						else:
							k_amp = 0.0
						k_sp_chr = 2190.0 #Room temperature chromite estimation from Clauser and Huenges 1995
						self.k[i] = geometric_mixing([self.ol_frac[i],self.opx_frac[i],self.cpx_frac[i],self.gt_frac[i],self.sp_chr_frac[i],self.pl_frac[i],self.amp_frac[i],self.cond_frac[i]],
						[k_ol,k_opx,k_cpx,k_gt,k_sp_chr,k_pl,k_amp,self.cond_t_k[i]])

				self.q[i] = self.q[i-1] - (self.A_list[i-1] * self.d_z[i-1])
				if self.depth[i] == self.moho:
					self.crust_production = MATE.q_0 - self.q[i]
					self.moho_heat_flow = self.q[i]

		if MATE.adiabat_selection != 0:

			T_K_Adiabat, self.depth_adiabat_used, self.T_adiabat_used = eval(MATE.adiabat_options[MATE.adiabat_selection] + '(P_input = self.p)')

			self.idx_T_adiabat = np.argwhere(np.diff(np.sign(self.T - T_K_Adiabat)) != 0)

			try:
				self.T[self.idx_T_adiabat[0][0]:] = T_K_Adiabat[self.idx_T_adiabat[0][0]:]
			except IndexError:
				pass

		#After P and T calculation re-calculate al-model and plot it.
		if MATE.al_method == '0':
			if MATE.al_opx_model_select != 0:
				self.recalculate_al()

		#Calculating Dry Solidus
		self.calculate_dry_solidus()

	def load_input_geotherm(self):

		#Interpolating the T for each depth in the mantle...

		f_T_geotherm = interp1d(np.array(MATE.depth_geotherm)*1e3,np.array(MATE.T_geotherm))
		try:
			self.T = f_T_geotherm(self.depth)
			continue_T = True
		except ValueError:
			QMessageBox.about(self, "WARNING!","There is a value in the input geotherm file outside the limits of Depth Range")
			continue_T = False

		if continue_T == True:

			if self.spinel_stab_select == 1:
				self.p_spinel = 1.4209 + np.exp((3.9073 * 1e-3 * self.T) - 6.8041)  #Spinel-Garnet transition line calculated with self.T
				#Taken from Hasterok & Chapman (2011)
				self.p_spinel = self.p_spinel[np.nonzero(self.T)] #Getting rid of zeros
			elif self.spinel_stab_select == 2:
				self.p_spinel = np.ones(len(self.T)) * MATE.P_sp_manual
				self.p_spinel = self.p_spinel[np.nonzero(self.T)]

			idx_sp = self.interception(self.p_spinel,self.p[:len(self.p_spinel)])
			idx_sp = int(idx_sp[0][0])
			if idx_sp != None:
				#If producted geotherm intercepts P-T line of sp-gt transition
				#change logical parameter to False for changing to gt.
				transition_sp_search = False
				self.depth_spinel = self.depth[idx_sp] #Depth of transition
				self.p_spinel_trans = self.p[idx_sp]
				self.index_spinel = idx_sp

			if MATE.al_method == '0':
				if MATE.al_opx_model_select != 0:
					self.recalculate_al()

		self.calculate_dry_solidus()

	def recalculate_al(self):

		#Function that plots the calculates and plots the al in opx variation

		if MATE.al_opx_model_pcrit[MATE.al_opx_model_select] > 0:
			idx_al, = np.where(self.p == self.find_nearest(self.p,self.p_spinel_trans))
			idx_al = int(idx_al)
		self.al_opx[idx_al:] = eval(MATE.al_opx_model_function[MATE.al_opx_model_select])
		self.plot_al(method = 'draw') #Re-draw after determination of P-T

	def calculate_water(self, method, idx = None):

		#Bulk water content is self.h2o, this definition will distribute the water contents with given partitioning rules.
		if method == 'array':
			self.ol_h2o = np.zeros(len(self.h2o))
			self.opx_h2o = np.zeros(len(self.h2o))
			self.cpx_h2o = np.zeros(len(self.h2o))
			self.gt_h2o = np.zeros(len(self.h2o))
			self.px_h2o = np.zeros(len(self.h2o))
			self.amp_h2o = np.zeros(len(self.h2o))
			self.pl_h2o = np.zeros(len(self.h2o))
			self.melt_h2o = np.zeros(len(self.h2o))
			self.h2o_solid = np.zeros(len(self.h2o))

		if method == 'array':

			idx_node = None

		elif method == 'index':

			idx_node = idx

		if MATE.melt_method == '0':

			if MATE.melt_partitions_calculated == False:

				#Converting fractions to water holding species that has an exchange with coexisting melt.
				self.ol_frac_wt = self.ol_frac / (self.ol_frac + self.opx_frac + self.cpx_frac + self.gt_frac)
				self.opx_frac_wt = self.opx_frac / (self.ol_frac + self.opx_frac + self.cpx_frac + self.gt_frac)
				self.cpx_frac_wt = self.cpx_frac / (self.ol_frac + self.opx_frac + self.cpx_frac + self.gt_frac)
				self.gt_frac_wt = self.gt_frac / (self.ol_frac + self.opx_frac + self.cpx_frac + self.gt_frac)

				if (MATE.d_melt_opx_type[MATE.opx_melt_part_select] == '1') or (MATE.d_melt_opx_type[MATE.opx_melt_part_select] == '3'):

					MATE.d_melt_opx = eval(self.d_melt_opx_function[MATE.opx_melt_part_select])

				elif (MATE.d_melt_opx_type[MATE.opx_melt_part_select] == '2'):

					MATE.d_melt_opx = np.zeros(len(self.p))

					for i in range(0,len(self.p)):
						if self.p[i] < self.d_melt_opx_change[MATE.opx_melt_part_select]:
							MATE.d_melt_opx[i] = eval(self.d_melt_opx_function[MATE.opx_melt_part_select])
						else:
							MATE.d_melt_opx[i] = eval(self.d_melt_opx_function[MATE.opx_melt_part_select])

				elif (MATE.d_melt_opx_type[MATE.opx_melt_part_select] == '4'):

					MATE.d_melt_opx = np.ones(len(self.p)) * float(self.d_melt_opx_function[MATE.opx_melt_part_select])


				if (MATE.d_melt_cpx_type[MATE.cpx_melt_part_select] == '1') or (MATE.d_melt_cpx_type[MATE.cpx_melt_part_select] == '3'):

					MATE.d_melt_cpx = eval(self.d_melt_cpx_function[MATE.cpx_melt_part_select])

				elif (MATE.d_melt_cpx_type[MATE.cpx_melt_part_select] == '2'):

					MATE.d_melt_cpx = np.zeros(len(self.p))

					for i in range(0,len(self.p)):
						if self.p[i] < self.d_melt_cpx_change[MATE.cpx_melt_part_select]:
							MATE.d_melt_cpx[i] = eval(self.d_melt_cpx_function[MATE.cpx_melt_part_select])
						else:
							MATE.d_melt_cpx[i] = eval(self.d_melt_cpx_function[MATE.cpx_melt_part_select])

				elif (MATE.d_melt_cpx_type[MATE.cpx_melt_part_select] == '4'):

					MATE.d_melt_cpx = np.ones(len(self.p)) * float(self.d_melt_cpx_function[MATE.cpx_melt_part_select])


				if (MATE.d_melt_ol_type[MATE.ol_melt_part_select] == '4'):

					MATE.d_melt_ol = np.ones(len(self.p)) * float(self.d_melt_ol_function[MATE.ol_melt_part_select])

				if (MATE.d_melt_gt_type[MATE.gt_melt_part_select] == '4'):

					MATE.d_melt_gt = np.ones(len(self.p)) * float(self.d_melt_gt_function[MATE.gt_melt_part_select])

				#Calculating partition coeff of water between per and melt from Hirschmann et al. (2009)
				self.d_per_melt = (self.ol_frac_wt * MATE.d_melt_ol) +\
					(self.opx_frac_wt * MATE.d_melt_opx) +\
					(self.cpx_frac_wt * MATE.d_melt_cpx) +\
					(self.gt_frac_wt * MATE.d_melt_gt)

				MATE.melt_partitions_calculated = True
			
			if self.solidus_wet_calculated == False:
				self.calculate_wet_solidus(method = method, idx = idx_node)
			
			if self.solidus_carbon_calculated == False:
				self.calculate_carbonated_solidus(method = method, idx = idx_node)

			self.melt_h2o[idx_node] = self.calculate_melt_water(h2o_bulk = self.h2o[idx_node], melt_mass_frac = self.melt_mass_frac[idx_node], d_per_melt = self.d_per_melt[idx_node])

			#reassigning the zero mass frac melt layers using pre-mapped indexing array.
			if idx_node == None:
				self.melt_h2o[self.melt_mass_frac <= 0.0] = 0.0
			# else:
			# 	self.melt_h2o[idx_node] = 0.0

			#Recalculating the self.h2o as peridotite (solid) water content
			self.h2o_solid[idx_node] = (self.h2o[idx_node] * self.d_per_melt[idx_node]) /\
				(self.melt_mass_frac[idx_node] + ((1.0 - self.melt_mass_frac[idx_node]) * self.d_per_melt[idx_node]))
		else:

			self.h2o_solid[idx_node] = self.h2o[idx_node]

		if MATE.mineral_partitions_calculated == False:
			#CALCULATING AL-DEPENDENT PARTITION COEFF
			if MATE.part_px_method == '1':
				#OPX/OL if they are handled independently.
				if (MATE.d_opx_type[MATE.opx_part_select] == '1') or (MATE.d_opx_type[MATE.opx_part_select] == '3'):
					#Evaluating function that are stored in str form in csv files.

					MATE.d_opx_ol = eval(self.dopx_function[MATE.opx_part_select])
				elif (MATE.d_opx_type[MATE.opx_part_select] == '2'):
					MATE.d_opx_ol = np.zeros(len(self.p))
					for i in range(0,len(self.p)):
						if self.p[i] < self.dopx_change[MATE.opx_part_select]:
							MATE.d_opx_ol[i] = eval(self.dopx_function[MATE.opx_part_select])
						else:
							MATE.d_opx_ol[i] = eval(self.dopx_function_2[MATE.opx_part_select])
				elif (MATE.d_opx_type[MATE.opx_part_select] == '4'):
					MATE.d_opx_ol = np.ones(len(self.p)) * float(self.dopx_function[MATE.opx_part_select])

				#If tree for handling CPX/OL

				if (MATE.d_cpx_type[MATE.cpx_part_select] == '1') or (MATE.d_cpx_type[MATE.cpx_part_select] == '3') or (MATE.d_cpx_type[MATE.cpx_part_select] == '5') :
					#Evaluating function that are stored in str form in csv files.
					MATE.d_cpx_ol = eval(self.dcpx_function[MATE.cpx_part_select])
				elif (MATE.d_cpx_type[MATE.cpx_part_select] == '2'):
					MATE.d_cpx_ol = np.zeros(len(self.p))
					for i in range(0,len(self.p)):
						if self.p[i] < self.dcpx_change[MATE.cpx_part_select]:
							MATE.d_cpx_ol[i] = eval(self.dcpx_function[MATE.cpx_part_select])
						else:
							MATE.d_cpx_ol[i] = eval(self.dcpx_function_2[MATE.cpx_part_select])
				elif (MATE.d_cpx_type[MATE.cpx_part_select] == '4'):
					MATE.d_cpx_ol = np.ones(len(self.p)) * float(self.dcpx_function[MATE.cpx_part_select])

			else:

				if (MATE.d_opx_type[MATE.opx_part_select] == '0') or (MATE.d_opx_type[MATE.opx_part_select] == '1') or (MATE.d_opx_type[MATE.opx_part_select] == '3'):

					MATE.d_opx_ol =  eval(self.d_px_function[MATE.px_part_select])
					MATE.d_cpx_ol =  eval(self.d_px_function[MATE.px_part_select])

				elif (MATE.d_px_type[MATE.px_part_select] == '4'):

					MATE.d_opx_ol = np.ones(len(self.p)) * float(self.d_px_function[MATE.px_part_select])
					MATE.d_cpx_ol = np.ones(len(self.p)) * float(self.d_px_function[MATE.px_part_select])

			#IF TREE FOR GT/OL

			if MATE.d_gt_type[MATE.gt_part_select] == '4':

				MATE.d_gt_ol = np.ones(len(self.p)) * float(self.d_gt_function[MATE.gt_part_select])

			if MATE.d_amp_type[MATE.amp_part_select] == '4':

				MATE.d_amp_ol = np.ones(len(self.p)) * float(self.d_amp_function[MATE.amp_part_select])

			if MATE.d_pl_type[MATE.pl_part_select] == '4':

				MATE.d_pl_ol = np.ones(len(self.p)) * float(self.d_pl_function[MATE.pl_part_select])

			MATE.mineral_partitions_calculated = True

		#DISTRIBUTING THE BULK WATER TO THE PHASES

		#Calculating the water content in olivine first

		if MATE.part_px_method == '1':

			if MATE.hydr_part_method == 0:
				self.ol_h2o[idx_node] = self.h2o_solid[idx_node] / (self.ol_frac[idx_node] + ((self.opx_frac[idx_node] * MATE.d_opx_ol[idx_node]) + (self.cpx_frac[idx_node] * MATE.d_cpx_ol[idx_node]) + (self.gt_frac[idx_node] * MATE.d_gt_ol[idx_node]) +\
				(self.amp_frac[idx_node] * MATE.d_amp_ol[idx_node]) + (self.pl_frac[idx_node] * MATE.d_pl_ol[idx_node])))
			else:
				self.ol_h2o[idx_node] = self.h2o_solid[idx_node] / (self.ol_frac[idx_node] + ((self.opx_frac[idx_node] * MATE.d_opx_ol[idx_node]) + (self.cpx_frac[idx_node] * MATE.d_cpx_ol[idx_node]) + (self.gt_frac[idx_node] * MATE.d_gt_ol[idx_node])))

			self.opx_h2o[idx_node] = self.ol_h2o[idx_node] * MATE.d_opx_ol[idx_node]
			self.opx_h2o[self.opx_frac == 0] = 0.0

			self.cpx_h2o[idx_node] = self.ol_h2o[idx_node] * MATE.d_cpx_ol[idx_node]
			self.cpx_h2o[self.cpx_frac == 0] = 0.0

			self.gt_h2o[idx_node] = self.ol_h2o[idx_node] * MATE.d_gt_ol[idx_node]
			self.gt_h2o[self.gt_frac == 0] = 0.0

			if MATE.hydr_part_method == 0:

				self.amp_h2o[idx_node] = self.ol_h2o[idx_node] * MATE.d_amp_ol[idx_node]
				self.amp_h2o[self.amp_frac == 0] = 0.0

				self.pl_h2o[idx_node] = self.ol_h2o[idx_node] * MATE.d_pl_ol[idx_node]
				self.pl_h2o[self.pl_frac == 0] = 0.0

		elif MATE.part_px_method == '0':

			self.px_frac = self.opx_frac + self.cpx_frac
			if MATE.hydr_part_method == 0:
				self.ol_h2o[idx_node] = self.h2o_solid[idx_node] / (self.ol_frac[idx_node] + ((self.px_frac[idx_node] * MATE.d_opx_ol[idx_node]) + (self.gt_frac[idx_node] * MATE.d_gt_ol[idx_node]) +\
				(self.amp_frac[idx_node] * MATE.d_amp_ol[idx_node]) + (self.pl_frac[idx_node] * MATE.d_pl_ol[idx_node])))
			else:
				self.ol_h2o[idx_node] = self.h2o_solid[idx_node] / (self.ol_frac[idx_node] + ((self.px_frac[idx_node] * MATE.d_opx_ol[idx_node]) + (self.gt_frac[idx_node] * MATE.d_gt_ol[idx_node])))

			self.px_h2o[idx_node] = self.ol_h2o[idx_node] * MATE.d_opx_ol[idx_node]
			self.px_h2o[self.opx_frac == 0] = 0.0

			self.gt_h2o[idx_node] = self.ol_h2o[idx_node] * MATE.d_gt_ol[idx_node]
			self.gt_h2o[self.gt_frac == 0] = 0.0

			if MATE.hydr_part_method == 0:

				self.amp_h2o[idx_node] = self.ol_h2o[idx_node] * MATE.d_amp_ol[idx_node]
				self.amp_h2o[self.amp_frac == 0] = 0.0

				self.pl_h2o[idx_node] = self.ol_h2o[idx_node] * MATE.d_pl_ol[idx_node]
				self.pl_h2o[self.pl_frac == 0] = 0.0

		if self.water_end == True:
			if MATE.w_inp_method == '0':
				if self.coun == 0:
					self.ol_h2o_min = self.ol_h2o
					if MATE.part_px_method == '1':
						self.opx_h2o_min = self.opx_h2o
						self.cpx_h2o_min = self.cpx_h2o
					else:
						self.px_h2o_min = self.px_h2o
					self.gt_h2o_min = self.gt_h2o
					if self.amp_method == 0:
						self.amp_h2o_min = self.amp_h2o
					elif self.pl_method == 0:
						self.pl_h2o_min = self.pl_h2o
				elif self.coun == 1:
					self.ol_h2o_max = self.ol_h2o
					if MATE.part_px_method == '1':
						self.opx_h2o_max = self.opx_h2o
						self.cpx_h2o_max = self.cpx_h2o
					else:
						self.px_h2o_max = self.px_h2o
					self.gt_h2o_max = self.gt_h2o
					if self.amp_method == 0:
						self.amp_h2o_max = self.amp_h2o
					elif self.pl_method == 0:
						self.pl_h2o_max = self.pl_h2o

					self.water_inverted = True


	def calculate_fugacity(self,mode):

		#Function that calculates oxygen fugacity buffers from selection.

		self.A_list = [-999,-27489.0,-999,-24930.0,-30650.0]
		self.B_list = [-999,6.702,-999,9.36,8.92]
		self.C_list = [-999,0.055,-999,0.046,0.054]

		#OXYGEN FUGACITY BUFFER CONSTANTS in the lists above(self.A_list ...)
		#Index 0: FMQ:
		#Index 1: IW: Hirsch (1991)
		#Index 2: QIF:
		#Index 3: NNO: Li et al. (1998)
		#Index 4 MMO: Xu et al. (2000)

		self.A_FMQ_low = -26455.3
		self.A_FMQ_high = -25096.3
		self.B_FMQ_low = 10.344
		self.B_FMQ_high = 8.735
		self.C_FMQ_low = 0.092
		self.C_FMQ_high = 0.11
		self.T_crit = 846.0

		self.A_QIF_low = -29435.7
		self.A_QIF_high = -29520.8
		self.B_QIF_low = 7.391
		self.B_QIF_high = 7.492
		self.C_QIF_low = 0.044
		self.C_QIF_high = 0.05


		if (mode == 0):

			self.fo2 = np.zeros(len(self.T))

			for i in range(0,len(self.T)):

				if self.T[i] < self.T_crit:

					self.fo2[i] = 10**((self.A_FMQ_low / self.T[i]) + self.B_FMQ_low + ((self.C_FMQ_low * ((self.p[i]*1e4) - 1)) / self.T[i]))

				else:

					self.fo2[i] = 10**((self.A_FMQ_high / self.T[i]) + self.B_FMQ_high + ((self.C_FMQ_high * ((self.p[i]*1e4) - 1)) / self.T[i]))


		elif (mode == 2):

			self.fo2 = np.zeros(len(self.T))

			for i in range(0,len(self.T)):

				if self.T[i] < self.T_crit:

					self.fo2[i] = 10**((self.A_QIF_low / self.T[i]) + self.B_QIF_low + ((self.C_QIF_low * ((self.p[i]*1e4) - 1)) / self.T[i]))

				else:

					self.fo2[i] = 10**((self.A_QIF_high / self.T[i]) + self.B_QIF_high + ((self.C_QIF_high * ((self.p[i]*1e4) - 1)) / self.T[i]))


		elif (mode == 5):

			self.fo2 = self.calculate_fugacity(mode = 0)
			self.fo2_exchange = np.zeros(len(self.fo2))
			for i in range(0,len(self.fo2)):
				if (i > self.idx_start_fo2) and (i < self.idx_end_fo2):
					self.fo2_exchange[i] = self.fo2_read[i-self.idx_start_fo2]
				else:
					self.fo2_exchange[i] = 0.0
			self.fo2 = 10.0**(np.log10(self.fo2) + self.fo2_exchange)

		else:

			self.fo2 = 10**((self.A_list[mode] / self.T) + self.B_list[mode] + ((self.C_list[mode] * ((self.p*1e4) - 1)) / self.T))

		#self.fo2 is in bars multiply by 1e5 for Pa and 1e-4 for GPa

		return self.fo2

	def read_csv_fo2_file(self):

		self.csv_fo2_data = self.read_csv(str(self.csv_fo2_file_name[0]),delim = ',')

		self.depth_fo2 = []
		self.fo2_fmq = []

		try:
			for i in range(1,len(self.csv_fo2_data)):

				self.depth_fo2.append(float(self.csv_fo2_data[i][0])*1e3)
				self.fo2_fmq.append(float(self.csv_fo2_data[i][1]))

		except (IndexError, ValueError):
			QMessageBox.about(self, "WARNING!","There is something wrong with the file format you entered. Check out the info in oxygen fugacity menubar.")
			return

		self.depth_fo2 = np.array(self.depth_fo2)
		self.fo2_fmq = np.array(self.fo2_fmq)

		self.idx_start_fo2, = np.where(self.depth == self.find_nearest(self.depth,self.depth_fo2[0]))
		self.idx_start_fo2 = int(self.idx_start_fo2) + 1
		self.idx_end_fo2, = np.where(self.depth == self.find_nearest(self.depth,self.depth_fo2[-1]))
		self.idx_end_fo2 = int(self.idx_end_fo2) + 1
		f_fo2_read = interp1d(self.depth_fo2,self.fo2_fmq)
		self.fo2_read = f_fo2_read(self.depth[self.idx_start_fo2:self.idx_end_fo2])

		self.fo2_input = True
		QMessageBox.about(self, "Info","Oxygen fugacity data is succesfully improted to the program.")

	def calculate_h2o_fugacity(self):

		#Water fugacity calculation for pure water from the EOS of Pitzer and Sterner (1994), adapted after the python script of Tony Withers taken from his personal website.

		coeff = [[0,0,0.24657688e6,0.51359951e2,0,0],[0,0,0.58638965e0,-0.28646939e-2,0.31375577e-4,0],
		[0,0,-0.62783840e1,0.14791599e-1,0.35779579e-3,0.15432925e-7],[0,0,0,-0.42719875e0,-0.16325155e-4,0],
		[0,0,0.56654978e4,-0.16580167e2,0.76560762e-1,0],[0,0,0,0.10917883e0,0,0],
		[0.38878656e13,-0.13494878e9,0.30916564e6,0.75591105e1,0,0],[0,0,-0.65537898e5,0.18810675e3,0,0],
		[-0.14182435e14,0.18165390e9,-0.19769068e6,-0.23530318e2,0,0],[0,0,0.92093375e5,0.12246777e3,0,0]]

		c = []

		def PSeos(volume, temperature, targetP):  # cc/mol, Kelvins, bars
			R=8314510  # Pa.cc/K/mol
			den=1/volume  # mol/cc

			for i in range(10):
					c.insert(i,coeff[i][0]*temperature**-4+coeff[i][1]*temperature**-2
							+coeff[i][2]*temperature**-1+coeff[i][3]
							+coeff[i][4]*temperature+coeff[i][5]*temperature**2)

			pressure = (den+c[0]*den**2-den**2*((c[2]+2*c[3]*den+3*c[4]*den**2
					+4*c[5]*den**3)/(c[1]+c[2]*den+c[3]*den**2+c[4]*den**3
					+c[5]*den**4)**2)+c[6]*den**2*math.exp(-c[7]*den)
					+c[8]*den**2*math.exp(-c[9]*den))*R*temperature/1e5
			return pressure-targetP  # bars

		def PSvolume(pressure, temperature):  # bars, Kelvins

			volume = optimize.root(PSeos, 10, args = (temperature, pressure))
			return volume.x

		def PSfugacity(pressure, temperature):  # bars, Kelvins

			for i in range(10):
					c.insert(i,coeff[i][0]*temperature**-4+coeff[i][1]*temperature**-2
							+coeff[i][2]*temperature**-1+coeff[i][3]
							+coeff[i][4]*temperature+coeff[i][5]*temperature**2)

			volume=PSvolume(pressure, temperature)
			R = 8314510  # Pa.cc/K/mol
			den = 1/volume  # mol/cc
			fug = math.exp(math.log(den)+c[0]*den+(1/(c[1]+c[2]*den+c[3]*den**2
						+c[4]*den**3+c[5]*den**4)-1/c[1])
						-c[6]/c[7]*(math.exp(-c[7]*den)-1)
						-c[8]/c[9]*(math.exp(-c[9]*den)-1)
						+pressure*1e5/(den*R*temperature)
						+math.log(R*temperature)-1)/1e5
			return fug  # bars

		self.h2o_fug = np.zeros(len(self.T))

		for i in range(0,len(self.T)):

			self.h2o_fug[i] = PSfugacity(self.p[i]*1e4,self.T[i]) / 1e4 #in GPa

	def calculate_dry_solidus(self):

		if MATE.solidus_dry_model_type[MATE.solidus_dry_model_selection] == 0:
			self.T_dry_solidus = eval(MATE.solidus_dry_model_names[MATE.solidus_dry_model_selection] + '(T = self.T, P = self.p)')
			self.solidus_dry_calculated = True
			self.T_wet_solidus = np.array(self.T_dry_solidus)
			self.T_carbon_solidus = np.array(self.T_dry_solidus)

	def calculate_wet_solidus(self, method, idx = None):

		if np.mean(self.h2o[self.idx_moho:]) != 0.0:
			if MATE.solidus_wet_model_type[MATE.solidus_wet_model_selection] == 0:
				if method == 'array':
					self.T_wet_solidus = eval(MATE.solidus_wet_model_names[MATE.solidus_wet_model_selection] + '(method = method, T = self.T, T_solidus = self.T_dry_solidus, P = self.p, Melt_Mass_Frac = self.melt_mass_frac, H2O = self.h2o, D_per_melt = self.d_per_melt, cpx_frac = self.cpx_frac)')
				elif method == 'index':
					self.T_wet_solidus[idx] = eval(MATE.solidus_wet_model_names[MATE.solidus_wet_model_selection] + '(method = method, T = self.T, T_solidus = self.T_dry_solidus[idx], P = self.p[idx], Melt_Mass_Frac = self.melt_mass_frac[idx], H2O = self.h2o[idx], D_per_melt = self.d_per_melt[idx], cpx_frac = self.cpx_frac[idx])')
				self.solidus_wet_calculated = True

	def calculate_carbonated_solidus(self, method, idx = None):

		if np.mean(self.co2[self.idx_moho:]) != 0.0:
			if MATE.solidus_carbon_model_type[MATE.solidus_carbon_model_selection] == 0:
				if method == 'array':
					self.T_carbon_solidus = eval(MATE.solidus_carbon_model_names[MATE.solidus_carbon_model_selection] + '(T = self.T, T_solidus = self.T_wet_solidus, P = self.p, CO2_Melt = self.co2)')
				elif method == 'index':
					self.T_carbon_solidus[idx] = eval(MATE.solidus_carbon_model_names[MATE.solidus_carbon_model_selection] + '(T = self.T, T_solidus = self.T_wet_solidus[idx], P = self.p, CO2_Melt = self.co2[idx])')
				self.solidus_carbon_calculated = True

	def calculate_melt_water(self, h2o_bulk, melt_mass_frac, d_per_melt):

		#Calculating the h2o content of melt that is in equilibrium with the entered solid-mixture, from Sifre et al. (2014)
		melt_water = h2o_bulk / (melt_mass_frac + ((1.0 - melt_mass_frac) * d_per_melt))

		return melt_water

	def calculate_melt_fraction(self):

		#After Blatter2022

		if self.solidus_wet_calculated == True:
			if self.solidus_carbon_calculated == True:
				self.melt_mass_frac = (self.T - self.T_carbon_solidus) / self.dT_dF
			else:
				self.melt_mass_frac = (self.T - self.T_wet_solidus) / self.dT_dF
		else:
			self.melt_mass_frac = (self.T - self.T_dry_solidus) / self.dT_dF

	def calculate_melt_fraction_minimise(self,F):

		self.calculate_wet_solidus(method = self.searching_for_root_melt_frac, idx = self.index_melt_frac)
		self.calculate_carbonated_solidus(method = self.searching_for_root_melt_frac, idx = self.index_melt_frac)

		if self.solidus_wet_calculated == True:
			if self.solidus_carbon_calculated == True:
				H = F - ((self.T[self.idx_moho:] - self.T_carbon_solidus[self.idx_moho:]) / self.dT_dF[self.idx_moho:])
			else:
				H = F - ((self.T[self.idx_moho:] - self.T_wet_solidus[self.idx_moho:]) / self.dT_dF[self.idx_moho:])
		else:
			H = F - ((self.T[self.idx_moho:] - self.T_dry_solidus[self.idx_moho:]) / self.dT_dF[self.idx_moho:])

		return H

	def calculate_melt_fraction_iterative(self,method,sol_idx):

		if MATE.melt_method != '0':

			MATE.melt_method = '0'
			self.calculate_water(method = 'array', idx = None)
			self.melt_calc_from_zero_melt = True

		else:

			pass

		if method == 'array':
			self.searching_for_root_melt_frac = 'array'
			self.index_melt_frac = None
		else:
			self.searching_for_root_melt_frac = 'index'
			self.index_melt_frac = sol_idx
		sol = optimize.root(self.calculate_melt_fraction_minimise, x0= self.melt_mass_frac[self.idx_moho:], method='lm')
		F = sol.x
		F[F <= 0.0] = 0

		return F

	def solubility_ol(self):

		#Def that calculates olivine storage capacities with different sources, sol_method.
		if self.ol_sol_fug_dep[MATE.sol_method] == 'Y':
			if self.h2o_fugacity_calculated == False:
				QMessageBox.about(self,'May take time (30-45 s)','Calculating pure water EOS here please be patient (for storage capacities)... press ok to continue')
				self.calculate_h2o_fugacity()
				self.h2o_fugacity_calculated = True
			self.fug_calc = True
		else:
			self.h2o_fug = np.zeros(len(self.T))
			self.fug_calc = False

		if ('*' in MATE.name_ol_sol[MATE.sol_method]) == True:

			ol_sol_function = MATE.name_ol_sol[MATE.sol_method].replace('*','')

		else:

			ol_sol_function = MATE.name_ol_sol[MATE.sol_method]

		self.max_ol_h2o = eval(ol_sol_function + '(T = self.T,P = self.p,depth = self.depth,h2o_fug = self.h2o_fug,o2_fug = self.calculate_fugacity(MATE.o2_buffer),fe_ol = self.fe_ol,ti_ol = self.ti_ol)')

		self.ol_sol_calibration = self.ol_sol_wcalib[MATE.sol_method]

		if MATE.ol_calib != MATE.ol_sol_calib:
			QMessageBox.about(self, "WARNING!","Chosen water calibration for conductivity and solubility models are not the same. Be cautious about your results!")

		if MATE.ol_sol_calib == 3:
			self.correction_factor_ol = 1.0
		else:
			self.FTIR_correction(min_idx = 0,sol_calc = 0)

		self.max_ol_h2o = self.max_ol_h2o * self.correction_factor_ol

	def solubility_partitioning(self):

		#Calculation of solubilties of other phases from selected partitioning methods.

		if MATE.part_px_method == '1':

			self.max_opx_h2o = self.max_ol_h2o * MATE.d_opx_ol
			self.max_cpx_h2o = self.max_ol_h2o * MATE.d_cpx_ol

		elif MATE.part_px_method == '0':

			self.max_px_h2o = self.max_ol_h2o * MATE.d_opx_ol #Here opx is the same as cpx and equivalent to px

		self.max_gt_h2o = self.max_ol_h2o * MATE.d_gt_ol

		if MATE.sol_model_pref_select == 0:

			for i in range(0,len(self.ol_h2o)):
				if self.ol_frac[i] != 0.0:
					self.ol_h2o[i] = self.max_ol_h2o[i]
				else:
					self.ol_h2o[i] = 0.0
					self.max_ol_h2o[i] = 0.0
				if self.gt_frac[i] != 0.0:
					self.gt_h2o[i] = self.max_gt_h2o[i]
				else:
					self.gt_h2o[i] = 0.0
					self.max_gt_h2o[i] = 0.0
				if MATE.part_px_method == '1':
					if self.opx_frac[i] != 0.0:
						self.opx_h2o[i] = self.max_opx_h2o[i]
					else:
						self.opx_h2o[i] = 0.0
						self.max_opx_h2o[i] = 0.0
					if self.cpx_frac[i] != 0.0:
						self.cpx_h2o[i] = self.max_cpx_h2o[i]
					else:
						self.cpx_h2o[i] = 0.0
						self.max_cpx_h2o[i] = 0.0
				elif MATE.part_px_method == '0':
					if (self.opx_frac[i] + self.cpx_frac[i]) != 0.0:
						self.px_h2o[i] = self.max_px_h2o[i]
					else:
						self.px_h2o[i] = 0.0
						self.max_px_h2o[i] = 0.0

			if MATE.part_px_method == '1':
				self.h2o_from_sol = (self.ol_h2o * self.ol_frac) + (self.opx_h2o * self.opx_frac) + (self.cpx_h2o * self.cpx_frac) + (self.gt_h2o * self.gt_frac)
			else:
				self.h2o_from_sol = (self.ol_h2o * self.ol_frac) + (self.px_h2o * (self.opx_frac + self.cpx_frac)) + (self.gt_h2o * self.gt_frac)

			if MATE.melt_method == '0':

				self.melt_h2o = self.h2o_from_sol / self.d_per_melt
				self.melt_h2o[self.melt_mass_frac <= 0.0] = 0.0

				self.h2o = self.h2o_from_sol * (self.melt_mass_frac + ((1-self.melt_mass_frac) * self.d_per_melt)) / self.d_per_melt

				for j in range(0,len(self.h2o_from_sol)):

					if self.melt_mass_frac[j] != 0:

						self.h2o_from_sol[j] = self.h2o_from_sol[j] * (self.melt_mass_frac[j] + ((1-self.melt_mass_frac[j]) * self.d_per_melt[j])) / self.d_per_melt[j]



	def check_sol_limit(self):

		self.sol_error = False
		self.sol_error_ol = False
		self.sol_error_opx = False
		self.sol_error_cpx = False
		self.sol_error_gt = False
		self.sol_error_px = False

		self.idx_ol_err_lst = []
		self.idx_opx_err_lst = []
		self.idx_cpx_err_lst = []
		self.idx_gt_err_lst = []
		self.idx_px_err_lst = []

		for i in range(self.idx_moho,len(self.T)):

			if self.ol_h2o[i] > self.max_ol_h2o[i]:
				self.idx_ol_err_lst.append(i)
				self.sol_error = True
				self.sol_error_ol = True

			if MATE.part_px_method == '0':
				if self.px_h2o[i] > self.max_px_h2o[i]:
					self.idx_px_err_lst.append(i)
					self.sol_error = True
					self.sol_error_px = True
			elif MATE.part_px_method == '1':
				if self.opx_h2o[i] > self.max_opx_h2o[i]:
					self.idx_opx_err_lst.append(i)
					self.sol_error = True
					self.sol_error_opx = True

				if self.cpx_h2o[i] > self.max_cpx_h2o[i]:
					self.idx_cpx_err_lst.append(i)
					self.sol_error = True
					self.sol_error_cpx = True

			if self.gt_h2o[i] > self.max_gt_h2o[i]:
				self.idx_gt_err_lst.append(i)
				self.sol_error = True
				self.sol_error_gt = True

		if self.sol_error == True:
			QMessageBox.about(self, "ERROR!", "There are some portions of the model where certain phases exceeds the maximum solubilities." +
			" They are indicated with red x signs in the graph")

	def FTIR_correction(self,min_idx = None,sol_calc = None):

		#A function that corrects the water content to desired calibration. Numbers are taken from Demouchy and Bolfan-Casanova (2016, Lithos)

		if min_idx == 0:
			if sol_calc == 0:
				calib_object = self.ol_sol_calibration
				calib_object_2 = MATE.ol_sol_calib
			elif sol_calc == 1:
				calib_object = self.w_calib[0][MATE.ol_cond_selection]
				calib_object_2 = MATE.ol_calib
			elif sol_calc == 2:
				calib_object = self.ol_calib_GB[MATE.GB_ol_select]
				calib_object_2 = MATE.ol_calib

			if calib_object_2 == 0:

				if calib_object == 0:

					if sol_calc == 2:
						self.correction_factor_GB = self.pat2with
					else:
						self.correction_factor_ol = self.pat2with #Paterson to Withers

				elif calib_object == 1:

					if sol_calc == 2:
						self.correction_factor_GB = self.bell2with
					else:
						self.correction_factor_ol = self.bell2with #Bell to Withers from Demouchy and Bolfan Casanova

				else:

					if sol_calc == 2:
						self.correction_factor_GB = 1.0
					else:
						self.correction_factor_ol = 1.0 #Withers to Withers

			elif calib_object_2 == 1:

				if calib_object == 0:

					if sol_calc == 2:
						self.correction_factor_GB = self.pat2bell
					else:
						self.correction_factor_ol = self.pat2bell #Paterson to Bell

				elif calib_object == 1:

					if sol_calc == 2:
						self.correction_factor_GB = 1.0
					else:
						self.correction_factor_ol = 1.0 #Bell to Bell

				else:

					if sol_calc == 2:
						self.correction_factor_GB = self.with2bell
					else:
						self.correction_factor_ol = self.with2bell #Withers to Bell


			elif calib_object_2 == 2:

				if calib_object == 0:

					if sol_calc == 2:
						self.correction_factor_GB = 1.0
					else:
						self.correction_factor_ol = 1.0 #Paterson to paterson

				elif calib_object == 1:

					if sol_calc == 2:
						self.correction_factor_GB = self.bell2path
					else:
						self.correction_factor_ol = self.bell2path #Bell to Paterson

				else:

					if sol_calc == 2:
						self.correction_factor_GB = self.with2pat
					else:
						self.correction_factor_ol = self.with2pat #Withers to Paterson

		if min_idx == 1:

			if MATE.opx_cond_selection < 0:
				if MATE.opx_cond_selection == -999:
					opx_prox = 0
					idx_px = 2
				else:
					opx_prox = MATE.opx_cond_selection * -1
					idx_px = 2

			else:

				opx_prox = MATE.opx_cond_selection
				idx_px = 1

			if MATE.px_calib == 0:

				if (self.w_calib[idx_px][opx_prox] == 0):

					self.correction_factor_pxgt = self.pat2bell95

				else:

					self.correction_factor_pxgt = 1.0

			elif MATE.px_calib == 1:

				if (self.w_calib[idx_px][opx_prox] == 1):

					self.correction_factor_pxgt = self.bell952pat

				else:

					self.correction_factor_pxgt = 1.0

		if min_idx == 2:

			if MATE.cpx_cond_selection < 0:
				if MATE.cpx_cond_selection == -999:
					cpx_prox = 0
					idx_px = 1
				else:
					cpx_prox = MATE.cpx_cond_selection * -1
					idx_px = 1

			else:

				cpx_prox = MATE.cpx_cond_selection
				idx_px = 2

			if MATE.px_calib == 0:

				if (self.w_calib[idx_px][cpx_prox] == 0):

					self.correction_factor_pxgt = self.pat2bell95

				else:

					self.correction_factor_pxgt = 1.0

			elif MATE.px_calib == 1:

				if (self.w_calib[idx_px][cpx_prox] == 1):

					self.correction_factor_pxgt = self.bell952pat

				else:

					self.correction_factor_pxgt = 1.0

		if min_idx == 3:

			if MATE.px_calib == 0:

				if (self.w_calib[3][MATE.gt_cond_selection] == 0):

					self.correction_factor_pxgt = self.pat2bell95

				else:

					self.correction_factor_pxgt = 1.0

			elif MATE.px_calib == 1:

				if (self.w_calib[3][MATE.gt_cond_selection] == 1):

					self.correction_factor_pxgt = self.bell952pat

				else:

					self.correction_factor_pxgt = 1.0

	def FTIR_calibration_error(self,min_idx,calib_no):

		#A function that returs associated errors of calibrations. Numbers are taken from Demouchy and Bolfan-Casanova (2016, Lithos)

		if min_idx == 0:
			if calib_no == 0:
				error_calib = 0.3
			elif calib_no == 1:
				error_calib = 0.1
			elif calib_no == 2:
				error_calib = 0.1
		else:
			if calib_no == 0:
				error_calib = 0.3
			else:
				error_calib = 0.1

		return error_calib

	def mineral_stabilities(self):

		#Checking the amphibole stability.
		self.idx_amph_st, = np.where(self.p == self.find_nearest(self.p[self.idx_moho:],self.P_amph[MATE.amph_stab_select]))
		self.idx_amph_st = int(self.idx_amph_st)

		for i in range(self.idx_amph_st,len(self.p)):
			if self.amp_frac[i] != 0.0:

				ok_to_plot_geotherm = False
			else:
				ok_to_plot_geotherm = True

		if ok_to_plot_geotherm == False:
			QMessageBox.about(self, "ERROR!", "Amphibole content was found out of the stability field. Depth of the stability field is calculated as  " + str(self.depth[self.idx_amph_st]/1000.0) + ' kms.')

		#Checking the garnet stability.
		for i in range(0,self.index_spinel):
			if self.gt_frac[i] !=0.0:

				ok_for_garnet = False
			else:
				ok_for_garnet = True

		if ok_for_garnet == False:

			QMessageBox.about(self, "ERROR!", "Garnet content was found out of the stability field. Depth of the stability field is calculated as  " + str(self.depth_spinel/1000.0) + ' kms.')
		#Here are the functions of dry conductivity models with non-ordinary conventions.

	def dry_vanilla(self,min_idx,c_idx,method,idx = None):

		#function that returs dry conductivity of minerals that can be defined by conventional arrhenian formalism.

		if method == 'array':
			idx_node = None
		elif method == 'index':
			idx_node = idx

		if self.sigma_i_dry[min_idx][c_idx] == 0:
			sigma_i_dry_calc = 0
		else:
			sigma_i_dry_calc = 10**self.sigma_i_dry[min_idx][c_idx]

		c_d_max = (sigma_i_dry_calc * np.exp(-(self.h_i_dry[min_idx][c_idx] - self.h_i_dry_err[min_idx][c_idx])/(self.R*self.T[idx_node]))) +\
			(10.0**self.sigma_pol_dry[min_idx][c_idx] * np.exp(-(self.h_pol_dry[min_idx][c_idx] - self.h_pol_dry_err[min_idx][c_idx]) / (self.R * self.T[idx_node])))
		c_d_min = (sigma_i_dry_calc * np.exp(-(self.h_i_dry[min_idx][c_idx] + self.h_i_dry_err[min_idx][c_idx])/(self.R*self.T[idx_node]))) +\
			(10.0**self.sigma_pol_dry[min_idx][c_idx] * np.exp(-(self.h_pol_dry[min_idx][c_idx] + self.h_pol_dry_err[min_idx][c_idx]) / (self.R * self.T[idx_node])))
		c_d = (sigma_i_dry_calc * np.exp(-(self.h_i_dry[min_idx][c_idx])/(self.R*self.T[idx_node]))) +\
			(10.0**self.sigma_pol_dry[min_idx][c_idx] * np.exp(-(self.h_pol_dry[min_idx][c_idx]) / (self.R * self.T[idx_node])))

		return c_d_max,c_d_min,c_d

	def conductivity_dry(self,min_idx,c_idx,method,sol_idx):

		#function that returs selected dry garnet conductivity model for models that does not accompanied by polaron and ionic cond.
		#type_dry = 0 indicates special form of conduction where it can not be described by conventional arrhenian formalism.

		if method == 'array':
			idx_node = None
		elif method == 'index':
			idx_node = sol_idx

		if MATE.type_dry[min_idx][c_idx] == '0':

			if ('*' in MATE.name_dry[min_idx][c_idx]) == True:

				dry_odd_function = MATE.name_dry[min_idx][c_idx].replace('*','')

			else:

				dry_odd_function = MATE.name_dry[min_idx][c_idx]

			c_d_max,c_d_min,c_d = eval(dry_odd_function + '(T = self.T[idx_node],fe_ol = self.fe_ol[idx_node],fe_opx = self.fe_opx[idx_node],fe_cpx = self.fe_cpx[idx_node],fe_gt = self.fe_gt[idx_node],P = self.p[idx_node],fo2 = self.calculate_fugacity(MATE.o2_buffer)[idx_node])')


		elif MATE.type_dry[min_idx][c_idx] == '1':

			c_d_max,c_d_min,c_d = self.dry_vanilla(min_idx = min_idx,c_idx = c_idx, method = method, idx = sol_idx)

		return c_d_max,c_d_min,c_d

	def conductivity_ionic(self,bound,min_idx,c_idx,method,sol_idx):

		#min_idx; 0:olivine,1:opx,2:cpx,3:garnet
		#c_idx: model_index

		if method == 'array':

			idx_node = None

		elif method == 'index':

			idx_node = sol_idx

		#If conditionals for determining whether proton conduction does not exists for that particular model.
		if MATE.model_method[min_idx] == 0:

			if self.sigma_i[min_idx][c_idx] == 0:
				if method == 'array':
					ionic_cond = np.zeros(len(self.T))[idx_node]
				elif method == 'index':
					ionic_cond = 0

			else:

				#Calculating the ionic conduction, bound 0:max with errors, bound1:min with errors bound 2:modelitself

				if bound == 0:
					ionic_cond = ((10.0**self.sigma_i[min_idx][c_idx]) * np.exp(-(self.h_i[min_idx][c_idx] - self.h_i_err[min_idx][c_idx]) / (self.R * self.T[idx_node])))
				elif bound == 1:
					ionic_cond = ((10.0**self.sigma_i[min_idx][c_idx]) * np.exp(-(self.h_i[min_idx][c_idx] + self.h_i_err[min_idx][c_idx]) / (self.R*self.T[idx_node])))
				elif bound == 2:
					ionic_cond = ((10.0**self.sigma_i[min_idx][c_idx]) * np.exp(-(self.h_i[min_idx][c_idx]) / (self.R*self.T[idx_node])))

		elif MATE.model_method[min_idx] == 1:

			if method == 'array':
				ionic_cond = np.zeros(len(self.T))[idx_node]
			else:
				ionic_cond = 0.0

		return ionic_cond

	def conductivity_polaron(self,bound,min_idx,c_idx,method,sol_idx):

		#min_idx; 0:olivine,1:opx,2:cpx,3:garnet
		#c_idx: model_index

		if method == 'array':

			idx_node = None

		elif method == 'index':

			idx_node = sol_idx

		#If conditionals for determining whether proton conduction does not exists for that particular model.
		if MATE.model_method[min_idx] == 0:

			if self.sigma_pol[min_idx][c_idx] == 0:
				#This is only zero because it only applies where the conventional methods.
				polaron_cond = np.zeros(len(self.T))

			else:
				#Calculating the polaron conduction, bound 0:max with errors, bound1:min with errors bound 2:modelitself
				if bound == 0:
					polaron_cond = ((10.0**self.sigma_pol[min_idx][c_idx]) * np.exp(-(self.h_pol[min_idx][c_idx] - self.h_pol_err[min_idx][c_idx]) / (self.R * self.T[idx_node])))
				elif bound == 1:
					polaron_cond = ((10.0**self.sigma_pol[min_idx][c_idx]) * np.exp(-(self.h_pol[min_idx][c_idx] + self.h_pol_err[min_idx][c_idx]) / (self.R * self.T[idx_node])))
				elif bound == 2:
					polaron_cond = ((10.0**self.sigma_pol[min_idx][c_idx]) * np.exp(-(self.h_pol[min_idx][c_idx]) / (self.R * self.T[idx_node])))

		elif MATE.model_method[min_idx] == 1:

			if min_idx == 0:
				p1,p2,p3 = self.conductivity_dry(0,MATE.ol_dry_selection,method = method,sol_idx = sol_idx)
			elif min_idx == 1:
				p1,p2,p3 = self.conductivity_dry(1,MATE.opx_dry_selection,method = method,sol_idx = sol_idx)
			elif min_idx == 2:
				p1,p2,p3 = self.conductivity_dry(2,MATE.cpx_dry_selection,method = method,sol_idx = sol_idx)
			elif min_idx == 3:
				p1,p2,p3 = self.conductivity_dry(3,MATE.gt_dry_selection,method = method,sol_idx = sol_idx)

			if bound == 0:
				polaron_cond = p1
			elif bound == 1:
				polaron_cond = p2
			elif bound == 2:
				polaron_cond = p3

		return polaron_cond


	def conductivity_proton(self,bound,min_idx,c_idx,method,sol_idx = None):

		#min_idx; 0:olivine,1:opx,2:cpx,3:garnet
		#c_idx: model_index

		if method == 'array':

			idx_node = None

		elif method == 'index':

			idx_node = sol_idx

		#Determining w_factor, which controls whether the formulation is set with ppm or weight percent. Multiplying by 1e4 if the latter.

		if self.wtype[min_idx][c_idx] == 0:
			self.w_factor = 1e4
		elif self.wtype[min_idx][c_idx] == 1:
			self.w_factor = 1.0

		#If conditionals for determining whether proton conduction does not exists for that particular model.

		if self.sigma_p[min_idx][c_idx] == 0:
			proton_cond = np.zeros(len(self.T))

		else:

			#Applying correction factor from calibrations and w_factor

			if min_idx == 0:
				h2o = self.ol_h2o[idx_node] / (self.correction_factor_ol * self.w_factor)
			elif min_idx == 1:
				if MATE.part_px_method == '0':
					h2o = self.px_h2o[idx_node] / (self.correction_factor_pxgt * self.w_factor)
				elif MATE.part_px_method == '1':
					h2o = self.opx_h2o[idx_node] / (self.correction_factor_pxgt * self.w_factor)
			elif min_idx == 2:
				if MATE.part_px_method == '0':
					h2o = self.px_h2o[idx_node] / (self.correction_factor_pxgt * self.w_factor)
				elif MATE.part_px_method == '1':
					h2o = self.cpx_h2o[idx_node] / (self.correction_factor_pxgt * self.w_factor)
			elif min_idx == 3:
				h2o = self.gt_h2o[idx_node] / (self.correction_factor_pxgt * self.w_factor)

			#Determining water error associated with selected calibration with the definition FTIR_calibration_error.
			wt_err = self.FTIR_calibration_error(min_idx,self.w_calib[min_idx][c_idx])

			#Calculating the proton conduction, bound 0:max with errors, bound1:min with errors bound 2:modelitself
			if bound == 0:

				proton_cond = ((10.0**self.sigma_p[min_idx][c_idx]) * (((h2o + (h2o * wt_err)))**(self.r[min_idx][c_idx] - self.r_err[min_idx][c_idx]))*\
						np.exp(-((self.h_p[min_idx][c_idx] - self.h_p_err[min_idx][c_idx]) - ((self.alpha_p[min_idx][c_idx] + self.alpha_p_err[min_idx][c_idx])*\
							(((h2o + (h2o * wt_err)))**(1.0/3.0)))) / (self.R * self.T[idx_node])))

			elif bound == 1:
				proton_cond = ((10.0**self.sigma_p[min_idx][c_idx]) * (((h2o - (h2o * wt_err)))**(self.r[min_idx][c_idx] + self.r_err[min_idx][c_idx]))*\
						np.exp(-((self.h_p[min_idx][c_idx] + self.h_p_err[min_idx][c_idx]) - ((self.alpha_p[min_idx][c_idx] - self.alpha_p_err[min_idx][c_idx])*\
							(((h2o - (h2o * wt_err)))**(1.0/3.0)))) / (self.R * self.T[idx_node])))

			elif bound == 2:
				proton_cond = ((10.0**self.sigma_p[min_idx][c_idx]) * (h2o**self.r[min_idx][c_idx])*\
						np.exp(-(self.h_p[min_idx][c_idx] - (self.alpha_p[min_idx][c_idx]*\
							(h2o**(1.0/3.0)))) / (self.R * self.T[idx_node])))

		return proton_cond

	def calculate_ol_conductivity(self,method,sol_idx = None):

		if MATE.ol_calib != 3:
			self.FTIR_correction(min_idx = 0,sol_calc = 1)
		else:
			self.correction_factor_ol = 1.0

		if method == 'array':
			idx_node = None
		elif method == 'index':
			idx_node = sol_idx

		def oriented_cond_ol(idx):

			ol_cond_max_array = []
			ol_cond_min_array = []
			ol_cond_array = []

			if MATE.type[0][idx] == '10':
				for i in range(0,3):
					if method == 'array':

						self.ol_cond_max_dum = self.conductivity_dry(0,MATE.ol_dry_selection,method,sol_idx)[0] + self.conductivity_proton(0,0,idx+i,method,sol_idx)
						self.ol_cond_min_dum = self.conductivity_dry(0,MATE.ol_dry_selection,method,sol_idx)[1] + self.conductivity_proton(1,0,idx+i,method,sol_idx)

						ol_cond_max_array.append(self.ol_cond_max_dum)
						ol_cond_min_array.append(self.ol_cond_min_dum)

					self.ol_cond_dum = self.conductivity_dry(0,MATE.ol_dry_selection,method,sol_idx)[2] + self.conductivity_proton(2,0,idx+i,method,sol_idx)
					ol_cond_array.append(self.ol_cond_dum)

				if method == 'array':
					self.ol_cond_max[idx_node] = (ol_cond_max_array[0] * ol_cond_max_array[1] * ol_cond_max_array[2])**(1.0/3.0)
					self.ol_cond_min[idx_node] = (ol_cond_min_array[0] * ol_cond_min_array[1] * ol_cond_min_array[2])**(1.0/3.0)
				self.ol_cond[idx_node] = (ol_cond_array[0] * ol_cond_array[1] * ol_cond_array[2])**(1.0/3.0)

			elif MATE.type[0][idx] == '20':

				ol_cond_max_dry_array = []
				ol_cond_min_dry_array = []
				ol_cond_dry_array = []

				for i in range(0,3):

					if method == 'array':
						self.ol_cond_max_dum = self.conductivity_proton(0,0,idx+i,method,sol_idx)
						self.ol_cond_min_dum = self.conductivity_proton(1,0,idx+i,method,sol_idx)

						self.ol_cond_max_dum_pol = self.conductivity_polaron(0,0,idx+i,method,sol_idx)
						self.ol_cond_min_dum_pol = self.conductivity_polaron(1,0,idx+i,method,sol_idx)

						ol_cond_max_dry_array.append(self.ol_cond_max_dum_pol)
						ol_cond_min_dry_array.append(self.ol_cond_min_dum_pol)

						ol_cond_max_array.append(self.ol_cond_max_dum)
						ol_cond_min_array.append(self.ol_cond_min_dum)

					self.ol_cond_dum = self.conductivity_proton(2,0,idx+i,method,sol_idx)
					self.ol_cond_dum_pol = self.conductivity_polaron(2,0,idx+i,method,sol_idx)

					ol_cond_array.append(self.ol_cond_dum)

					ol_cond_dry_array.append(self.ol_cond_dum_pol)


				self.ol_cond[idx_node] = (ol_cond_dry_array[0] * ol_cond_dry_array[1] * ol_cond_dry_array[2])**(1.0/3.0) +\
				(ol_cond_array[0] * ol_cond_array[1] * ol_cond_array[2])**(1.0/3.0)

				if method == 'array':
					self.ol_cond_max[idx_node] = (ol_cond_max_dry_array[0] * ol_cond_max_dry_array[1] * ol_cond_max_dry_array[2])**(1.0/3.0) +\
					(ol_cond_max_array[0] * ol_cond_max_array[1] * ol_cond_max_array[2])**(1.0/3.0)
					self.ol_cond_min[idx_node] = (ol_cond_min_dry_array[0] * ol_cond_min_dry_array[1] * ol_cond_min_dry_array[2])**(1.0/3.0) +\
					(ol_cond_min_array[0] * ol_cond_min_array[1] * ol_cond_min_array[2])**(1.0/3.0)
				else:
					self.ol_cond_max[idx_node] = self.ol_cond[idx_node]

			return self.ol_cond_max, self.ol_cond_min,self.ol_cond

		if MATE.type[0][MATE.ol_cond_selection] == '0':

			self.ol_cond[idx_node] = self.conductivity_ionic(2,0,MATE.ol_cond_selection,method,sol_idx) + self.conductivity_polaron(2,0,MATE.ol_cond_selection,method,sol_idx) +\
			self.conductivity_proton(2,0,MATE.ol_cond_selection,method,sol_idx)

			if method == 'array':

				self.ol_cond_max[idx_node] = self.conductivity_ionic(0,0,MATE.ol_cond_selection,method,sol_idx) + self.conductivity_polaron(0,0,MATE.ol_cond_selection,method,sol_idx) +\
				self.conductivity_proton(0,0,MATE.ol_cond_selection,method,sol_idx)

				self.ol_cond_min[idx_node] = self.conductivity_ionic(1,0,MATE.ol_cond_selection,method,sol_idx) + self.conductivity_polaron(1,0,MATE.ol_cond_selection,method,sol_idx) +\
				self.conductivity_proton(1,0,MATE.ol_cond_selection,method,sol_idx)

			else:

				self.ol_cond_max[idx_node] = self.ol_cond[idx_node]
				self.ol_cond_min[idx_node] = self.ol_cond[idx_node]

		elif MATE.type[0][MATE.ol_cond_selection] == '1':


			self.ol_cond[idx_node] = self.conductivity_dry(0,MATE.ol_dry_selection,method,sol_idx)[2] + self.conductivity_proton(2,0,MATE.ol_cond_selection,method,sol_idx)

			if method == 'array':

				self.ol_cond_max[idx_node] = self.conductivity_dry(0,MATE.ol_dry_selection,method,sol_idx)[0] + self.conductivity_proton(0,0,MATE.ol_cond_selection,method,sol_idx)
				self.ol_cond_min[idx_node] = self.conductivity_dry(0,MATE.ol_dry_selection,method,sol_idx)[1] + self.conductivity_proton(1,0,MATE.ol_cond_selection,method,sol_idx)

			else:

				self.ol_cond_max[idx_node] = self.ol_cond[idx_node]
				self.ol_cond_min[idx_node] = self.ol_cond[idx_node]

		elif (MATE.type[0][MATE.ol_cond_selection] == '11') or (MATE.type[0][MATE.ol_cond_selection] == '21'):

			self.ol_cond_max[idx_node], self.ol_cond_min[idx_node],self.ol_cond[idx_node] = oriented_cond_ol(idx = MATE.ol_cond_selection - 1)

		elif (MATE.type[0][MATE.ol_cond_selection] == '12') or (MATE.type[0][MATE.ol_cond_selection] == '22'):

			self.ol_cond_max[idx_node], self.ol_cond_min[idx_node],self.ol_cond[idx_node] = oriented_cond_ol(idx = MATE.ol_cond_selection - 2)

		elif (MATE.type[0][MATE.ol_cond_selection] == '10') or (MATE.type[0][MATE.ol_cond_selection] == '20'):

			self.ol_cond_max[idx_node], self.ol_cond_min[idx_node],self.ol_cond[idx_node] = oriented_cond_ol(idx = MATE.ol_cond_selection)

		elif (MATE.type[0][MATE.ol_cond_selection] == '3'):

			if ('*' in MATE.name[0][MATE.ol_cond_selection]) == True:

				ol_wet_odd_function = MATE.name[0][MATE.ol_cond_selection].replace('*','')

			else:

				ol_wet_odd_function = MATE.name[0][MATE.ol_cond_selection]

			cond_ol_max,cond_ol_min,cond_ol,cond_dry,cond_wet = eval(ol_wet_odd_function + '(model_method = MATE.model_method[0],T = self.T[idx_node],P = self.p[idx_node],corr_factor = self.correction_factor_ol,fo2 = self.calculate_fugacity(MATE.o2_buffer)[idx_node],fo2_ref = self.calculate_fugacity(3)[idx_node],wt_err = self.FTIR_calibration_error(0,self.w_calib[0][MATE.ol_cond_selection]),ol_h2o = self.ol_h2o[idx_node], method = method)')

			if MATE.model_method[0] == 0:

				self.ol_cond[idx_node] = cond_ol
				if method == 'array':
					self.ol_cond_max[idx_node] = cond_ol_max
					self.ol_cond_min[idx_node] = cond_ol_min
				else:
					self.ol_cond_max[idx_node] = self.ol_cond[idx_node]
					self.ol_cond_min[idx_node] = self.ol_cond[idx_node]

			elif MATE.model_method[0] == 1:

				self.ol_cond[idx_node] = self.conductivity_dry(0,MATE.ol_dry_selection,method,sol_idx)[2] + cond_ol
				if method == 'array':
					self.ol_cond_max[idx_node] = self.conductivity_dry(0,MATE.ol_dry_selection,method,sol_idx)[0] + cond_ol_max
					self.ol_cond_min[idx_node] = self.conductivity_dry(0,MATE.ol_dry_selection,method,sol_idx)[1] + cond_ol_min
				else:
					self.ol_cond_max[idx_node] = self.ol_cond[idx_node]
					self.ol_cond_min[idx_node] = self.ol_cond[idx_node]


		elif (MATE.type[0][MATE.ol_cond_selection] == '4') or (MATE.type[0][MATE.ol_cond_selection] == '5'):

			h2o_h_ol = (self.avog * (self.rho_ol[idx_node]*1e3) * (self.ol_h2o[idx_node]/(1e4))) / 153.3 #Conversion from Jones (2016)

			if (MATE.type[0][MATE.ol_cond_selection] == '5'):

				D_GB_ol = (10.0**self.D_ol_GB[MATE.GB_ol_select]) * np.exp(-self.E_ol_GB[MATE.GB_ol_select] / (self.R*self.T[idx_node]))
				if method == 'array':
					D_GB_ol_max = (10.0**self.D_ol_GB[MATE.GB_ol_select]) * np.exp(-(self.E_ol_GB[MATE.GB_ol_select]-self.E_err_ol_GB[MATE.GB_ol_select]) / (self.R*self.T[idx_node]))
					D_GB_ol_min = (10.0**self.D_ol_GB[MATE.GB_ol_select]) * np.exp(-(self.E_ol_GB[MATE.GB_ol_select]+self.E_err_ol_GB[MATE.GB_ol_select]) / (self.R*self.T[idx_node]))

			if ('*' in MATE.name[0][MATE.ol_cond_selection]) == True:

				if (MATE.type[0][MATE.ol_cond_selection] == '4'):

					ol_wet_diff_function = MATE.name[0][MATE.ol_cond_selection].replace('*','')

				elif (MATE.type[0][MATE.ol_cond_selection] == '5'):

					ol_wet_diff_function = MATE.name[0][MATE.ol_cond_selection].replace('*','')[MATE.name[0][MATE.ol_cond_selection].rfind('+')+1:]

			else:
				if (MATE.type[0][MATE.ol_cond_selection] == '4'):
					ol_wet_diff_function = MATE.name[0][MATE.ol_cond_selection]
				elif (MATE.type[0][MATE.ol_cond_selection] == '5'):
					ol_wet_diff_function = MATE.name[0][MATE.ol_cond_selection][MATE.name[0][MATE.ol_cond_selection].rfind('+')+1:]

			if (MATE.type[0][MATE.ol_cond_selection] == '4'):
				DH_max,DH_min,DH = eval(ol_wet_diff_function + '(T = self.T[idx_node],ol_h2o = ((self.ol_h2o[idx_node])/self.correction_factor_ol),method = method)')
			elif (MATE.type[0][MATE.ol_cond_selection] == '5'):
				DH_max,DH_min,DH = eval(ol_wet_diff_function + '(T = self.T[idx_node],ol_h2o = ((self.ol_h2o[idx_node]*(1-MATE.D_gb))/self.correction_factor_ol),method = method)')
			#Dry conductivity + Nernst-Einstein equation
			if (MATE.type[0][MATE.ol_cond_selection] == '4'):

				self.ol_cond[idx_node] = self.conductivity_dry(0,MATE.ol_dry_selection,method,sol_idx)[2] +\
				((DH * (h2o_h_ol/self.correction_factor_ol) * (self.el_q**2.0)) / (self.boltz*self.T[idx_node]))
				if method == 'array':
					self.ol_cond_max[idx_node] = self.conductivity_dry(0,MATE.ol_dry_selection,method,sol_idx)[0] +\
					((DH_max * (h2o_h_ol/self.correction_factor_ol) * (self.el_q**2.0)) / (self.boltz*self.T[idx_node]))
					self.ol_cond_min[idx_node] = self.conductivity_dry(0,MATE.ol_dry_selection,method,sol_idx)[1] +\
					((DH_min * (h2o_h_ol/self.correction_factor_ol)  * (self.el_q**2.0)) / (self.boltz*self.T[idx_node]))
				else:
					self.ol_cond_max[idx_node] = self.ol_cond[idx_node]
					self.ol_cond_min[idx_node] = self.ol_cond[idx_node]

			elif (MATE.type[0][MATE.ol_cond_selection] == '5'):
				if MATE.ol_calib != 3:
					self.FTIR_correction(min_idx = 0,sol_calc = 2)
				else:
					self.correction_factor_GB = 1.0
					self.correction_factor_ol = 1.0
				self.ol_cond[idx_node] = self.conductivity_dry(0,MATE.ol_dry_selection,method,sol_idx)[2] +\
				(((DH/self.correction_factor_ol) + (MATE.D_gb * (1.0/self.correction_factor_GB) * (3*self.delta/self.ol_gs[idx_node]) * D_GB_ol)) * h2o_h_ol * (self.el_q**2.0)) / (self.boltz*self.T[idx_node])
				if method == 'array':
					self.ol_cond_max[idx_node] = self.conductivity_dry(0,MATE.ol_dry_selection,method,sol_idx)[0] +\
					(((DH_max/self.correction_factor_ol) + (MATE.D_gb * (1.0/self.correction_factor_GB) * (3*self.delta/self.ol_gs[idx_node]) * D_GB_ol_max)) * h2o_h_ol * (self.el_q**2.0)) / (self.boltz*self.T[idx_node])
					self.ol_cond_min[idx_node] = self.conductivity_dry(0,MATE.ol_dry_selection,method,sol_idx)[1] +\
					 (((DH_min/self.correction_factor_ol) + (MATE.D_gb * (1.0/self.correction_factor_GB) * (3*self.delta/self.ol_gs[idx_node]) * D_GB_ol_min)) * h2o_h_ol * (self.el_q**2.0)) / (self.boltz*self.T[idx_node])
				else:
					self.ol_cond_max[idx_node] = self.ol_cond[idx_node]
					self.ol_cond_min[idx_node] = self.ol_cond[idx_node]

	def calculate_opx_conductivity(self,method,sol_idx = None):

		if MATE.px_calib != 2:
			self.FTIR_correction(min_idx = 1,sol_calc = 1)
		else:
			self.correction_factor_pxgt = 1.0

		if method == 'array':
			idx_node = None
		elif method == 'index':
			idx_node = sol_idx

		if MATE.px_cond_method == 1:

			#Creating an index entry for opx calculations, given with minus version of indexes
			if MATE.opx_cond_selection == -999:
				MATE.opx_cond_selection = 0
			else:
				MATE.opx_cond_selection == MATE.cpx_cond_selection * -1

		def oriented_cond_opx(idx):

			#local function for calculating isotropic conductivities from anisotropic ones w/ geo. averaging.
			opx_cond_max_array = []
			opx_cond_min_array = []
			opx_cond_array = []

			if MATE.type[1][idx] == '10':

				for i in range(0,3):

					self.opx_cond_dum = self.conductivity_dry(1,self.opx_dry_selection,method,sol_idx)[2] + self.conductivity_proton(2,1,idx+i,method,sol_idx)
					opx_cond_array.append(self.opx_cond_dum)

					if method == 'array':
						self.opx_cond_max_dum = self.conductivity_dry(1,self.opx_dry_selection,method,sol_idx)[0] + self.conductivity_proton(0,1,idx+i,method,sol_idx)
						self.opx_cond_min_dum = self.conductivity_dry(1,self.opx_dry_selection,method,sol_idx)[1] + self.conductivity_proton(1,1,idx+i,method,sol_idx)

						opx_cond_max_array.append(self.opx_cond_max_dum)
						opx_cond_min_array.append(self.opx_cond_min_dum)

				self.opx_cond[idx_node] = (opx_cond_array[0] * opx_cond_array[1] * opx_cond_array[2])**(1.0/3.0)
				if method == 'array':
					self.opx_cond_max[idx_node] = (opx_cond_max_array[0] * opx_cond_max_array[1] * opx_cond_max_array[2])**(1.0/3.0)
					self.opx_cond_min[idx_node] = (opx_cond_min_array[0] * opx_cond_min_array[1] * opx_cond_min_array[2])**(1.0/3.0)
				else:
					self.opx_cond_max[idx_node] = self.opx_cond[idx_node]
					self.opx_cond_min[idx_node] = self.opx_cond[idx_node]

			elif MATE.type[1][idx] == '20':

				opx_cond_max_dry_array = []
				opx_cond_min_dry_array = []
				opx_cond_dry_array = []

				for i in range(0,3):

					self.opx_cond_dum = self.conductivity_proton(2,1,idx+i,method,sol_idx)
					self.opx_cond_dum_pol = self.conductivity_polaron(2,1,idx+i,method,sol_idx)
					opx_cond_array.append(self.opx_cond_dum)
					opx_cond_dry_array.append(self.opx_cond_dum_pol)

					if method == 'array':
						self.opx_cond_max_dum = self.conductivity_proton(0,1,idx+i,method,sol_idx)
						self.opx_cond_min_dum = self.conductivity_proton(1,1,idx+i,method,sol_idx)

						self.opx_cond_max_dum_pol = self.conductivity_polaron(0,1,idx+i,method,sol_idx)
						self.opx_cond_min_dum_pol = self.conductivity_polaron(1,1,idx+i,method,sol_idx)

						opx_cond_max_array.append(self.opx_cond_max_dum)
						opx_cond_min_array.append(self.opx_cond_min_dum)
						opx_cond_max_dry_array.append(self.opx_cond_max_dum_pol)
						opx_cond_min_dry_array.append(self.opx_cond_min_dum_pol)


				self.opx_cond[idx_node] = (opx_cond_dry_array[0] * opx_cond_dry_array[1] * opx_cond_dry_array[2])**(1.0/3.0) +\
				(opx_cond_array[0] * opx_cond_array[1] * opx_cond_array[2])**(1.0/3.0)

				if method == 'array':
					self.opx_cond_max[idx_node] = (opx_cond_max_dry_array[0] * opx_cond_max_dry_array[1] * opx_cond_max_dry_array[2])**(1.0/3.0) +\
					(opx_cond_max_array[0] * opx_cond_max_array[1] * opx_cond_max_array[2])**(1.0/3.0)
					self.opx_cond_min[idx_node] = (opx_cond_min_dry_array[0] * opx_cond_min_dry_array[1] * opx_cond_min_dry_array[2])**(1.0/3.0) +\
					(opx_cond_min_array[0] * opx_cond_min_array[1] * opx_cond_min_array[2])**(1.0/3.0)
				else:
					self.opx_cond_max[idx_node] = self.opx_cond[idx_node]
					self.opx_cond_min[idx_node] = self.opx_cond[idx_node]

			return self.opx_cond_max, self.opx_cond_min, self.opx_cond


		if MATE.opx_cond_selection >= 0:

			if MATE.type[1][MATE.opx_cond_selection] == '0':

				self.opx_cond[idx_node] = self.conductivity_ionic(2,1,MATE.opx_cond_selection,method,sol_idx) + self.conductivity_polaron(2,1,MATE.opx_cond_selection,method,sol_idx) +\
				self.conductivity_proton(2,1,MATE.opx_cond_selection,method,sol_idx)

				if method == 'array':
					self.opx_cond_max[idx_node] = self.conductivity_ionic(0,1,MATE.opx_cond_selection,method,sol_idx) + self.conductivity_polaron(0,1,MATE.opx_cond_selection,method,sol_idx) +\
					self.conductivity_proton(0,1,MATE.opx_cond_selection,method,sol_idx)

					self.opx_cond_min[idx_node] = self.conductivity_ionic(1,1,MATE.opx_cond_selection,method,sol_idx) + self.conductivity_polaron(1,1,MATE.opx_cond_selection,method,sol_idx) +\
					self.conductivity_proton(1,1,MATE.opx_cond_selection,method,sol_idx)
				else:
					self.opx_cond_max[idx_node] = self.opx_cond[idx_node]
					self.opx_cond_min[idx_node] = self.opx_cond[idx_node]

			elif MATE.type[1][MATE.opx_cond_selection] == '1':


				self.opx_cond[idx_node] = self.conductivity_dry(1,MATE.opx_dry_selection,method,sol_idx)[2] + self.conductivity_proton(2,1,MATE.opx_cond_selection,method,sol_idx)

				if method == 'array':
					self.opx_cond_max[idx_node] = self.conductivity_dry(1,MATE.opx_dry_selection,method,sol_idx)[0] + self.conductivity_proton(0,1,MATE.opx_cond_selection,method,sol_idx)
					self.opx_cond_min[idx_node] = self.conductivity_dry(1,MATE.opx_dry_selection,method,sol_idx)[1] + self.conductivity_proton(1,1,MATE.opx_cond_selection,method,sol_idx)
				else:
					self.opx_cond_max[idx_node] = self.opx_cond[idx_node]
					self.opx_cond_min[idx_node] = self.opx_cond[idx_node]

			elif (MATE.type[1][MATE.opx_cond_selection] == '11') or (MATE.type[1][MATE.opx_cond_selection] == '21'):

				self.opx_cond_max[idx_node],self.opx_cond_min[idx_node],self.opx_cond[idx_node] = oriented_cond_opx(idx = MATE.opx_cond_selection - 1)

			elif (MATE.type[1][MATE.opx_cond_selection] == '12') or (MATE.type[1][MATE.opx_cond_selection] == '22'):

				self.opx_cond_max[idx_node],self.opx_cond_min[idx_node],self.opx_cond[idx_node] = oriented_cond_opx(idx = MATE.opx_cond_selection - 2)

			elif (MATE.type[1][MATE.opx_cond_selection] == '10') or (MATE.type[1][MATE.opx_cond_selection] == '20'):

				self.opx_cond_max[idx_node],self.opx_cond_min[idx_node],self.opx_cond[idx_node] = oriented_cond_opx(idx = MATE.opx_cond_selection)

			elif MATE.type[1][MATE.opx_cond_selection] == '3':

				if ('*' in MATE.name[1][MATE.opx_cond_selection]) == True:

					opx_wet_odd_function = MATE.name[1][MATE.opx_cond_selection].replace('*','')

				else:

					opx_wet_odd_function = MATE.name[1][MATE.opx_cond_selection]

				cond_opx_max,cond_opx_min,cond_opx = eval(opx_wet_odd_function + '(model_method = MATE.model_method[1],T = self.T[idx_node],P = self.p[idx_node],corr_factor = self.correction_factor_pxgt,fo2 = self.calculate_fugacity(MATE.o2_buffer)[idx_node],fo2_ref = self.calculate_fugacity(3)[idx_node],wt_err = self.FTIR_calibration_error(1,self.w_calib[1][MATE.opx_cond_selection]),opx_h2o = self.opx_h2o[idx_node],method = method)')

				if MATE.model_method[1] == 0:

					self.opx_cond[idx_node] = cond_opx

					if method == 'array':
						self.opx_cond_max[idx_node] = cond_opx_max
						self.opx_cond_min[idx_node] = cond_opx_min
					else:
						self.opx_cond_max[idx_node] = cond_opx
						self.opx_cond_min[idx_node] = cond_opx


				elif MATE.model_method[1] == 1:

					self.opx_cond[idx_node] = self.conductivity_dry(1,MATE.opx_dry_selection,method,sol_idx)[2] + cond_opx
					if method == 'array':
						self.opx_cond_max[idx_node] = self.conductivity_dry(1,MATE.opx_dry_selection,method,sol_idx)[0] + cond_opx_max
						self.opx_cond_min[idx_node] = self.conductivity_dry(1,MATE.opx_dry_selection,method,sol_idx)[1] + cond_opx_min
					else:
						self.opx_cond_max[idx_node] = self.opx_cond[idx_node]
						self.opx_cond_min[idx_node] = self.opx_cond[idx_node]


			elif (MATE.type[0][MATE.opx_cond_selection] == '4'):

				h2o_h_opx = (self.avog * (self.rho_opx[idx_node]*1e3) * (self.opx_h2o[idx_node]/(1e4*self.correction_factor_pxgt))) / 200.78 #Conversion from Jones (2016)

				if ('*' in MATE.name[1][MATE.opx_cond_selection]) == True:

					opx_wet_diff_function = MATE.name[1][MATE.opx_cond_selection].replace('*','')

				else:

					opx_wet_diff_function = MATE.name[1][MATE.opx_cond_selection]

				DH_max,DH_min,DH = eval(opx_wet_diff_function + '(T = self.T[idx_node],opx_h2o = self.opx_h2o[idx_node],method = method)')

				#Dry conductivity + Nernst-Einstein equation
				self.opx_cond[idx_node] = self.conductivity_dry(1,MATE.opx_dry_selection)[2] +\
				((DH * h2o_h_opx * (self.el_q**2.0)) / (self.boltz*self.T[idx_node]))

				if method == 'array':
					self.opx_cond_max[idx_node] = self.conductivity_dry(1,MATE.opx_dry_selection)[0] +\
					((DH_max * h2o_h_opx * (self.el_q**2.0)) / (self.boltz*self.T[idx_node]))
					self.opx_cond_min[idx_node] = self.conductivity_dry(1,MATE.opx_dry_selection)[1] +\
					((DH_min * h2o_h_opx * (self.el_q**2.0)) / (self.boltz*self.T[idx_node]))
				else:
					self.opx_cond_max[idx_node] = self.opx_cond[idx_node]
					self.opx_cond_min[idx_node] = self.opx_cond[idx_node]

		if MATE.px_cond_method == 1:

			self.cpx_cond_max[idx_node] = self.opx_cond_max
			self.cpx_cond_min[idx_node] = self.opx_cond_min
			self.cpx_cond[idx_node] = self.opx_cond

	def calculate_cpx_conductivity(self,method,sol_idx = None):

		if MATE.px_calib != 2:
			self.FTIR_correction(min_idx = 2,sol_calc = 1)
		else:
			self.correction_factor_pxgt = 1.0

		if method == 'array':
			idx_node = None
		elif method == 'index':
			idx_node = sol_idx

		if MATE.px_cond_method == 1:

			if MATE.cpx_cond_selection == -999:
				MATE.cpx_cond_selection = 0 #I'm so sorry about this but I was already in too deep to correct a better method to
				#handle this. Anyways, it works.
			#Creating an index entry for opx calculations, given with minus version of indexes
			else:
				MATE.cpx_cond_selection == MATE.opx_cond_selection * -1


		def oriented_cond_cpx(idx = None):

			cpx_cond_max_array = []
			cpx_cond_min_array = []
			cpx_cond_array = []

			if MATE.type[2][idx] == '10':

				for i in range(0,3):
					self.cpx_cond_dum = self.conductivity_dry(2,self.cpx_dry_selection,method,sol_idx)[2] + self.conductivity_proton(2,2,idx+i,method,sol_idx)
					cpx_cond_array.append(self.cpx_cond_dum)

					if method == 'array':
						self.cpx_cond_max_dum = self.conductivity_dry(2,self.cpx_dry_selection,method,sol_idx)[0] + self.conductivity_proton(0,2,idx+i,method,sol_idx)
						self.cpx_cond_min_dum = self.conductivity_dry(2,self.cpx_dry_selection,method,sol_idx)[1] + self.conductivity_proton(1,2,idx+i,method,sol_idx)
						cpx_cond_max_array.append(self.cpx_cond_max_dum)
						cpx_cond_min_array.append(self.cpx_cond_min_dum)

				self.cpx_cond[idx_node] = (cpx_cond_array[0] * cpx_cond_array[1] * cpx_cond_array[2])**(1.0/3.0)
				if method == 'array':
					self.cpx_cond_max[idx_node] = (cpx_cond_max_array[0] * cpx_cond_max_array[1] * cpx_cond_max_array[2])**(1.0/3.0)
					self.cpx_cond_min[idx_node] = (cpx_cond_min_array[0] * cpx_cond_min_array[1] * cpx_cond_min_array[2])**(1.0/3.0)
				else:
					self.cpx_cond_max[idx_node] = self.cpx_cond[idx_node]
					self.cpx_cond_min[idx_node] = self.cpx_cond[idx_node]

			elif MATE.type[2][idx] == '20':

				cpx_cond_max_dry_array = []
				cpx_cond_min_dry_array = []
				cpx_cond_dry_array = []

				for i in range(0,3):

					if method == 'array':
						self.cpx_cond_max_dum = self.conductivity_proton(0,2,idx+i,method,sol_idx)
						self.cpx_cond_min_dum = self.conductivity_proton(1,2,idx+i,method,sol_idx)
						self.cpx_cond_max_dum_pol = self.conductivity_polaron(0,2,idx+i,method,sol_idx)
						self.cpx_cond_min_dum_pol = self.conductivity_polaron(1,2,idx+i,method,sol_idx)
						cpx_cond_max_array.append(self.cpx_cond_max_dum)
						cpx_cond_min_array.append(self.cpx_cond_min_dum)
						cpx_cond_max_dry_array.append(self.cpx_cond_max_dum_pol)
						cpx_cond_min_dry_array.append(self.cpx_cond_min_dum_pol)

					self.cpx_cond_dum = self.conductivity_proton(2,2,idx+i,method,sol_idx)
					self.cpx_cond_dum_pol = self.conductivity_polaron(2,2,idx+i,method,sol_idx)
					cpx_cond_array.append(self.cpx_cond_dum)
					cpx_cond_dry_array.append(self.cpx_cond_dum_pol)

				self.cpx_cond[idx_node] = (cpx_cond_dry_array[0] * cpx_cond_dry_array[1] * cpx_cond_dry_array[2])**(1.0/3.0) +\
				(cpx_cond_array[0] * cpx_cond_array[1] * cpx_cond_array[2])**(1.0/3.0)

				if method == 'array':
					self.cpx_cond_max[idx_node] = (cpx_cond_max_dry_array[0] * cpx_cond_max_dry_array[1] * cpx_cond_max_dry_array[2])**(1.0/3.0) +\
					(cpx_cond_max_array[0] * cpx_cond_max_array[1] * cpx_cond_max_array[2])**(1.0/3.0)
					self.cpx_cond_min[idx_node] = (cpx_cond_min_dry_array[0] * cpx_cond_min_dry_array[1] * cpx_cond_min_dry_array[2])**(1.0/3.0) +\
					(cpx_cond_min_array[0] * cpx_cond_min_array[1] * cpx_cond_min_array[2])**(1.0/3.0)
				else:
					self.cpx_cond_max[idx_node] = self.cpx_cond[idx_node]
					self.cpx_cond_min[idx_node] = self.cpx_cond[idx_node]

			return self.cpx_cond_max, self.cpx_cond_min, self.cpx_cond

		if MATE.cpx_cond_selection >= 0:

			if MATE.type[2][MATE.cpx_cond_selection] == '0':

				self.cpx_cond[idx_node] = self.conductivity_ionic(2,2,MATE.cpx_cond_selection,method,sol_idx) + self.conductivity_polaron(2,2,MATE.cpx_cond_selection,method,sol_idx) +\
				self.conductivity_proton(2,2,MATE.cpx_cond_selection,method,sol_idx)

				if method == 'array':
					self.cpx_cond_max[idx_node] = self.conductivity_ionic(0,2,MATE.cpx_cond_selection,method,sol_idx) + self.conductivity_polaron(0,2,MATE.cpx_cond_selection,method,sol_idx) +\
					self.conductivity_proton(0,2,MATE.cpx_cond_selection,method,sol_idx)

					self.cpx_cond_min[idx_node] = self.conductivity_ionic(1,2,MATE.cpx_cond_selection,method,sol_idx) + self.conductivity_polaron(1,2,MATE.cpx_cond_selection,method,sol_idx) +\
					self.conductivity_proton(1,2,MATE.cpx_cond_selection,method,sol_idx)
				else:
					self.cpx_cond_max[idx_node] = self.cpx_cond[idx_node]
					self.cpx_cond_min[idx_node] = self.cpx_cond[idx_node]


			elif MATE.type[2][MATE.cpx_cond_selection] == '1':

				self.cpx_cond[idx_node] = self.conductivity_dry(2,MATE.cpx_dry_selection,method,sol_idx)[2] + self.conductivity_proton(2,2,MATE.cpx_cond_selection,method,sol_idx)
				if method == 'array':
					self.cpx_cond_max[idx_node] = self.conductivity_dry(2,MATE.cpx_dry_selection,method,sol_idx)[0] + self.conductivity_proton(0,2,MATE.cpx_cond_selection,method,sol_idx)
					self.cpx_cond_min[idx_node] = self.conductivity_dry(2,MATE.cpx_dry_selection,method,sol_idx)[1] + self.conductivity_proton(1,2,MATE.cpx_cond_selection,method,sol_idx)
				else:
					self.cpx_cond_max[idx_node] = self.cpx_cond[idx_node]
					self.cpx_cond_min[idx_node] = self.cpx_cond[idx_node]

			elif (MATE.type[2][MATE.cpx_cond_selection] == '11') or (MATE.type[2][MATE.cpx_cond_selection] == '21'):

				self.cpx_cond_max[idx_node],self.cpx_cond_min[idx_node],self.cpx_cond[idx_node] = oriented_cond_cpx(idx = MATE.cpx_cond_selection - 1)

			elif (MATE.type[2][MATE.cpx_cond_selection] == '12') or (MATE.type[2][MATE.cpx_cond_selection] == '22'):

				self.cpx_cond_max[idx_node],self.cpx_cond_min[idx_node],self.cpx_cond[idx_node] = oriented_cond_cpx(idx = MATE.cpx_cond_selection - 2)

			elif (MATE.type[2][MATE.cpx_cond_selection] == '10') or (MATE.type[2][MATE.cpx_cond_selection] == '20'):

				self.cpx_cond_max[idx_node],self.cpx_cond_min[idx_node],self.cpx_cond[idx_node] = oriented_cond_cpx(idx = MATE.cpx_cond_selection)

			elif MATE.type[2][MATE.cpx_cond_selection] == '3':

				if ('*' in MATE.name[2][MATE.cpx_cond_selection]) == True:

					cpx_wet_odd_function = MATE.name[2][MATE.cpx_cond_selection].replace('*','')

				else:

					cpx_wet_odd_function = MATE.name[2][MATE.cpx_cond_selection]

				cond_cpx_max,cond_cpx_min,cond_cpx,cond_dry,cond_wet = eval(cpx_wet_odd_function + '(model_method = MATE.model_method[2],T = self.T[idx_node],P = self.p[idx_node],corr_factor = self.correction_factor_pxgt,fo2 = self.calculate_fugacity(MATE.o2_buffer)[idx_node],fo2_ref = self.calculate_fugacity(3)[idx_node],wt_err = self.FTIR_calibration_error(2,self.w_calib[2][MATE.cpx_cond_selection]),cpx_h2o = self.cpx_h2o[idx_node],cpx_fe = self.fe_cpx[idx_node],method = method)')

				if MATE.model_method[2] == 0:

					self.cpx_cond[idx_node] = cond_cpx
					if method == 'array':
						self.cpx_cond_max[idx_node] = cond_cpx_max
						self.cpx_cond_min[idx_node] = cond_cpx_min
					else:
						self.cpx_cond_max[idx_node] = self.cpx_cond[idx_node]
						self.cpx_cond_min[idx_node] = self.cpx_cond[idx_node]

				elif MATE.model_method[2] == 1:

					self.cpx_cond[idx_node] = self.conductivity_dry(2,MATE.cpx_dry_selection,method,sol_idx)[2] + cond_cpx

					if method == 'array':
						self.cpx_cond_max[idx_node] = self.conductivity_dry(2,MATE.cpx_dry_selection,method,sol_idx)[0] + cond_cpx_max
						self.cpx_cond_min[idx_node] = self.conductivity_dry(2,MATE.cpx_dry_selection,method,sol_idx)[1] + cond_cpx_min


			elif MATE.type[2][MATE.cpx_cond_selection] == '4':

				h2o_h_cpx = (self.avog * (self.rho_cpx[idx_node]*1e3) * (self.cpx_h2o[idx_node]/(1e4*self.correction_factor_pxgt))) / 216.55 #Conversion from Jones (2016)

				if ('*' in MATE.name[2][MATE.cpx_cond_selection]) == True:

					cpx_wet_diff_function = MATE.name[2][MATE.cpx_cond_selection].replace('*','')

				else:

					cpx_wet_diff_function = MATE.name[2][MATE.cpx_cond_selection]

				DH_max,DH_min,DH = eval(cpx_wet_diff_function + '(T = self.T[idx_node],cpx_h2o = self.cpx_h2o[idx_node],method = method)')

				#Dry conductivity + Nernst-Einstein equation
				self.cpx_cond[idx_node] = self.conductivity_dry(2,MATE.cpx_dry_selection,method,sol_idx)[2] +\
				((DH * h2o_h_cpx * (self.el_q**2.0)) / (self.boltz*self.T[idx_node]))
				if method == 'array':
					self.cpx_cond_max[idx_node] = self.conductivity_dry(2,MATE.cpx_dry_selection,method,sol_idx)[0] +\
					((DH_max * h2o_h_cpx * (self.el_q**2.0)) / (self.boltz*self.T[idx_node]))
					self.cpx_cond_min[idx_node] = self.conductivity_dry(2,MATE.cpx_dry_selection,method,sol_idx)[1] +\
					((DH_min * h2o_h_cpx * (self.el_q**2.0)) / (self.boltz*self.T[idx_node]))
				else:
					self.cpx_cond_max[idx_node] = self.cpx_cond[idx_node]
					self.cpx_cond_min[idx_node] = self.cpx_cond[idx_node]

		if MATE.px_cond_method == 1:

			self.opx_cond_max[idx_node] = self.cpx_cond_max
			self.opx_cond_min[idx_node] = self.cpx_cond_min
			self.opx_cond[idx_node] = self.cpx_cond


	def calculate_gt_conductivity(self,method,sol_idx = None):

		if MATE.px_calib != 2:
			self.FTIR_correction(min_idx = 3,sol_calc = 1)
		else:
			self.correction_factor_pxgt = 1.0

		if method == 'array':
			idx_node = None
		elif method == 'index':
			idx_node = sol_idx

		def oriented_cond_gt(idx = None):

			gt_cond_max_array = []
			gt_cond_min_array = []
			gt_cond_array = []

			if MATE.type[3][idx] == '10':

				for i in range(0,3):

					self.gt_cond_dum = self.conductivity_dry(3,self.gt_dry_selection,method,sol_idx)[2] + self.conductivity_proton(2,3,idx+i,method,sol_idx)
					gt_cond_array.append(self.gt_cond_dum)

					if method == 'array':
						self.gt_cond_max_dum = self.conductivity_dry(3,self.gt_dry_selection,method,sol_idx)[0] + self.conductivity_proton(0,3,idx+i,method,sol_idx)
						self.gt_cond_min_dum = self.conductivity_dry(3,self.gt_dry_selection,method,sol_idx)[1] + self.conductivity_proton(1,3,idx+i,method,sol_idx)
						gt_cond_max_array.append(self.gt_cond_max_dum)
						gt_cond_min_array.append(self.gt_cond_min_dum)

				self.gt_cond[idx_node] = (gt_cond_array[0] * gt_cond_array[1] * gt_cond_array[2])**(1.0/3.0)
				if method == 'array':
					self.gt_cond_max[idx_node] = (gt_cond_max_array[0] * gt_cond_max_array[1] * gt_cond_max_array[2])**(1.0/3.0)
					self.gt_cond_min[idx_node] = (gt_cond_min_array[0] * gt_cond_min_array[1] * gt_cond_min_array[2])**(1.0/3.0)
				else:
					self.gt_cond_max[idx_node] = self.gt_cond[idx_node]
					self.gt_cond_min[idx_node] = self.gt_cond[idx_node]

			elif MATE.type[3][idx] == '20':

				gt_cond_max_dry_array = []
				gt_cond_min_dry_array = []
				gt_cond_dry_array = []

				for i in range(0,3):
					self.gt_cond_dum = self.conductivity_proton(2,3,idx+i,method,sol_idx)
					self.gt_cond_dum_pol = self.conductivity_polaron(2,3,idx+i,method,sol_idx)
					gt_cond_array.append(self.gt_cond_dum)
					gt_cond_dry_array.append(self.gt_cond_dum_pol)

					if method == 'array':
						self.gt_cond_max_dum = self.conductivity_proton(0,3,idx+i,method,sol_idx)
						self.gt_cond_min_dum = self.conductivity_proton(1,3,idx+i,method,sol_idx)

						self.gt_cond_max_dum_pol = self.conductivity_polaron(0,3,idx+i,method,sol_idx)
						self.gt_cond_min_dum_pol = self.conductivity_polaron(1,3,idx+i,method,sol_idx)

						gt_cond_max_array.append(self.gt_cond_max_dum)
						gt_cond_min_array.append(self.gt_cond_min_dum)
						gt_cond_max_dry_array.append(self.gt_cond_max_dum_pol)
						gt_cond_min_dry_array.append(self.gt_cond_min_dum_pol)

				self.gt_cond[idx_node] = (gt_cond_dry_array[0] * gt_cond_dry_array[1] * gt_cond_dry_array[2])**(1.0/3.0) +\
				(gt_cond_array[0] * gt_cond_array[1] * gt_cond_array[2])**(1.0/3.0)
				if method == 'array':
					self.gt_cond_max[idx_node] = (gt_cond_max_dry_array[0] * gt_cond_max_dry_array[1] * gt_cond_max_dry_array[2])**(1.0/3.0) +\
					(gt_cond_max_array[0] * gt_cond_max_array[1] * gt_cond_max_array[2])**(1.0/3.0)
					self.gt_cond_min[idx_node] = (gt_cond_min_dry_array[0] * gt_cond_min_dry_array[1] * gt_cond_min_dry_array[2])**(1.0/3.0) +\
					(gt_cond_min_array[0] * gt_cond_min_array[1] * gt_cond_min_array[2])**(1.0/3.0)
				else:
					self.gt_cond_max[idx_node] = self.gt_cond[idx_node]
					self.gt_cond_min[idx_node] = self.gt_cond[idx_node]

			return self.gt_cond_max,self.gt_cond_min,self.gt_cond

		if MATE.type[3][MATE.gt_cond_selection] == '0':

			self.gt_cond[idx_node] = self.conductivity_ionic(2,3,MATE.gt_cond_selection,method,sol_idx) + self.conductivity_polaron(2,3,MATE.gt_cond_selection,method,sol_idx) +\
			self.conductivity_proton(2,3,MATE.gt_cond_selection,method,sol_idx)

			if method == 'array':
				self.gt_cond_max[idx_node] = self.conductivity_ionic(0,3,MATE.gt_cond_selection,method,sol_idx) + self.conductivity_polaron(0,3,MATE.gt_cond_selection,method,sol_idx) +\
				self.conductivity_proton(0,3,MATE.gt_cond_selection,method,sol_idx)

				self.gt_cond_min[idx_node] = self.conductivity_ionic(1,3,MATE.gt_cond_selection,method,sol_idx) + self.conductivity_polaron(1,3,MATE.gt_cond_selection,method,sol_idx) +\
				self.conductivity_proton(1,3,MATE.gt_cond_selection,method,sol_idx)

			else:
				self.gt_cond_max[idx_node] = self.gt_cond[idx_node]
				self.gt_cond_min[idx_node] = self.gt_cond[idx_node]

		elif MATE.type[3][MATE.gt_cond_selection] == '1':

			self.gt_cond[idx_node] = self.conductivity_dry(3,MATE.gt_dry_selection,method,sol_idx)[2] + self.conductivity_proton(2,3,MATE.gt_cond_selection,method,sol_idx)
			if method == 'array':
				self.gt_cond_max[idx_node] = self.conductivity_dry(3,MATE.gt_dry_selection,method,sol_idx)[0] + self.conductivity_proton(0,3,MATE.gt_cond_selection,method,sol_idx)
				self.gt_cond_min[idx_node] = self.conductivity_dry(3,MATE.gt_dry_selection,method,sol_idx)[1] + self.conductivity_proton(1,3,MATE.gt_cond_selection,method,sol_idx)
			else:
				self.gt_cond_max[idx_node] = self.gt_cond[idx_node]
				self.gt_cond_min[idx_node] = self.gt_cond[idx_node]

		elif (MATE.type[3][MATE.gt_cond_selection] == '11') or (MATE.type[3][MATE.gt_cond_selection] == '21'):

			self.gt_cond_max[idx_node],self.gt_cond_min[idx_node],self.gt_cond[idx_node] =  oriented_cond_gt(idx = MATE.gt_cond_selection - 1)

		elif (MATE.type[3][MATE.gt_cond_selection] == '12') or (MATE.type[3][MATE.gt_cond_selection] == '22'):

			self.gt_cond_max[idx_node],self.gt_cond_min[idx_node],self.gt_cond[idx_node] =  oriented_cond_gt(idx = MATE.gt_cond_selection - 2)

		elif (MATE.type[3][MATE.gt_cond_selection] == '10') or (MATE.type[3][MATE.gt_cond_selection] == '20'):

			self.gt_cond_max[idx_node],self.gt_cond_min[idx_node],self.gt_cond[idx_node] =  oriented_cond_gt(idx = MATE.gt_cond_selection)

		elif MATE.type[3][MATE.gt_cond_selection] == '3':

			if ('*' in MATE.name[3][MATE.gt_cond_selection]) == True:

				gt_wet_odd_function = MATE.name[3][MATE.gt_cond_selection].replace('*','')

			else:

				gt_wet_odd_function = MATE.name[3][MATE.gt_cond_selection]

			cond_gt_max,cond_gt_min,cond_gt,cond_dry,cond_wet = eval(gt_wet_odd_function + '(model_method = MATE.model_method[3],T = self.T[idx_node],P = self.p[idx_node],corr_factor = self.correction_factor_pxgt,fo2 = self.calculate_fugacity(MATE.o2_buffer)[idx_node],fo2_ref = self.calculate_fugacity(3)[idx_node],wt_err = self.FTIR_calibration_error(3,self.w_calib[3][MATE.gt_cond_selection]),gt_h2o = self.gt_h2o[idx_node],method = method)')

			if MATE.model_method[3] == 0:

				self.gt_cond[idx_node] = cond_gt

				if method == 'array':
					self.gt_cond_max[idx_node] = cond_gt_max
					self.gt_cond_min[idx_node] = cond_gt_min
				else:
					self.gt_cond_max[idx_node] = self.gt_cond[idx_node]
					self.gt_cond_min[idx_node] = self.gt_cond[idx_node]

			elif MATE.model_method[3] == 1:

				self.gt_cond[idx_node] = self.conductivity_dry(3,MATE.gt_dry_selection,method,sol_idx)[2] + cond_gt
				if method == 'array':
					self.gt_cond_max[idx_node] = self.conductivity_dry(3,MATE.gt_dry_selection,method,sol_idx)[0] + cond_gt_max
					self.gt_cond_min[idx_node] = self.conductivity_dry(3,MATE.gt_dry_selection,method,sol_idx)[1] + cond_gt_min
				else:
					self.gt_cond_max[idx_node] = self.gt_cond[idx_node]
					self.gt_cond_min[idx_node] = self.gt_cond[idx_node]


		elif (MATE.type[3][MATE.gt_cond_selection] == '4'):

			h2o_h_gt = (self.avog * (self.rho_gt[idx_node]*1e3) * (self.gt_h2o[idx_node]/(1e4*self.correction_factor_pxgt))) / 425.0 #Conversion from Jones (2016)

			if ('*' in MATE.name[3][MATE.gt_cond_selection]) == True:

				if MATE.type[3][MATE.gt_cond_selection] == '4':

					gt_wet_diff_function = MATE.name[3][MATE.gt_cond_selection].replace('*','')

			else:

				gt_wet_diff_function = MATE.name[3][MATE.gt_cond_selection]

			DH_max,DH_min,DH = eval(gt_wet_diff_function + '(T = self.T[idx_node],gt_h2o = self.gt_h2o[idx_node],method = method)')

			#Dry conductivity + Nernst-Einstein equation

			if (MATE.type[3][MATE.gt_cond_selection] == '4'):
				self.gt_cond[idx_node] = self.conductivity_dry(3,MATE.gt_dry_selection,method,sol_idx)[2] +\
				((DH * h2o_h_gt * (self.el_q**2.0)) / (self.boltz*self.T[idx_node]))
				if method == 'array':
					self.gt_cond_max[idx_node] = self.conductivity_dry(3,MATE.gt_dry_selection,method,sol_idx)[0] +\
					((DH_max * h2o_h_gt * (self.el_q**2.0)) / (self.boltz*self.T[idx_node]))
					self.gt_cond_min[idx_node] = self.conductivity_dry(3,MATE.gt_dry_selection,method,sol_idx)[1] +\
					((DH_min * h2o_h_gt * (self.el_q**2.0)) / (self.boltz*self.T[idx_node]))
				else:
					self.gt_cond_max[idx_node] = self.gt_cond[idx_node]
					self.gt_cond_min[idx_node] = self.gt_cond[idx_node]

	def calculate_amp_conductivity(self,method,sol_idx):

		if method == 'array':
			idx_node = None
		elif method == 'index':
			idx_node = sol_idx

		if MATE.type[4][MATE.amp_cond_selection] == '3':

			if ('*' in MATE.name[4][MATE.amp_cond_selection]) == True:

				amp_odd_function = MATE.name[4][MATE.amp_cond_selection].replace('*','')

			else:

				amp_odd_function = MATE.name[4][MATE.amp_cond_selection]

			cond_amp_max,cond_amp_min,cond_amp = eval(amp_odd_function + '(T = self.T[idx_node],method = method)')

			self.amp_cond[idx_node] = cond_amp
			if method == 'array':
				self.amp_cond_max[idx_node] = cond_amp_max
				self.amp_cond_min[idx_node] = cond_amp_min
			else:
				self.amp_cond_max[idx_node] = self.amp_cond[idx_node]
				self.amp_cond_min[idx_node] = self.amp_cond[idx_node]

	def calculate_pl_conductivity(self,method,sol_idx):

		#Conductivity of phlogopite from Li et al. (2017, Geochimica et Cosmochimica Acta)
		#It is a function of fluorine content in Phlogopite. So one has to determine a reasonable constrain of fluorine content.

		if method == 'array':
			idx_node = None
		elif method == 'index':
			idx_node = sol_idx

		if MATE.type[5][MATE.pl_cond_selection] == '3':

			if ('*' in MATE.name[5][MATE.pl_cond_selection]) == True:

				pl_odd_function = MATE.name[5][MATE.pl_cond_selection].replace('*','')

			else:

				pl_odd_function = MATE.name[5][MATE.pl_cond_selection]

			cond_pl_max,cond_pl_min,cond_pl = eval(pl_odd_function + '(T = self.T[idx_node],flu = self.flu[idx_node],method = method)')

			self.pl_cond[idx_node] = cond_pl
			if method == 'array':
				self.pl_cond_max[idx_node] = cond_pl_max
				self.pl_cond_min[idx_node] = cond_pl_min
			else:
				self.pl_cond_max[idx_node] = self.pl_cond[idx_node]
				self.pl_cond_min[idx_node] = self.pl_cond[idx_node]

	def calculate_sp_chr_conductivity(self,method,sol_idx):

		#Conductivity of chromite taken from Sun et al. (2021).

		if method == 'array':
			idx_node = None
		elif method == 'index':
			idx_node = sol_idx

		if MATE.type[6][MATE.sp_chr_cond_selection] == '3':

			if ('*' in MATE.name[6][MATE.sp_chr_cond_selection]) == True:

				chr_odd_function = MATE.name[6][MATE.sp_chr_cond_selection].replace('*','')

			else:

				chr_odd_function = MATE.name[6][MATE.sp_chr_cond_selection]

			cond_chr_max,cond_chr_min,cond_chr = eval(chr_odd_function + '(T = self.T[idx_node],method = method)')

			self.sp_chr_cond[idx_node] = cond_chr
			if method == 'array':
				self.sp_chr_cond_max[idx_node] = cond_chr_max
				self.sp_chr_cond_min[idx_node] = cond_chr_min
			else:
				self.sp_chr_cond_max[idx_node] = self.sp_chr_cond[idx_node]
				self.sp_chr_cond_min[idx_node] = self.sp_chr_cond[idx_node]

	def calculate_melt_conductivity(self,method,sol_idx):

		if method == 'array':
			idx_node = None
		elif method == 'index':
			idx_node = sol_idx

		if MATE.type[7][MATE.melt_cond_selection] == '3':

			if ('*' in MATE.name[7][MATE.melt_cond_selection]) == True:

				melt_odd_function = MATE.name[7][MATE.melt_cond_selection].replace('*','')

			else:

				melt_odd_function = MATE.name[7][MATE.melt_cond_selection]

			cond_melt_max,cond_melt_min,cond_melt = eval(melt_odd_function + '(T = self.T[idx_node], P = self.p[idx_node], Melt_H2O = self.melt_h2o[idx_node], Melt_CO2 = self.co2[idx_node], Melt_Na2O = self.na2o_melt[idx_node], Melt_K2O = self.k2o_melt[idx_node],method = method)')

			self.melt_cond[idx_node] = cond_melt
			
			if method == 'array':
				self.melt_cond_max[idx_node] = cond_melt_max
				self.melt_cond_min[idx_node] = cond_melt_min
			else:
				self.melt_cond_max[idx_node] = self.melt_cond[idx_node]
				self.melt_cond_min[idx_node] = self.melt_cond[idx_node]

	def phase_mixing_function(self, method = None, melt_method = None, indexing_method = None, sol_idx = None):

		if indexing_method == 'array':
			idx_node = None
		elif indexing_method == 'index':
			idx_node = sol_idx

		if MATE.pl_method == '1':
			self.pl_m = np.ones(len(self.T))
			self.pl_cond_max = np.ones(len(self.T))
			self.pl_cond_min = np.ones(len(self.T))
			self.pl_cond = np.ones(len(self.T))
		else:
			for i in range(self.idx_moho,len(self.pl_frac)):
				if self.pl_frac[i] == 0.0:
					self.pl_m[i] = 1.0

		if MATE.amp_method == '1':
			self.amp_m = np.ones(len(self.T))
			self.amp_cond_max = np.ones(len(self.T))
			self.amp_cond_min = np.ones(len(self.T))
			self.amp_cond = np.ones(len(self.T))
		else:
			for i in range(self.idx_moho,len(self.amp_frac)):
				if self.amp_frac[i] == 0.0:
					self.amp_m[i] = 1.0

		if np.mean(self.sp_chr_frac[self.idx_moho:]) == 0.0:
			self.sp_chr_m = np.ones(len(self.T))
			self.sp_chr_cond = np.ones(len(self.T))
		else:
			for i in range(self.idx_moho,len(self.sp_chr_frac)):
				if self.sp_chr_frac[i] == 0.0:
					self.sp_chr_m[i] = 1.0

		if np.mean(self.cond_frac[self.idx_moho:]) == 0.0:
			self.cond_m = np.ones(len(self.T))
			self.cond_cond = np.ones(len(self.T))
		else:
			for i in range(self.idx_moho,len(self.cond_frac)):
				if self.cond_frac[i] == 0.0:
					self.cond_m[i] = 1.0

		if method == 0:

			#Calculating phase exponent of the abundant mineral to make connectedness equal to unity.
			#From Glover (2010, Geophysics), analytic solution.

			#creating search limits for different indexing methods.
			if indexing_method == 'array':
				start_idx = self.idx_moho
				end_idx = len(self.T)
			elif indexing_method == 'index':
				start_idx = sol_idx
				end_idx = sol_idx + 1


			for i in range(start_idx,end_idx):
				phase_list = [self.ol_frac[i],self.opx_frac[i],self.cpx_frac[i],self.gt_frac[i],self.sp_chr_frac[i],self.pl_frac[i],self.amp_frac[i],self.cond_frac[i]]
				m_list = [self.ol_m[i],self.opx_m[i],self.cpx_m[i],self.gt_m[i],self.sp_chr_m[i],self.pl_m[i],self.amp_m[i],self.cond_m[i]]
				frac_abundant = max(phase_list) #fraction of abundant mineral
				idx_max_ph = phase_list.index(frac_abundant) #index of the abundant mineral
				del phase_list[idx_max_ph] #deleting the abundant mineral form local list
				del m_list[idx_max_ph] #deleting the exponent of the abundant mineral from local list
				connectedness = np.asarray(phase_list)**np.asarray(m_list) #calculating the connectedness of the rest
				m_abundant = np.log(1.0 - np.sum(connectedness)) / np.log(frac_abundant) #analytic solution to the problem
				if idx_max_ph == 0:
					self.ol_m[i] = m_abundant
				elif idx_max_ph == 1:
					self.opx_m[i] = m_abundant
				elif idx_max_ph == 2:
					self.cpx_m[i] = m_abundant
				elif idx_max_ph == 3:
					self.gt_m[i] = m_abundant
				elif idx_max_ph == 4:
					self.spr_chr_m[i] = m_abundant
				elif idx_max_ph == 5:
					self.pl_m[i] = m_abundant
				elif idx_max_ph == 6:
					self.amp_m[i] = m_abundant
				elif idx_max_ph == 7:
					self.cond_m[i] = m_abundant

			#Generalized Archie's Law for maximum, minimum bounds and neutral w/o errors

			self.connectedness_ol = self.ol_frac[idx_node]**self.ol_m[idx_node]
			self.connectedness_opx = self.opx_frac[idx_node]**self.opx_m[idx_node]
			self.connectedness_cpx = self.cpx_frac[idx_node]**self.cpx_m[idx_node]
			self.connectedness_gt = self.gt_frac[idx_node]**self.gt_m[idx_node]
			self.connectedness_sp_chr = self.sp_chr_frac[idx_node]**self.sp_chr_m[idx_node]
			self.connectedness_amp = self.amp_frac[idx_node]**self.amp_m[idx_node]
			self.connectedness_pl = self.pl_frac[idx_node]**self.pl_m[idx_node]
			self.connectedness_cond = self.cond_frac[idx_node]**self.cond_m[idx_node]

			self.bulk_cond[idx_node] = (self.ol_cond[idx_node]*(self.ol_frac[idx_node]**self.ol_m[idx_node])) +\
			(self.opx_cond[idx_node]*(self.opx_frac[idx_node]**self.opx_m[idx_node])) +\
			(self.cpx_cond[idx_node]*(self.cpx_frac[idx_node]**self.cpx_m[idx_node])) +\
			(self.gt_cond[idx_node]*(self.gt_frac[idx_node]**self.gt_m[idx_node])) +\
			(self.sp_chr_cond[idx_node]*(self.sp_chr_frac[idx_node]**self.sp_chr_m[idx_node])) +\
			(self.pl_cond[idx_node]*(self.pl_frac[idx_node]**self.pl_m[idx_node])) +\
			(self.amp_cond[idx_node]*(self.amp_frac[idx_node]**self.amp_m[idx_node])) +\
			(self.cond_cond[idx_node]*(self.cond_frac[idx_node]**self.cond_m[idx_node]))

			if indexing_method == 'array':
				self.bulk_cond_max[idx_node] = (self.ol_cond_max[idx_node]*(self.ol_frac[idx_node]**self.ol_m[idx_node])) +\
				(self.opx_cond_max[idx_node]*(self.opx_frac[idx_node]**self.opx_m[idx_node])) +\
				(self.cpx_cond_max[idx_node]*(self.cpx_frac[idx_node]**self.cpx_m[idx_node])) +\
				(self.gt_cond_max[idx_node]*(self.gt_frac[idx_node]**self.gt_m[idx_node])) +\
				(self.sp_chr_cond_max[idx_node]*(self.sp_chr_frac[idx_node]**self.sp_chr_m[idx_node])) +\
				(self.pl_cond_max[idx_node]*(self.pl_frac[idx_node]**self.pl_m[idx_node])) +\
				(self.amp_cond_max[idx_node]*(self.amp_frac[idx_node]**self.amp_m[idx_node])) +\
				(self.cond_cond[idx_node]*(self.cond_frac[idx_node]**self.cond_m[idx_node]))

				self.bulk_cond_min[idx_node] = (self.ol_cond_min[idx_node]*(self.ol_frac[idx_node]**self.ol_m[idx_node])) +\
				(self.opx_cond_min[idx_node]*(self.opx_frac[idx_node]**self.opx_m[idx_node])) +\
				(self.cpx_cond_min[idx_node]*(self.cpx_frac[idx_node]**self.cpx_m[idx_node])) +\
				(self.gt_cond_min[idx_node]*(self.gt_frac[idx_node]**self.gt_m[idx_node])) +\
				(self.sp_chr_cond_min[idx_node]*(self.sp_chr_frac[idx_node]**self.sp_chr_m[idx_node])) +\
				(self.pl_cond_min[idx_node]*(self.pl_frac[idx_node]**self.pl_m[idx_node])) +\
				(self.amp_cond_min[idx_node]*(self.amp_frac[idx_node]**self.amp_m[idx_node])) +\
				(self.cond_cond[idx_node]*(self.cond_frac[idx_node]**self.cond_m[idx_node]))
			else:
				self.bulk_cond_max[idx_node] = self.bulk_cond[idx_node]
				self.bulk_cond_min[idx_node] = self.bulk_cond[idx_node]

		elif method == 1:

			#Hashin-Strikman minimum extramal bound for maximum, minimum bounds and neutral w/o errors

			if indexing_method == 'array':
				self.bulk_cond_max = np.zeros(len(self.ol_cond_max))
				self.bulk_cond_min = np.zeros(len(self.ol_cond_min))
				self.bulk_cond = np.zeros(len(self.ol_cond))
				start_idx = self.idx_moho
				end_idx = len(self.T)
			elif indexing_method == 'index':
				start_idx = sol_idx
				end_idx = sol_idx + 1

			for i in range(start_idx,end_idx):

				list_i_max = [self.ol_cond_max[i],self.opx_cond_max[i],	self.cpx_cond_max[i],self.gt_cond_max[i]]
				list_i_min = [self.ol_cond_min[i],self.opx_cond_min[i],	self.cpx_cond_min[i],self.gt_cond_min[i]]
				list_i = [self.ol_cond[i],self.opx_cond[i],	self.cpx_cond[i],self.gt_cond[i]]

				if MATE.pl_method == '0':

					list_i_max.append(self.pl_cond_max[i])
					list_i_min.append(self.pl_cond_min[i])
					list_i.append(self.pl_cond[i])

				if MATE.amp_method == '0':

					list_i_max.append(self.amp_cond_max[i])
					list_i_min.append(self.amp_cond_min[i])
					list_i.append(self.amp_cond[i])

				if np.mean(self.sp_chr_frac[self.idx_moho:]) != 0.0:

					list_i_max.append(self.sp_chr_cond_max[i])
					list_i_min.append(self.sp_chr_cond_min[i])
					list_i.append(self.sp_chr_cond[i])

				if np.mean(self.cond_frac[self.idx_moho:]) != 0.0:

					list_i_max.append(self.cond_cond[i])
					list_i_min.append(self.cond_cond[i])
					list_i.append(self.cond_cond[i])

				while True:

					#while loop for deleting the zero arrays that could be encountered due to non-existence of the mineral.

					min_local_max = np.amin(np.asarray(list_i_max))
					min_local_min = np.amin(np.asarray(list_i_min))
					min_local = np.amin(np.asarray(list_i))

					if (min_local_min != 0.0) and (min_local_max != 0.0) and (min_local != 0.0):

						break

					else:

						list_i_max = np.delete(list_i_max, np.argwhere(list_i_max == 0))
						list_i_min = np.delete(list_i_min, np.argwhere(list_i_min == 0))
						list_i = np.delete(list_i, np.argwhere(list_i == 0))

				self.bulk_cond[i] =  (((self.ol_frac[i] / (self.ol_cond[i] + (2*min_local))) +\
				(self.opx_frac[i] / (self.opx_cond[i] + (2*min_local))) +\
				(self.cpx_frac[i] / (self.cpx_cond[i] + (2*min_local))) +\
				(self.gt_frac[i] / (self.gt_cond[i] + (2*min_local))) +\
				(self.pl_frac[i] / (self.pl_cond[i] + (2*min_local))) +\
				(self.amp_frac[i] / (self.amp_cond[i] + (2*min_local))) +\
				(self.sp_chr_frac[i] / (self.sp_chr_cond[i] + (2*min_local))) +\
				(self.cond_frac[i] / (self.cond_cond[i] + (2*min_local))))**(-1.0)) -\
				2.0*min_local

				if indexing_method == 'array':
					self.bulk_cond_min[i] = (((self.ol_frac[i] / (self.ol_cond_min[i] + (2*min_local_min))) +\
					(self.opx_frac[i] / (self.opx_cond_min[i] + (2*min_local_min))) +\
					(self.cpx_frac[i] / (self.cpx_cond_min[i] + (2*min_local_min))) +\
					(self.gt_frac[i] / (self.gt_cond_min[i] + (2*min_local_min))) +\
					(self.pl_frac[i] / (self.pl_cond_min[i] + (2*min_local_min))) +\
					(self.amp_frac[i] / (self.amp_cond_min[i] + (2*min_local_min))) +\
					(self.sp_chr_frac[i] / (self.sp_chr_cond_min[i] + (2*min_local_min))) +\
					(self.cond_frac[i] / (self.cond_cond[i] + (2*min_local_min))))**(-1.0)) -\
					2.0*min_local_min

					self.bulk_cond_max[i] = (((self.ol_frac[i] / (self.ol_cond_max[i] + (2*min_local_max))) +\
					(self.opx_frac[i] / (self.opx_cond_max[i] + (2*min_local_max))) +\
					(self.cpx_frac[i] / (self.cpx_cond_max[i] + (2*min_local_max))) +\
					(self.gt_frac[i] / (self.gt_cond_max[i] + (2*min_local_max))) +\
					(self.pl_frac[i] / (self.pl_cond_max[i] + (2*min_local_max))) +\
					(self.amp_frac[i] / (self.amp_cond_max[i] + (2*min_local_max))) +\
					(self.sp_chr_frac[i] / (self.sp_chr_cond_max[i] + (2*min_local_max))) +\
					(self.cond_frac[i] / (self.cond_cond[i] + (2*min_local_max))))**(-1.0)) -\
					2.0*min_local_max
				else:
					self.bulk_cond_max[idx_node] = self.bulk_cond[idx_node]
					self.bulk_cond_min[idx_node] = self.bulk_cond[idx_node]

		elif method == 2:

			#Hashin-Strikman minimum extramal bound for maximum, minimum bounds and neutral w/o errors

			if indexing_method == 'array':
				self.bulk_cond_max = np.zeros(len(self.ol_cond_max))
				self.bulk_cond_min = np.zeros(len(self.ol_cond_min))
				self.bulk_cond = np.zeros(len(self.ol_cond))
				start_idx = self.idx_moho
				end_idx = len(self.T)
			elif indexing_method == 'index':
				start_idx = sol_idx
				end_idx = sol_idx + 1

			for i in range(start_idx,end_idx):

				list_i_max = [self.ol_cond_max[i],self.opx_cond_max[i],	self.cpx_cond_max[i],self.gt_cond_max[i]]
				list_i_min = [self.ol_cond_min[i],self.opx_cond_min[i],	self.cpx_cond_min[i],self.gt_cond_min[i]]
				list_i = [self.ol_cond[i],self.opx_cond[i],	self.cpx_cond[i],self.gt_cond[i]]

				if MATE.pl_method == '0':

					list_i_max.append(self.pl_cond_max[i])
					list_i_min.append(self.pl_cond_min[i])
					list_i.append(self.pl_cond[i])

				if MATE.amp_method == '0':

					list_i_max.append(self.amp_cond_max[i])
					list_i_min.append(self.amp_cond_min[i])
					list_i.append(self.amp_cond[i])

				if np.mean(self.sp_chr_frac[self.idx_moho:]) != 0.0:

					list_i_max.append(self.sp_chr_cond_max[i])
					list_i_min.append(self.sp_chr_cond_min[i])
					list_i.append(self.sp_chr_cond[i])

				if np.mean(self.cond_frac[self.idx_moho:]) != 0.0:

					list_i_max.append(self.cond_cond[i])
					list_i_min.append(self.cond_cond[i])
					list_i.append(self.cond_cond[i])

				while True:

					#while loop for deleting the zero arrays that could be encountered due to non-existence of the mineral.

					max_local_max = np.amax(np.asarray(list_i_max))
					max_local_min = np.amax(np.asarray(list_i_min))
					max_local = np.amax(np.asarray(list_i))

					if (max_local_min != 0.0) and (max_local_max != 0.0) and (max_local != 0.0):

						break

					else:

						list_i_max = np.delete(list_i_max, np.argwhere(list_i_max == 0))
						list_i_min = np.delete(list_i_min, np.argwhere(list_i_min == 0))
						list_i = np.delete(list_i, np.argwhere(list_i == 0))

				self.bulk_cond[i] =  (((self.ol_frac[i] / (self.ol_cond[i] + 2*max_local)) +\
				(self.opx_frac[i] / (self.opx_cond[i] + 2*max_local)) +\
				(self.cpx_frac[i] / (self.cpx_cond[i] + 2*max_local)) +\
				(self.gt_frac[i] / (self.gt_cond[i] + 2*max_local)) +\
				(self.pl_frac[i] / (self.pl_cond[i] + 2*max_local)) +\
				(self.amp_frac[i] / (self.amp_cond[i] + 2*max_local)) +\
				(self.sp_chr_frac[i] / (self.sp_chr_cond[i] + 2*max_local)) +\
				(self.cond_frac[i] / (self.cond_cond[i] + 2*max_local)))**(-1.0)) -\
				2.0*max_local

				if indexing_method == 'array':
					self.bulk_cond_min[i] = (((self.ol_frac[i] / (self.ol_cond_min[i] + 2*max_local_min)) +\
					(self.opx_frac[i] / (self.opx_cond_min[i] + 2*max_local_min)) +\
					(self.cpx_frac[i] / (self.cpx_cond_min[i] + 2*max_local_min)) +\
					(self.gt_frac[i] / (self.gt_cond_min[i] + 2*max_local_min)) +\
					(self.pl_frac[i] / (self.pl_cond_min[i] + 2*max_local_min)) +\
					(self.amp_frac[i] / (self.amp_cond_min[i] + 2*max_local_min)) +\
					(self.sp_chr_frac[i] / (self.sp_chr_cond_min[i] + 2*max_local_min)) +\
					(self.cond_frac[i] / (self.cond_cond[i] + 2*max_local_min)))**(-1.0)) -\
					2.0*max_local_min

					self.bulk_cond_max[i] = (((self.ol_frac[i] / (self.ol_cond_max[i] + 2*max_local_max)) +\
					(self.opx_frac[i] / (self.opx_cond_max[i] + 2*max_local_max)) +\
					(self.cpx_frac[i] / (self.cpx_cond_max[i] + 2*max_local_max)) +\
					(self.gt_frac[i] / (self.gt_cond_max[i] + 2*max_local_max)) +\
					(self.pl_frac[i] / (self.pl_cond_max[i] + 2*max_local_max)) +\
					(self.amp_frac[i] / (self.amp_cond_max[i] + 2*max_local_max)) +\
					(self.sp_chr_frac[i] / (self.sp_chr_cond_max[i] + 2*max_local_max)) +\
					(self.cond_frac[i] / (self.cond_cond[i] + 2*max_local_max)))**(-1.0)) -\
					2.0*max_local_max
				else:
					self.bulk_cond_max[idx_node] = self.bulk_cond[idx_node]
					self.bulk_cond_min[idx_node] = self.bulk_cond[idx_node]

		elif method == 3:

			#Parallel model for maximum, minimum bounds and neutral w/o errors

			self.bulk_cond[idx_node] = (self.ol_frac[idx_node]*self.ol_cond[idx_node]) +\
			(self.opx_frac[idx_node]*self.opx_cond[idx_node]) +\
			(self.cpx_frac[idx_node]*self.cpx_cond[idx_node]) +\
			(self.gt_frac[idx_node]*self.gt_cond[idx_node]) +\
			(self.pl_frac[idx_node]*self.pl_cond[idx_node]) +\
			(self.amp_frac[idx_node]*self.amp_cond[idx_node]) +\
			(self.sp_chr_frac[idx_node]*self.sp_chr_cond[idx_node]) +\
			(self.cond_frac[idx_node]*self.cond_cond[idx_node])

			if indexing_method == 'array':
				self.bulk_cond_max[idx_node] = (self.ol_frac[idx_node]*self.ol_cond_max[idx_node]) +\
				(self.opx_frac[idx_node]*self.opx_cond_max[idx_node]) +\
				(self.cpx_frac[idx_node]*self.cpx_cond_max[idx_node]) +\
				(self.gt_frac[idx_node]*self.gt_cond_max[idx_node]) +\
				(self.pl_frac[idx_node]*self.pl_cond_max[idx_node]) +\
				(self.amp_frac[idx_node]*self.amp_cond_max[idx_node]) +\
				(self.sp_chr_frac[idx_node]*self.sp_chr_cond_max[idx_node]) +\
				(self.cond_frac[idx_node]*self.cond_cond[idx_node])

				self.bulk_cond_min[idx_node] = (self.ol_frac[idx_node]*self.ol_cond_min[idx_node]) +\
				(self.opx_frac[idx_node]*self.opx_cond_min[idx_node]) +\
				(self.cpx_frac[idx_node]*self.cpx_cond_min[idx_node]) +\
				(self.gt_frac[idx_node]*self.gt_cond_min[idx_node]) +\
				(self.pl_frac[idx_node]*self.pl_cond_min[idx_node]) +\
				(self.amp_frac[idx_node]*self.amp_cond_min[idx_node]) +\
				(self.sp_chr_frac[idx_node]*self.sp_chr_cond_min[idx_node]) +\
				(self.cond_frac[idx_node]*self.cond_cond[idx_node])
			else:
				self.bulk_cond_max[idx_node] = self.bulk_cond[idx_node]
				self.bulk_cond_min[idx_node] = self.bulk_cond[idx_node]

		elif method == 4:

			if indexing_method == 'array':
				self.bulk_cond_max = np.zeros(len(self.ol_cond_max))
				self.bulk_cond_min = np.zeros(len(self.ol_cond_min))
				self.bulk_cond = np.zeros(len(self.ol_cond))
				start_idx = self.idx_moho
				end_idx = len(self.T)
			elif indexing_method == 'index':
				start_idx = sol_idx
				end_idx = sol_idx + 1

			#Perpendicular model for maximum, minimum bounds and neutral w/o errors
			for i in range(start_idx,end_idx):
				if self.ol_frac[i] == 0.0:
					self.ol_cond_max[i] = -999
					self.ol_cond_min[i] = -999
					self.ol_cond[i] = -999
				if self.opx_frac[i] == 0.0:
					self.opx_cond_max[i] = -999
					self.opx_cond_min[i] = -999
					self.opx_cond[i] = -999
				if self.cpx_frac[i] == 0.0:
					self.cpx_cond_max[i] = -999
					self.cpx_cond_min[i] = -999
					self.cpx_cond[i] = -999
				if self.gt_frac[i] == 0.0:
					self.gt_cond_max[i] = -999
					self.gt_cond_min[i] = -999
					self.gt_cond[i] = -999
				if self.pl_frac[i] == 0.0:
					self.pl_cond_max[i] = -999
					self.pl_cond_min[i] = -999
					self.pl_cond[i] = -999
				if self.sp_chr_frac[i] == 0.0:
					self.sp_chr_cond_max[i] = -999
					self.sp_chr_cond_min[i] = -999
					self.sp_chr_cond[i] = -999
				if self.amp_frac[i] == 0.0:
					self.amp_cond_max[i] = -999
					self.amp_cond_min[i] = -999
					self.amp_cond[i] = -999
				if self.cond_frac[i] == 0.0:
					self.cond_cond[i] = -999

			self.bulk_cond[idx_node] = 1.0 / ((self.ol_frac[idx_node] / self.ol_cond[idx_node]) +\
			(self.opx_frac[idx_node] / self.opx_cond[idx_node]) +\
			(self.cpx_frac[idx_node] / self.cpx_cond[idx_node]) +\
			(self.gt_frac[idx_node] / self.gt_cond[idx_node]) +\
			(self.sp_chr_frac[idx_node] / self.sp_chr_cond[idx_node]) +\
			(self.pl_frac[idx_node] / self.pl_cond[idx_node]) +\
			(self.amp_frac[idx_node] / self.amp_cond[idx_node]) +\
			(self.cond_frac[idx_node] / self.cond_cond[idx_node]))

			if indexing_method == 'array':
				self.bulk_cond_max[idx_node] = 1.0 / ((self.ol_frac[idx_node] / self.ol_cond_max[idx_node]) +\
				(self.opx_frac[idx_node] / self.opx_cond_max[idx_node]) +\
				(self.cpx_frac[idx_node] / self.cpx_cond_max[idx_node]) +\
				(self.gt_frac[idx_node] / self.gt_cond_max[idx_node]) +\
				(self.sp_chr_frac[idx_node] / self.sp_chr_cond_max[idx_node]) +\
				(self.pl_frac[idx_node] / self.pl_cond_max[idx_node]) +\
				(self.amp_frac[idx_node] / self.amp_cond_max[idx_node]) +\
				(self.cond_frac[idx_node] / self.cond_cond[idx_node]))

				self.bulk_cond_min[idx_node] = 1.0 / ((self.ol_frac[idx_node] / self.ol_cond_min[idx_node]) +\
				(self.opx_frac[idx_node] / self.opx_cond_min[idx_node]) +\
				(self.cpx_frac[idx_node] / self.cpx_cond_min[idx_node]) +\
				(self.gt_frac[idx_node] / self.gt_cond_min[idx_node]) +\
				(self.sp_chr_frac[idx_node] / self.sp_chr_cond_min[idx_node]) +\
				(self.pl_frac[idx_node] / self.pl_cond_min[idx_node]) +\
				(self.amp_frac[idx_node] / self.amp_cond_min[idx_node]) +\
				(self.cond_frac[idx_node] / self.cond_cond[idx_node]))
			else:
				self.bulk_cond_max[idx_node] = self.bulk_cond[idx_node]
				self.bulk_cond_min[idx_node] = self.bulk_cond[idx_node]

		elif method == 5:

			#Random model for maximum, minimum bounds and neutral w/o errors

			self.bulk_cond[idx_node] = (self.ol_cond[idx_node]**self.ol_frac[idx_node]) *\
			(self.opx_cond[idx_node]**self.opx_frac[idx_node]) *\
			(self.cpx_cond[idx_node]**self.cpx_frac[idx_node]) *\
			(self.gt_cond[idx_node]**self.gt_frac[idx_node]) *\
			(self.sp_chr_cond[idx_node]**self.sp_chr_frac[idx_node]) *\
			(self.pl_cond[idx_node]**self.pl_frac[idx_node]) *\
			(self.amp_cond[idx_node]**self.amp_frac[idx_node]) *\
			(self.cond_cond[idx_node]**self.cond_frac[idx_node])

			if indexing_method == 'array':
				self.bulk_cond_max[idx_node] = (self.ol_cond_max[idx_node]**self.ol_frac[idx_node]) *\
				(self.opx_cond_max[idx_node]**self.opx_frac[idx_node]) *\
				(self.cpx_cond_max[idx_node]**self.cpx_frac[idx_node]) *\
				(self.gt_cond_max[idx_node]**self.gt_frac[idx_node]) *\
				(self.sp_chr_cond_max[idx_node]**self.sp_chr_frac[idx_node]) *\
				(self.pl_cond_max[idx_node]**self.pl_frac[idx_node]) *\
				(self.amp_cond_max[idx_node]**self.amp_frac[idx_node]) *\
				(self.cond_cond[idx_node]**self.cond_frac[idx_node])

				self.bulk_cond_min[idx_node] = (self.ol_cond_min[idx_node]**self.ol_frac[idx_node]) *\
				(self.opx_cond_min[idx_node]**self.opx_frac[idx_node]) *\
				(self.cpx_cond_min[idx_node]**self.cpx_frac[idx_node]) *\
				(self.gt_cond_min[idx_node]**self.gt_frac[idx_node]) *\
				(self.sp_chr_cond_min[idx_node]**self.sp_chr_frac[idx_node]) *\
				(self.pl_cond_min[idx_node]**self.pl_frac[idx_node]) *\
				(self.amp_cond_min[idx_node]**self.amp_frac[idx_node]) *\
				(self.cond_cond[idx_node]**self.cond_frac[idx_node])
			else:
				self.bulk_cond_max[idx_node] = self.bulk_cond[idx_node]
				self.bulk_cond_min[idx_node] = self.bulk_cond[idx_node]

		self.bulk_error = (self.bulk_cond_max - self.bulk_cond_min) / 2.0

		if MATE.melt_method == '0':

			#Determining xvol, first have to calculate the density of the melt from Sifre et al. (2014)
			self.dens_melt_dry = float(self.dens_mat[7][MATE.melt_cond_selection]) / 1e3

			self.dens_melt[idx_node] = (((self.melt_h2o[idx_node] * 1e-4) / 1e2) * 1.4) +\
				(((self.co2[idx_node] * 1e-4) / 1e2) * 2.4) + (1 - (((self.melt_h2o[idx_node] * 1e-4) +\
				(self.co2[idx_node] * 1e-4)) / 1e2)) * self.dens_melt_dry

			#Volume fraction of melt calculated from melt mass fraction (melt_mass_frac)

			if indexing_method == 'array':
				self.melt_frac = np.zeros(len(self.melt_mass_frac))
				start_idx = self.idx_moho
				end_idx = len(self.T)
			elif indexing_method == 'index':
				start_idx = sol_idx
				end_idx = sol_idx + 1

			for i in range(start_idx,end_idx):
				if self.melt_mass_frac[i] != 0.0:
					self.melt_frac[i] = 1.0 / (1 + (((1.0/self.melt_mass_frac[i]) - 1) * (self.dens_melt[i] / (self.density_mantle[i] / 1e3))))

			if melt_method == 0:

				#Modified Archie's Law taken from Glover et al. (2000) from eq. 8

				for i in range(start_idx,end_idx):

					if self.melt_mass_frac[i] != 0.0:

						p = np.log10(1.0 - self.melt_frac[i]**self.melt_m[i]) / np.log10(1.0 - self.melt_frac[i])

						self.bulk_cond[i] = (self.bulk_cond[i] * (1.0 - self.melt_frac[i])**p) + (self.melt_cond[i] * (self.melt_frac[i]**self.melt_m[i]))
						if indexing_method == 'array':
							self.bulk_cond_max[i] = (self.bulk_cond_max[i] * (1.0 - self.melt_frac[i])**p) + (self.melt_cond_max[i] * (self.melt_frac[i]**self.melt_m[i]))
							self.bulk_cond_min[i] = (self.bulk_cond_min[i] * (1.0 - self.melt_frac[i])**p) + (self.melt_cond_min[i] * (self.melt_frac[i]**self.melt_m[i]))
						else:
							self.bulk_cond_max[i] = self.bulk_cond[i]
							self.bulk_cond_min[i] = self.bulk_cond[i]

			elif melt_method == 1:

				#Tubes model for melt and solid mixture from ten Grotenhuis et al. (2005) eq.5

				self.bulk_cond[idx_node] = ((1.0/3.0) * self.melt_frac[idx_node] * self.melt_cond[idx_node]) + ((1.0 - self.melt_frac[idx_node]) * self.bulk_cond[idx_node])

				if indexing_method == 'array':
					self.bulk_cond_max[idx_node] = ((1.0/3.0) * self.melt_frac[idx_node] * self.melt_cond_max[idx_node]) + ((1.0 - self.melt_frac[idx_node]) * self.bulk_cond_max[idx_node])
					self.bulk_cond_min[idx_node] = ((1.0/3.0) * self.melt_frac[idx_node] * self.melt_cond_min[idx_node]) + ((1.0 - self.melt_frac[idx_node]) * self.bulk_cond_min[idx_node])
				else:
					self.bulk_cond_max[i] = self.bulk_cond[i]
					self.bulk_cond_min[i] = self.bulk_cond[i]

			elif melt_method == 2:

				#Spheres model for melt ans solid mixture got from ten Grotenhuis et al. (2005), eq.3

				self.bulk_cond[idx_node] = self.melt_cond[idx_node] + ((1.0 - self.melt_frac[idx_node]) / ((1.0 / (self.bulk_cond[idx_node] - self.melt_cond[idx_node])) +\
				 	(self.melt_frac[idx_node] / (3.0 * self.melt_cond[idx_node]))))

				if indexing_method == 'array':
					self.bulk_cond_max[idx_node] = self.melt_cond_max[idx_node] + ((1.0 - self.melt_frac[idx_node]) / ((1.0 / (self.bulk_cond_max[idx_node] - self.melt_cond_max[idx_node])) +\
					 	(self.melt_frac[idx_node] / (3.0 * self.melt_cond_max[idx_node]))))

					self.bulk_cond_min[idx_node] = self.melt_cond_min[idx_node] + ((1.0 - self.melt_frac[idx_node]) / ((1.0 / (self.bulk_cond_min[idx_node] - self.melt_cond_min[idx_node])) +\
					 	(self.melt_frac[idx_node] / (3.0 * self.melt_cond_min[idx_node]))))
				else:
					self.bulk_cond_max[i] = self.bulk_cond[i]
					self.bulk_cond_min[i] = self.bulk_cond[i]

			elif melt_method == 3:

				#Modified brick-layer model from Schilling et al. (1997)

				ones = (1.0 - self.melt_frac[idx_node])
				two_thirds = (1.0 - self.melt_frac[idx_node])**(2.0/3.0)

				self.bulk_cond[idx_node] = self.melt_cond[idx_node] * (((self.melt_cond[idx_node] * (two_thirds - 1.0)) - (self.bulk_cond[idx_node] * two_thirds)) /\
				((self.bulk_cond[idx_node] * (ones - two_thirds)) + (self.melt_cond[idx_node] * (two_thirds - ones - 1.0))))

				if indexing_method == 'array':
					self.bulk_cond_max[idx_node] = self.melt_cond_max[idx_node] * ((self.melt_cond_max[idx_node] * (two_thirds - 1.0)) - (self.bulk_cond_max[idx_node] * two_thirds)) /\
					((self.bulk_cond_max[idx_node] * (ones - two_thirds)) + (self.melt_cond_max[idx_node] * (two_thirds - ones - 1.0)))

					self.bulk_cond_min[idx_node] = self.melt_cond_min[idx_node] * ((self.melt_cond_min[idx_node] * (two_thirds - 1.0)) - (self.bulk_cond_min[idx_node] * two_thirds)) /\
					((self.bulk_cond_min[idx_node] * (ones- two_thirds)) + (self.melt_cond_min[idx_node] * (two_thirds - ones - 1.0)))
				else:
					self.bulk_cond_max[i] = self.bulk_cond[i]
					self.bulk_cond_min[i] = self.bulk_cond[i]

			elif melt_method == 4:

				#Hashin-shtrikman upper bound from Glover et al. (2000)
				vol_matrix = 1.0 - self.melt_frac[idx_node]

				self.bulk_cond[idx_node] = self.melt_cond[idx_node] * (1 -\
				((3 * vol_matrix * (self.melt_cond[idx_node] - self.bulk_cond[idx_node])) /\
				(3 * self.melt_cond[idx_node] - (self.melt_frac[idx_node] * (self.melt_cond[idx_node] - self.bulk_cond[idx_node])))))

				if indexing_method == 'array':
					self.bulk_cond_max[idx_node] = self.melt_cond_max[idx_node] * (1 -\
					((3 * vol_matrix * (self.melt_cond_max[idx_node] - self.bulk_cond_max[idx_node])) /\
					(3 * self.melt_cond_max[idx_node] - (self.melt_frac[idx_node] * (self.melt_cond_max[idx_node] - self.bulk_cond_max[idx_node])))))

					self.bulk_cond_min[idx_node] = self.melt_cond_min[idx_node] * (1 -\
					((3 * vol_matrix * (self.melt_cond_min[idx_node] - self.bulk_cond_min[idx_node])) /\
					(3 * self.melt_cond_min[idx_node] - (self.melt_frac[idx_node] * (self.melt_cond_min[idx_node] - self.bulk_cond_min[idx_node])))))
				else:
					self.bulk_cond_max[i] = self.bulk_cond[i]
					self.bulk_cond_min[i] = self.bulk_cond[i]

			elif melt_method == 5:

				#Hashin-shtrikman lower bound from Glover et al. (2000)
				vol_matrix = 1.0 - self.melt_frac[idx_node]

				self.bulk_cond[idx_node] = self.bulk_cond[idx_node] * (1 +\
				((3 * self.melt_frac[idx_node] * (self.melt_cond[idx_node] - self.bulk_cond[idx_node])) /\
				(3 * self.bulk_cond[idx_node] + (vol_matrix * (self.melt_cond[idx_node] - self.bulk_cond[idx_node])))))

				if indexing_method == 'array':

					self.bulk_cond_max[idx_node] = self.bulk_cond_max[idx_node] * (1 +\
					((3 * self.melt_frac[idx_node] * (self.melt_cond_max[idx_node] - self.bulk_cond_max[idx_node])) /\
					(3 * self.bulk_cond_max[idx_node] + (vol_matrix * (self.melt_cond_max[idx_node] - self.bulk_cond_max[idx_node])))))

					self.bulk_cond_min[idx_node] = self.bulk_cond_min[idx_node] * (1 +\
					((3 * self.melt_frac[idx_node] * (self.melt_cond_min[idx_node] - self.bulk_cond_min[idx_node])) /\
					(3 * self.bulk_cond_min[idx_node] + (vol_matrix * (self.melt_cond_min[idx_node] - self.bulk_cond_min[idx_node])))))
				else:
					self.bulk_cond_max[i] = self.bulk_cond[i]
					self.bulk_cond_min[i] = self.bulk_cond[i]

	def read_ModEM_dat(self):

		#Reading ModEM dat file to get coordinates of stations and model centre.

		self.ModEM_dat_data = self.read_csv(str(self.ModEM_data_file_name[0]),delim = ' ')

		MATE.station_lat = []
		MATE.station_lon = []
		MATE.station_name = []
		MATE.station_posx = []
		MATE.station_posy = []
		try:
			MATE.mc_lat = float(self.ModEM_dat_data[6][1])
			MATE.mc_lon = float(self.ModEM_dat_data[6][2])

			dash_found = False

			for row in range(8,len(self.ModEM_dat_data)):
				if self.ModEM_dat_data[row][0] == '#' :
					limitlines = row-1
					dash_found = True

			if dash_found == False:
				limitlines = len(self.ModEM_dat_data)

			for row in range(8,limitlines):
				if self.ModEM_dat_data[row][1] != self.ModEM_dat_data[row-1][1]:
					MATE.station_name.append(self.ModEM_dat_data[row][1])
					MATE.station_lat.append(float(self.ModEM_dat_data[row][2]))
					MATE.station_lon.append(float(self.ModEM_dat_data[row][3]))
					MATE.station_posx.append(float(self.ModEM_dat_data[row][4]))
					MATE.station_posy.append(float(self.ModEM_dat_data[row][5]))
		except IndexError:
			QMessageBox.about(self,'Warning!','Structure of the csv file seems to be wrong.')
			return

		self.ModEM_dat_read = True
		MATE.res_profile_plot_list = []
		MATE.res_profile_max_plot_list = []
		MATE.res_profile_min_plot_list = []

		MATE.st_item_list = []

		for i in range(0,len(MATE.station_name)):

			MATE.st_item_list.append(str(i) + ' - ' + MATE.station_name[i])

		QMessageBox.about(self,'Success',str(self.ModEM_data_file_name[0]) + ' file was succesfully imported to the program!')

	def read_ModEM_rho(self):

		self.ModEM_rho_data = self.read_csv(str(self.ModEM_model_file_name[0]), delim = ' ')

		self.x_num = int(self.ModEM_rho_data[1][0])
		self.y_num = int(self.ModEM_rho_data[1][1])
		self.z_num = int(self.ModEM_rho_data[1][2])

		self.x_grid = np.asarray(self.ModEM_rho_data[2]).astype(np.float)
		self.y_grid = np.asarray(self.ModEM_rho_data[3]).astype(np.float)
		self.z_grid = np.asarray(self.ModEM_rho_data[4]).astype(np.float)

		self.lenxgrid = len(self.x_grid)
		self.lenygrid = len(self.y_grid)
		self.lenzgrid = len(self.z_grid)

		MATE.rho = []

		for k in range(5,len(self.ModEM_rho_data) - 2 ,self.y_num):
			rhoy = []
			for z in range(k, k + self.y_num):
				rhox = []
				for l in range(0,self.x_num):
					rhox.append(float(self.ModEM_rho_data[z][l]))
				rhoy.append(rhox)

			MATE.rho.append(rhoy)

		MATE.rho = np.exp(np.asarray(MATE.rho))

		MATE.z_depth = np.array([0.0])
		self.z_grid = np.cumsum(self.z_grid)
		MATE.z_depth = np.append(MATE.z_depth,self.z_grid)
		MATE.z_mesh_center = []
		for i in range(1,len(MATE.z_depth)):
			MATE.z_mesh_center.append((((MATE.z_depth[i] - MATE.z_depth[i-1]) / 2.0) + MATE.z_depth[i-1]) / 1000.0)

		MATE.x_grid_cum = []
		MATE.y_grid_cum = []
		self.mid_point_x = int(len(self.x_grid) / 2.0)
		self.mid_point_y = int(len(self.y_grid) / 2.0)

		if len(self.x_grid) %2 == 0:
			self.mid_point_x = int(len(self.x_grid) / 2.0)
			beg_x = np.sum(self.x_grid[:self.mid_point_x]) * -1

		elif len(self.x_grid) %2 != 0:
			self.mid_point_x = int(len(self.x_grid) / 2.0) + 1
			beg_x = np.sum(self.x_grid[:self.mid_point_x]) * -1 + (self.x_grid[self.mid_point_x] / 2.0)

		if len(self.y_grid) %2 == 0:
			self.mid_point_y = int(len(self.y_grid) / 2.0)
			beg_y = np.sum(self.y_grid[:self.mid_point_y]) * -1
		elif len(self.y_grid) %2 != 0:
			self.mid_point_y = int(len(self.y_grid) / 2.0) + 1
			beg_y = np.sum(self.y_grid[:self.mid_point_y]) * -1 + (self.y_grid[self.mid_point_y] / 2.0)

		MATE.x_grid_cum.append(beg_x)
		for i in range(0,self.lenxgrid-1):
			beg_x += self.x_grid[i]
			MATE.x_grid_cum.append(beg_x)
		MATE.y_grid_cum.append(beg_y)
		for i in range(0,self.lenygrid-1):
			beg_y += self.y_grid[i]
			MATE.y_grid_cum.append(beg_y)

		MATE.rectobj_list = []
		x1list = []
		MATE.x_grid_cum = MATE.x_grid_cum[::-1]
		self.x_grid = self.x_grid[::-1]
		for i in range(0,len(MATE.y_grid_cum)):
			for j in range(0,len(MATE.x_grid_cum)):
				x1 = MATE.y_grid_cum[i]
				y1 = MATE.x_grid_cum[j]
				x1list.append(x1)
				rectobj = patches.Rectangle((x1,y1),self.y_grid[i],self.x_grid[j])
				MATE.rectobj_list.append(rectobj)

		MATE.min_x_grid_cum = np.amin(MATE.x_grid_cum)
		MATE.max_x_grid_cum = np.amax(MATE.x_grid_cum)
		MATE.min_y_grid_cum = np.amin(MATE.y_grid_cum)
		MATE.max_y_grid_cum = np.amax(MATE.y_grid_cum)

		#Creating x and y mesh centers to find the profile locations

		MATE.x_mesh_center = []
		MATE.y_mesh_center = []

		for i in range(1,len(MATE.x_grid_cum)):
			MATE.x_mesh_center.append(((MATE.x_grid_cum[i] - MATE.x_grid_cum[i-1]) / 2.0) + MATE.x_grid_cum[i-1])
		for i in range(1,len(MATE.y_grid_cum)):
			MATE.y_mesh_center.append(((MATE.y_grid_cum[i] - MATE.y_grid_cum[i-1]) / 2.0) + MATE.y_grid_cum[i-1])

		MATE.z_number = self.z_num
		self.ModEM_model_read = True
		self.csv_MT_read = False

		QMessageBox.about(self,'Success',str(self.ModEM_model_file_name[0]) + ' file was succesfully imported to the program!')

	def read_csv_MT_file(self):

		self.csv_mt_data = self.read_csv(str(self.csv_MT_file_name[0]),delim = ',')

		MATE.z_depth = []
		MATE.res_profile = []
		MATE.res_profile_max = []
		MATE.res_profile_min = []

		try:
			for i in range(1,len(self.csv_mt_data)):
				try:
					MATE.z_depth.append(float(self.csv_mt_data[i][0]))
					MATE.res_profile.append(float(self.csv_mt_data[i][1]))
					MATE.res_profile_max.append(float(self.csv_mt_data[i][2]))
					MATE.res_profile_min.append(float(self.csv_mt_data[i][3]))
				except ValueError:
					QMessageBox.about(self,'Warning!','There is an element in the file that can not be transformed into floating number...')
					return
		except IndexError:
			QMessageBox.about(self,'Warning!','Structure of the csv file seems to be wrong.')
			return

		if MATE.csv_file_selection == 0:

			MATE.z_depth_plot = []
			MATE.res_profile_plot = []
			MATE.res_profile_max_plot = []
			MATE.res_profile_min_plot = []

			for i in range(0,len(MATE.res_profile)):
				for j in range(0,2):
					MATE.res_profile_plot.append(MATE.res_profile[i])
					MATE.res_profile_max_plot.append(MATE.res_profile_max[i])
					MATE.res_profile_min_plot.append(MATE.res_profile_min[i])

			for i in range(0,len(MATE.z_depth)):
				if (i == 0):
					MATE.z_depth_plot.append(MATE.z_depth[i])
					MATE.z_depth_plot.append(MATE.z_depth[i+1])
				elif  (i == len(MATE.z_depth)-1):
					MATE.z_depth_plot.append(MATE.z_depth[i])
					MATE.z_depth_plot.append(1e4)
				else:
					for j in range(0,2):
						MATE.z_depth_plot.append(MATE.z_depth[i])
		else:
			MATE.res_profile_plot = MATE.res_profile
			MATE.res_profile_max_plot = MATE.res_profile_max
			MATE.res_profile_min_plot = MATE.res_profile_min
			MATE.z_depth_plot = MATE.z_depth

		MATE.res_profile_plot_list.append(MATE.res_profile_plot)
		MATE.res_profile_max_plot_list.append(MATE.res_profile_max_plot)
		MATE.res_profile_min_plot_list.append(MATE.res_profile_min_plot)
		MATE.z_depth_plot_list.append(MATE.z_depth_plot)

		self.csv_MT_read = True
		self.ModEM_dat_read = False
		self.ModEM_model_read = False

		QMessageBox.about(self,'Success',str(self.csv_MT_file_name[0]) + ' file was succesfully imported to the program!')

	def MT_model_rms(self):

		if (self.ModEM_dat_read == True) and (self.ModEM_model_read == True):

			if MATE.ModEM_data_submit == True:
				#The MT profile needs interpolation

				self.z_center = np.asarray(MATE.z_mesh_center) * 1000.0

				idx_start_mt = (np.abs(np.asarray(self.z_center)-MATE.moho)).argmin()

				if self.z_center[idx_start_mt] > MATE.moho:
					idx_start_mt = idx_start_mt - 1

				f_mt_profile = interp1d(self.z_center[idx_start_mt:],MATE.res_profile[idx_start_mt:])

				self.mt_profile_mantle = f_mt_profile(self.depth_mantle)

				self.misfit_mt = (self.mt_profile_mantle - (1.0/self.bulk_cond[self.idx_moho:])) / (1.0/self.bulk_error[self.idx_moho:])

				self.rms_mt = self.misfit_mt.std()

	def xenolith_RMS(self, T = None,P = None ,std_T = None,std_P = None,P_eq = None,T_eq = None):

		xenolith_RMS = ((1.0/float(len(T))) * np.sum((((T-T_eq)**2.0)) / (std_T**2.0))) ** 0.5

		return xenolith_RMS

	def plot_composition(self,method = None):

		if method == 'draw':
			if MATE.melt_method == '0':
				self.ax0 = plt.subplot2grid((16,16),(0,0), rowspan = 16,colspan = 3, fig = self.fig)
			else:
				self.ax0 = plt.subplot2grid((16,16),(0,0), rowspan = 16,colspan = 4, fig = self.fig)
			fontsize_labels = 8

		elif method == 'save':
			self.figure_comp_save = plt.figure(figsize = (2,7))
			fontsize_labels = 10
			self.ax0 = plt.subplot(111)


		self.ax0.fill_betweenx(self.depth[self.idx_moho:]/1000.0,self.ol_frac[self.idx_moho:] * 100.0,np.zeros(len(self.ol_frac[self.idx_moho:])),color = '#0b820f',alpha = 0.8,label = 'ol')
		scnd_box = self.ol_frac[self.idx_moho:] * 100.0 + self.opx_frac[self.idx_moho:] * 100
		thrd_box = scnd_box + self.cpx_frac[self.idx_moho:] * 100
		frth_box = thrd_box + self.gt_frac[self.idx_moho:] * 100
		ffth_box = frth_box + self.sp_chr_frac[self.idx_moho:] * 100
		self.ax0.fill_betweenx(self.depth[self.idx_moho:]/1000.0,scnd_box,self.ol_frac[self.idx_moho:] * 100.0,color = '#0b3c82',alpha = 0.8,label = 'opx')
		self.ax0.fill_betweenx(self.depth[self.idx_moho:]/1000.0,thrd_box,scnd_box,color = '#dbc14e',alpha = 0.8,label = 'cpx')
		self.ax0.fill_betweenx(self.depth[self.idx_moho:]/1000.0,frth_box,thrd_box,color = '#ad0f1f',alpha = 0.8,label = 'gt')
		self.ax0.fill_betweenx(self.depth[self.idx_moho:]/1000.0,ffth_box,frth_box,color = '#0fadad',alpha = 0.8,label = 'sp_chr')

		if MATE.pl_method == '0':
			sxth_box = ffth_box + self.pl_frac[self.idx_moho:] * 100
			self.ax0.fill_betweenx(self.depth[self.idx_moho:]/1000.0,sxth_box,ffth_box,color = '#2dff5b',alpha = 0.8,label = 'phlg')
			if MATE.amp_method == '0':
				svnth_box = sxth_box + self.amp_frac[self.idx_moho:] * 100
				self.ax0.fill_betweenx(self.depth[self.idx_moho:]/1000.0,svnth_box,sxth_box,color = '#853de3',alpha = 0.8,label = 'amph')
		else:
			if MATE.amp_method == '0':
				sxth_box = ffth_box + self.amp_frac[self.idx_moho:] * 100
				self.ax0.fill_betweenx(self.depth[self.idx_moho:]/1000.0,sxth_box,ffth_box,color = '#853de3',alpha = 0.8,label = 'amph')

		self.ax0.axhline(MATE.moho/1000.0, linestyle = '--',color = '#BA43C2', alpha = 0.85,linewidth = 2.5)
		self.ax0.axhline(MATE.lab/1000.0, linestyle = '--', color = 'k', alpha = 0.85,linewidth = 2.5)
		for i in range(0,len(self.depth_comp_plot)):
			self.ax0.axhline(self.depth_comp_plot[i]/1000.0,linewidth = 0.75, alpha = 0.5, color = 'k',linestyle = '-.')

		for tick in self.ax0.xaxis.get_major_ticks():
			tick.label.set_fontsize(fontsize_labels)
		for tick in self.ax0.yaxis.get_major_ticks():
			tick.label.set_fontsize(fontsize_labels)

		self.ax0.set_ylabel(r'$Depth \, (km)$', fontsize = 9)
		self.ax0.set_xlabel(r'$Fraction \, (\%)$', fontsize = 9)
		self.ax0.set_xlim((0,100.0))
		self.ax0.set_ylim((MATE.lab / 1000.0) + 25.0, 0.0)

		crust_obj = patches.Rectangle((0,0) ,100.0,MATE.moho / 1000.0, color = '#b76314', alpha = 0.6,hatch = 'xxxx')
		ast_obj = patches.Rectangle((0,MATE.lab / 1000.0),100.0,1e5, color = '#b73114', alpha = 0.6,hatch = 'xx')
		self.ax0.add_patch(crust_obj)
		self.ax0.add_patch(ast_obj)

		with warnings.catch_warnings():
			warnings.simplefilter('ignore', UserWarning)
			self.fig.tight_layout()

		if method == 'draw':

			self.canvas.draw()

		elif method == 'save':

			#self.ax0.legend(fontsize = fontsize_labels, bbox_to_anchor=(0.5, 1.14), borderaxespad=0.1)
			plt.savefig(self.png_file_name + '_composition.png',dpi = 300,bbox_inches = "tight")
			os.system(self.commandmv + ' ' + self.png_file_name + '_composition.png ' + self.dir_path)

	def plot_melt_frac(self, method = None):

		if method == 'draw':
			self.ax_melt_frac = plt.subplot2grid((16,16),(0,3), rowspan = 16,colspan = 1, fig = self.fig)
			fontsize_labels = 8

		elif method == 'save':
			self.figure_comp_save = plt.figure(figsize = (2,7))
			fontsize_labels = 10
			self.ax_melt_frac = plt.subplot(111)

		self.ax_melt_frac.axhline(MATE.moho/1000.0, linestyle = '--',color = '#BA43C2', alpha = 0.85,linewidth = 2.5)
		self.ax_melt_frac.axhline(MATE.lab/1000.0, linestyle = '--', color = 'k', alpha = 0.85,linewidth = 2.5)
		for i in range(0,len(self.depth_comp_plot)):
			self.ax_melt_frac.axhline(self.depth_comp_plot[i]/1000.0,linewidth = 0.75, alpha = 0.5, color = 'k',linestyle = '-.')

		self.ax_melt_frac.plot(self.melt_mass_frac[self.idx_moho:]*100, self.depth[self.idx_moho:]/1e3, linestyle = '-', color = 'k', linewidth = 1.25)
		maxfrac = (np.amax(self.melt_mass_frac[self.idx_moho:]))
		if maxfrac >= 50.0:
			max_melt_frac_plot = 100.0
		elif (maxfrac < 50.0) and (maxfrac >= 30.0):
			max_melt_frac_plot = 50
		elif maxfrac <= 0.05:
			max_melt_frac_plot = 0.1
		else:
			max_melt_frac_plot = int(np.amax(self.melt_mass_frac[self.idx_moho:])*200)

		self.ax_melt_frac.set_xlim((0,max_melt_frac_plot))
		self.ax_melt_frac.set_ylim((MATE.lab / 1000.0) + 25.0, 0.0)

		if method == 'save':
			for tick in self.ax_melt_frac.yaxis.get_major_ticks():
				tick.label.set_fontsize(fontsize_labels)
			for tick in self.ax_melt_frac.yaxis.get_major_ticks():
				tick.label.set_fontsize(fontsize_labels)
		else:
			for tick in self.ax_melt_frac.xaxis.get_major_ticks():
				tick.label.set_fontsize(fontsize_labels)
			self.ax_melt_frac.set_yticklabels([])

		self.ax_melt_frac.set_xlabel('Melt Mass Frac %', fontsize = fontsize_labels)

		crust_obj = patches.Rectangle((0,0) ,100.0,MATE.moho / 1000.0, color = '#b76314', alpha = 0.6,hatch = 'xxxx')
		ast_obj = patches.Rectangle((0,MATE.lab / 1000.0),100.0,1e5, color = '#b73114', alpha = 0.6,hatch = 'xx')
		self.ax_melt_frac.add_patch(crust_obj)
		self.ax_melt_frac.add_patch(ast_obj)

		if method == 'draw':
			self.canvas.draw()
		elif method == 'save':
			plt.savefig(self.png_file_name + '_melt_frac.png',dpi = 300,bbox_inches = "tight")
			try:
				os.system(self.commandmv + ' ' + self.png_file_name + '_melt_frac.png ' + self.dir_path)
			except UserWarning:
				pass
	def plot_geotherm(self, method = None):

		if method == 'draw':
			self.ax3 = plt.subplot2grid((16,16),(0,4), rowspan = 16,colspan = 3, fig = self.fig)
			fontsize_labels = 8

		elif method == 'save':
			self.figure_geotherm_save = plt.figure(figsize = (3,7))
			self.ax3 = plt.subplot(111)
			fontsize_labels = 10

		self.T_list.append(self.T)
		for i in range(0,len(self.T_list)):
			self.ax3.plot(self.T_list[i] - 273.0, self.depth / 1000.0, linewidth = 2.0, color = 'k',label = 'Geotherm')
		self.ax3.invert_yaxis()
		self.ax3.set_xlabel(r'$Temperature \, (C^{\circ})$', fontsize = 9)
		if method == 'save':
			self.ax3.set_ylabel(r'$Depth \, (km)$',fontsize = fontsize_labels)
			for tick in self.ax3.yaxis.get_major_ticks():
				tick.label.set_fontsize(fontsize_labels)
			for tick in self.ax3.xaxis.get_major_ticks():
				tick.label.set_fontsize(fontsize_labels)
		self.ax3.axhline(MATE.moho/1000.0, linestyle = '--',color = '#BA43C2', alpha = 0.85,linewidth = 2.5)
		self.ax3.axhline(MATE.hr/1000.0, linestyle = '--', color = '#D83A3A', alpha = 0.85, label = 'Heat Producing Crust',linewidth = 2.5)
		self.ax3.axhline(MATE.lab/1000.0, linestyle = '--', color = 'k', alpha = 0.85,linewidth = 2.5)
		if self.depth_spinel != 0.0:
			self.ax3.axhline(self.depth_spinel/1000.0,linestyle = '--', color = '#7EB345', alpha = 0.85, label = 'sp-gt transition',linewidth = 2.5)
		if MATE.geotherm_asked == False:
			self.ax3.set_xlim((0,np.amax(self.T) - 273.0 + 50.0))
		elif MATE.geotherm_asked == True:
			self.ax3.set_xlim((0,MATE.geotherm_up))
		self.ax3.set_ylim((MATE.lab / 1000.0) + 25.0, 0.0)
		if method == 'draw':
			self.ax3.set_yticks([])
			for tick in self.ax3.xaxis.get_major_ticks():
				tick.label.set_fontsize(fontsize_labels)
		crust_obj = patches.Rectangle((0,0) ,3000,MATE.moho / 1000.0, color = '#b76314', alpha = 0.6,hatch = 'xxxx')
		self.ax3.add_patch(crust_obj)
		ast_obj = patches.Rectangle((0,MATE.lab / 1000.0),3000,1e5, color = '#b73114', alpha = 0.6,hatch = 'xx')
		self.ax3.add_patch(ast_obj)

		for i in range(0,len(self.depth_comp_plot)):
			self.ax3.axhline(self.depth_comp_plot[i]/1000.0,linewidth = 0.75, alpha = 0.5, color = 'k',linestyle = '-.')

		if self.xenolith_existence == True:
			self.depth_xen = []
			index_depth_xen = []
			t_exclude = []
			if MATE.z_xen_method == '0':
				for i in range(0,len(self.p_xen)):
					if self.p_xen[i] < np.amax(self.p):
						index_depth_xen.append(np.where(self.p == self.find_nearest(self.p,self.p_xen[i])))
						self.depth_xen.append(self.depth[index_depth_xen[i]][0]) #Finding the nearest value of depth equivalents of P values.
					else:
						t_exclude.append(i)

			t_exclude = t_exclude[::-1]
			self.T_xen_plot = np.asarray(self.T_xen)
			self.p_xen_plot = np.asarray(self.p_xen)
			for i in t_exclude:
				self.T_xen_plot = np.delete(self.T_xen_plot,i)
				self.p_xen_plot = np.delete(self.p_xen_plot,i)
			temp_err = np.ones(len(self.T_xen_plot)) * MATE.xen_temp_err
			pres_err = np.ones(len(self.p_xen_plot)) * MATE.xen_pressure_err

			#Finding the data-equivalent T-P

			self.P_equivalent = []
			self.T_equivalent = []
			for i in index_depth_xen:
				self.P_equivalent.append(self.p[i][0])
				self.T_equivalent.append(self.T[i][0])

			self.P_equivalent = np.asarray(self.P_equivalent)
			self.T_equivalent = np.asarray(self.T_equivalent)

			positive_pressure_diff_list = []
			negative_pressure_diff_list = []
			for i in range(0,len(pres_err)):

				positive_pressure = self.p_xen[i] + MATE.xen_pressure_err
				positive_pressure_depth = self.depth[np.where(self.p == self.find_nearest(self.p,positive_pressure))][0]
				positive_pressure_diff_list.append((positive_pressure_depth - self.depth_xen[i]) / 1e3)
				negative_pressure = self.p_xen[i] - MATE.xen_pressure_err
				negative_pressure_depth = self.depth[np.where(self.p == self.find_nearest(self.p,negative_pressure))][0]
				negative_pressure_diff_list.append((self.depth_xen[i] - negative_pressure_depth) / 1e3)

			self.ax3.errorbar(self.T_xen_plot-273.0,np.asarray(self.depth_xen) / 1000.0,yerr = [negative_pressure_diff_list,positive_pressure_diff_list],
			xerr = [temp_err,temp_err],fmt = 'o',color = '#bd3b24',markersize = 5,label = 'Xenolith Data',ecolor = 'k',elinewidth = 0.5,alpha = 0.6,
			markeredgecolor = 'k')

		#Amphibole stability line
		if MATE.amp_method == '0':
			self.ax3.axhline(self.depth[self.idx_amph_st]/1000.0, linestyle = '--', color = '#9c2fa8', alpha = 0.85, label = 'Amphibole Stability',linewidth = 2.5)

		if MATE.adiabat_selection != 0:
			if MATE.thermal_cond_method != '2':
				self.ax3.plot(np.array(self.T_adiabat_used) - 273.15, self.depth_adiabat_used, linestyle = '--', color = 'k')

				if len(self.idx_T_adiabat) > 0:
					self.ax3.axhline(self.depth[self.idx_T_adiabat]/1e3, linestyle = '--', color = '#551927', label = 'LAB',linewidth = 2.5)

		if MATE.thermal_cond_method != '2':

			self.ax3.text(50,(MATE.lab / 1000.0) + 10,r'$Q_{Moho}\, = $' + str('%4.2f' % self.moho_heat_flow) + r'$\, mW/m^2$',fontsize = 8,bbox=dict(facecolor='#8f8f8f', alpha=0.9))
			self.ax3.text(50,(MATE.lab / 1000.0) + 20,r'$Q_{LAB}\, = $' + str('%4.2f' % self.q[-1]) + r'$\, mW/m^2$',fontsize = 8,bbox=dict(facecolor='#8f8f8f', alpha=0.9))

		self.p_graphite = np.asarray([33.9608,62.9494]) / 10.0 #P graphite-diamond in GPa
		self.graphite_depth = []
		for i in range(0,len(self.p_graphite)):
			graphite_idx, = np.where(self.p == self.find_nearest(self.p,self.p_graphite[i]))
			graphite_idx = int(graphite_idx)
			self.graphite_depth.append(self.depth[graphite_idx]/1000.0)

		self.ax3.plot([649.890,1734.60],self.graphite_depth,color = '#2f9172',linewidth = 2.5,label = 'Graphite-Diamond')

		if self.solidus_dry_calculated == True:

			self.ax3.plot(self.T_dry_solidus - 273.15, self.depth/1e3, color = '#b51e1e',linewidth = 2, linestyle = '--', label = 'Dry Mantle Solidus')

		if self.solidus_wet_calculated == True:

			self.ax3.plot(self.T_wet_solidus - 273.15, self.depth/1e3, color = '#1e7ab5',linewidth = 2, linestyle = '-.', label = 'Wet Mantle Solidus')

		if self.solidus_carbon_calculated == True:

			self.ax3.plot(self.T_carbon_solidus - 273.15, self.depth/1e3, color = '#1d9a29',linewidth = 2, linestyle = ':', label = 'Carbonated-Wet Mantle Solidus')
			
		if MATE.solidus_wg_plot == True:
		
			self.Wallace_Green_1988_depth = []
			
			for i in range(0,len(self.Wallace_Green_1988_P)):
				idx_wg, = np.where(self.p == self.find_nearest(self.p,self.Wallace_Green_1988_P[i]))
				idx_wg = int(idx_wg)
				
				self.Wallace_Green_1988_depth.append(self.depth[idx_wg])
				
			self.Wallace_Green_1988_depth = np.array(self.Wallace_Green_1988_depth)
			
			self.ax3.plot(self.Wallace_Green_1988_T, self.Wallace_Green_1988_depth/1e3, color = '#730eaa',linewidth = 2, linestyle = '--', label = 'Wallace & Green (1988)')
			
		if MATE.solidus_foley_plot == True:
		
			self.Foley_2022_depth = []
			
			for i in range(0,len(self.Foley_2022_P)):
				idx_f, = np.where(self.p == self.find_nearest(self.p,self.Foley_2022_P[i]))
				idx_f = int(idx_f)
				
				self.Foley_2022_depth.append(self.depth[idx_f])
				
			self.Foley_2022_depth = np.array(self.Foley_2022_depth)
			
			self.ax3.plot(self.Foley_2022_T, self.Foley_2022_depth/1e3, color = '#fc7f03',linewidth = 2, linestyle = '--', label = 'Foley et al. (2022)')
			
		if MATE.solidus_green2010_plot == True:
		
			self.Green_2010_Depth = []
			
			for i in range(0,len(self.Green_2010_P)):
				idx_g, = np.where(self.p == self.find_nearest(self.p,self.Green_2010_P[i]))
				idx_g = int(idx_g)
				
				self.Green_2010_Depth.append(self.depth[idx_g])
				
			self.Green_2010_Depth = np.array(self.Green_2010_Depth)
			
			self.ax3.plot(self.Green_2010_T, self.Green_2010_Depth/1e3, color = '#3264a8',linewidth = 2, linestyle = '--', label = 'Green et al. (2010)')

		if method == 'draw':
			self.canvas.draw()
		elif method == 'save':
			#self.ax3.legend(fontsize = fontsize_labels, bbox_to_anchor=(0.8, 1.14), borderaxespad=0.1)
			plt.savefig(self.png_file_name + '_geotherm.png',dpi = 300,bbox_inches = "tight")
			os.system(self.commandmv + ' ' + self.png_file_name + '_geotherm.png ' + self.dir_path)

	def plot_water(self, method = None):

		if method == 'draw':
			self.ax4 = plt.subplot2grid((16,16),(0,7), rowspan = 16,colspan = 4, fig = self.fig)
			fontsize_labels = 8
		elif method == 'save':
			self.figure_water_save = plt.figure(figsize = (2,7))
			self.ax4 = plt.subplot(111)
			fontsize_labels = 10

		all_h2o = [self.h2o[self.idx_moho:],self.h2o_solid[self.idx_moho:],self.ol_h2o[self.idx_moho:],
		self.opx_h2o[self.idx_moho:],self.cpx_h2o[self.idx_moho:],self.gt_h2o[self.idx_moho:],self.px_h2o[self.idx_moho:]]
		if self.amp_method == 0:
			all_h2o.append(self.amp_h2o[self.idx_moho:])
		if self.pl_method == 0:
			all_h2o.append(self.pl_h2o[self.idx_moho:])
		if MATE.melt_method == '0':
			all_h2o.append(self.melt_h2o[self.idx_moho:])
		all_h2o = np.asarray(list(itertools.chain(*all_h2o)))
		self.maxwater = np.amax(all_h2o) + (np.amax(all_h2o) / 5.0)

		if MATE.sol_model_pref_select == 0:
			self.h2o_list.append(self.h2o_from_sol)
			self.h2o_max_list.append(self.h2o_from_sol)
			self.h2o_min_list.append(self.h2o_from_sol)
		else:
			self.h2o_list.append(self.h2o_solid)
			if MATE.w_inp_method == '0':
				if self.water_error_calculated == True:
					self.h2o_max_list.append(self.h2o_max)
					self.h2o_min_list.append(self.h2o_min)
			else:
				self.h2o_max_list.append(self.h2o_solid)
				self.h2o_min_list.append(self.h2o_solid)

		self.h2o_bulk_list.append(self.h2o)

		self.ol_h2o_list.append(self.ol_h2o)
		if MATE.w_inp_method == '0':
			if self.water_error_calculated == True:
				self.ol_h2o_max_list.append(self.ol_h2o_max)
				self.ol_h2o_min_list.append(self.ol_h2o_min)
		else:
			self.ol_h2o_max_list.append(self.ol_h2o)
			self.ol_h2o_min_list.append(self.ol_h2o)
		self.gt_h2o_list.append(self.gt_h2o)
		if MATE.w_inp_method == '0':
			if self.water_error_calculated == True:
				self.gt_h2o_max_list.append(self.gt_h2o_max)
				self.gt_h2o_min_list.append(self.gt_h2o_min)
		else:
			self.gt_h2o_max_list.append(self.gt_h2o)
			self.gt_h2o_min_list.append(self.gt_h2o)

		if MATE.amp_method == '0':
			self.amp_h2o_list.append(self.amp_h2o)
			if MATE.w_inp_method == '0':
				if self.water_error_calculated == True:
					self.amp_h2o_max_list.append(self.amp_h2o_max)
					self.amp_h2o_min_list.append(self.amp_h2o_min)
			else:
				self.amp_h2o_max_list.append(self.amp_h2o)
				self.amp_h2o_min_list.append(self.amp_h2o)

		if MATE.pl_method == '0':
			self.pl_h2o_list.append(self.pl_h2o)
			if MATE.w_inp_method == '0':
				if self.water_error_calculated == True:
					self.pl_h2o_max_list.append(self.pl_h2o_max)
					self.pl_h2o_min_list.append(self.pl_h2o_min)
			else:
				self.pl_h2o_max_list.append(self.pl_h2o)
				self.pl_h2o_min_list.append(self.pl_h2o)

		if MATE.sol_plot == True:

			self.check_sol_limit()

			sol_order_list = [np.mean(self.max_ol_h2o[self.idx_moho:]),np.mean(self.max_gt_h2o[self.idx_moho:])]
			sol_plot_order_list = [self.max_ol_h2o[self.idx_moho:],self.max_gt_h2o[self.idx_moho:]]
			color_order_list = ['#0b820f','#ad0f1f']

			index_first = sol_order_list.index(min(sol_order_list))
			index_last = sol_order_list.index(max(sol_order_list))

			if MATE.sol_plot_method == 0:

				self.ax4.fill_betweenx(self.depth[self.idx_moho:]/1000.0,sol_plot_order_list[index_first],0.0,color = color_order_list[index_first], alpha = 1.0)
				self.ax4.fill_betweenx(self.depth[self.idx_moho:]/1000.0,sol_plot_order_list[index_last],sol_plot_order_list[index_first],color = color_order_list[index_last], alpha = 1.0)

				if MATE.part_px_method == '0':

					sol_plot_3, = self.ax4.fill_betweenx(self.depth[self.idx_moho:]/1000.0,self.max_px_h2o[self.idx_moho:], sol_plot_order_list[index_last],color = '#f49b42', alpha = 1.0)

				elif MATE.part_px_method == '1':

					self.ax4.fill_betweenx(self.depth[self.idx_moho:]/1000.0,self.max_opx_h2o[self.idx_moho:],
					sol_plot_order_list[index_last],color = '#0b3c82', alpha = 1.0,label = 'Opx Solubility')
					self.ax4.fill_betweenx(self.depth[self.idx_moho:]/1000.0,self.max_cpx_h2o[self.idx_moho:],
					self.max_opx_h2o[self.idx_moho:],color = '#dbc14e', alpha = 1.0,label = 'Cpx Solubility')

			elif MATE.sol_plot_method == 1:

				self.ax4.plot(self.max_ol_h2o[self.idx_moho:], self.depth[self.idx_moho:] / 1000.0, linestyle = '--',color = '#0b820f',linewidth = 3, label = r'Ol Solubility')
				self.ax4.plot(self.max_gt_h2o[self.idx_moho:], self.depth[self.idx_moho:] / 1000.0, linestyle = '--',color = '#ad0f1f',linewidth = 3, label = r'Gt Solubility')

				if MATE.part_px_method == '0':

					self.ax4.plot(self.max_px_h2o[self.idx_moho:], self.depth[self.idx_moho:] / 1000.0, linestyle = '--',color = '#f49b42',linewidth = 3, label = r'Px Solubility')

				elif MATE.part_px_method == '1':

					self.ax4.plot(self.max_opx_h2o[self.idx_moho:], self.depth[self.idx_moho:] / 1000.0, linestyle = '--',color = '#0b3c82',linewidth = 3, label = r'Opx Solubility')
					self.ax4.plot(self.max_cpx_h2o[self.idx_moho:], self.depth[self.idx_moho:] / 1000.0, linestyle = '--',color = '#dbc14e',linewidth = 3, label = r'Cpx Solubility')


		for i in range(0,len(self.h2o_list)):

			if MATE.bulk_water_method == 0:
				water_plot_0, = self.ax4.plot(self.h2o_list[i][self.idx_moho:],self.depth[self.idx_moho:] / 1000.0, linestyle = '--', color = 'k', linewidth = 4, alpha = 0.85, label = r'$C_w^{Solid-Bulk}$')
				if MATE.w_inp_method == '0':
					if self.water_error_calculated == True:
						self.ax4.fill_betweenx(self.depth[self.idx_moho:],self.h2o_min_list[i][self.idx_moho:],self.h2o_max_list[i][self.idx_moho:],color = 'k',alpha = 0.3)

			water_plot_1, = self.ax4.plot(self.ol_h2o_list[i][self.idx_moho:],self.depth[self.idx_moho:] / 1000.0, color = '#0b820f', linewidth = 2.0, label = r'$C_w^{ol}$',path_effects=[pe.Stroke(linewidth=3.0, foreground='k'), pe.Normal()])
			if MATE.w_inp_method == '0':
				if self.water_error_calculated == True:
					self.ax4.fill_betweenx(self.depth[self.idx_moho:],self.ol_h2o_min_list[i][self.idx_moho:],self.ol_h2o_max_list[i][self.idx_moho:],color = '#0b820f',alpha = 0.3)
			water_plot_2, = self.ax4.plot(self.gt_h2o_list[i][self.idx_moho:],self.depth[self.idx_moho:] / 1000.0, color = '#ad0f1f', linewidth = 2.0, label = r'$C_w^{gt}$',path_effects=[pe.Stroke(linewidth=3.0, foreground='k'), pe.Normal()])
			if MATE.w_inp_method == '0':
				if self.water_error_calculated == True:
					self.ax4.fill_betweenx(self.depth[self.idx_moho:],self.gt_h2o_min_list[i][self.idx_moho:],self.gt_h2o_max_list[i][self.idx_moho:],color = '#ad0f1f',alpha = 0.3)

			if MATE.amp_method == '0':
				water_plot_5, = self.ax4.plot(self.amp_h2o_list[i][self.idx_moho:],self.depth[self.idx_moho:] / 1000.0, color = '#853de3', linewidth = 2.0, label = r'$C_w^{amp}$',path_effects=[pe.Stroke(linewidth=3.0, foreground='k'), pe.Normal()])
				if MATE.w_inp_method == '0':
					if self.water_error_calculated == True:
						self.ax4.fill_betweenx(self.depth[self.idx_moho:],self.amp_h2o_min_list[i][self.idx_moho:],self.amp_h2o_max_list[i][self.idx_moho:],color = '#853de3',alpha = 0.3)

			if MATE.pl_method == '0':
				water_plot_6, = self.ax4.plot(self.pl_h2o_list[i][self.idx_moho:],self.depth[self.idx_moho:] / 1000.0, color = '#c542f4', linewidth = 2.0, label = r'$C_w^{phlg}$',path_effects=[pe.Stroke(linewidth=3.0, foreground='k'), pe.Normal()])
				if MATE.w_inp_method == '0':
					if self.water_error_calculated == True:
						self.ax4.fill_betweenx(self.depth[self.idx_moho:],self.pl_h2o_min_list[i][self.idx_moho:],self.pl_h2o_max_list[i][self.idx_moho:],color = '#c542f4',alpha = 0.3)


		if MATE.sol_plot == True:
			if self.sol_error == True:
				if self.sol_error_ol == True:
					for idx in self.idx_ol_err_lst:
						self.ax4.plot(self.ol_h2o[idx],self.depth[idx] / 1000.0, marker = 'x',color = 'r',linewidth = 2.0)

				if MATE.part_px_method == '0':
					if self.sol_error_px == True:
						for idx in self.idx_px_err_lst:
							self.ax4.plot(self.px_h2o[idx],self.depth[idx] / 1000.0, marker = 'x',color = 'r',linewidth = 2.0)

				elif MATE.part_px_method == '1':
					if self.sol_error_opx == True:
						for idx in self.idx_opx_err_lst:
							self.ax4.plot(self.opx_h2o[idx],self.depth[idx] / 1000.0, marker = 'x',color = 'r',linewidth = 2.0)

					if self.sol_error_cpx == True:
						for idx in self.idx_cpx_err_lst:
							self.ax4.plot(self.cpx_h2o[idx],self.depth[idx] / 1000.0, marker = 'x',color = 'r',linewidth = 2.0)

				if self.sol_error_gt == True:
					for idx in self.idx_gt_err_lst:
						self.ax4.plot(self.gt_h2o[idx],self.depth[idx] / 1000.0, marker = 'x',color = 'r',linewidth = 2.0)

		if MATE.part_px_method == '1':

			self.opx_h2o_list.append(self.opx_h2o)
			if MATE.w_inp_method == '0':
				if self.water_error_calculated == True:
					self.opx_h2o_max_list.append(self.opx_h2o_max)
					self.opx_h2o_min_list.append(self.opx_h2o_min)
			else:
				self.opx_h2o_max_list.append(self.opx_h2o)
				self.opx_h2o_min_list.append(self.opx_h2o)

			self.cpx_h2o_list.append(self.cpx_h2o)
			if MATE.w_inp_method == '0':
				if self.water_error_calculated == True:
					self.cpx_h2o_max_list.append(self.cpx_h2o_max)
					self.cpx_h2o_min_list.append(self.cpx_h2o_min)
			else:
				self.cpx_h2o_max_list.append(self.cpx_h2o)
				self.cpx_h2o_min_list.append(self.cpx_h2o)

			for i in range(0,len(self.opx_h2o_list)):
				water_plot_3, = self.ax4.plot(self.opx_h2o_list[i][self.idx_moho:],self.depth[self.idx_moho:] / 1000.0, color = '#0b3c82', linewidth = 2.0, label = r'$C_w^{opx}$',
				path_effects=[pe.Stroke(linewidth=3.0, foreground='k'), pe.Normal()])
				if MATE.w_inp_method == '0':
					if self.water_error_calculated == True:
						self.ax4.fill_betweenx(self.depth[self.idx_moho:],self.opx_h2o_min_list[i][self.idx_moho:],self.opx_h2o_max_list[i][self.idx_moho:],color = '#0b3c82',alpha = 0.3)
				water_plot_4, = self.ax4.plot(self.cpx_h2o_list[i][self.idx_moho:],self.depth[self.idx_moho:] / 1000.0, color = '#dbc14e', linewidth = 2.0, label = r'$C_w^{cpx}$',
				path_effects=[pe.Stroke(linewidth=3.0, foreground='k'), pe.Normal()])
				if MATE.w_inp_method == '0':
					if self.water_error_calculated == True:
						self.ax4.fill_betweenx(self.depth[self.idx_moho:],self.cpx_h2o_min_list[i][self.idx_moho:],self.cpx_h2o_max_list[i][self.idx_moho:],color = '#dbc14e',alpha = 0.3)

		else:
			self.px_h2o_list.append(self.px_h2o)
			if MATE.w_inp_method == '0':
				if self.water_error_calculated == True:
					self.px_h2o_max_list.append(self.px_h2o_max)
					self.px_h2o_min_list.append(self.px_h2o_min)
			else:
				self.px_h2o_max_list.append(self.px_h2o)
				self.px_h2o_min_list.append(self.px_h2o)

			for i in range(0,len(self.px_h2o_list)):
				water_plot_3, = self.ax4.plot(self.px_h2o_list[i][self.idx_moho:],self.depth[self.idx_moho:] / 1000.0, color = '#f49b42', linewidth = 2.0, label = r'$C_w^{px}$',
				path_effects=[pe.Stroke(linewidth=2.5, foreground='k'), pe.Normal()])
				if MATE.w_inp_method == '0':
					if self.water_error_calculated == True:
						self.ax4.fill_betweenx(self.depth[self.idx_moho:],self.px_h2o_min_list[i][self.idx_moho:],self.px_h2o_max_list[i][self.idx_moho:],color = '#f49b42',alpha = 0.3)

		if MATE.melt_method == '0':

			self.melt_h2o_list.append(self.melt_h2o)
			water_plot_5, = self.ax4.plot(self.melt_h2o_list[i][self.idx_moho:],self.depth[self.idx_moho:] / 1000.0, color = '#f45328', linewidth = 2.0, label = r'$C_w^{melt}$',
			path_effects=[pe.Stroke(linewidth=2.5, foreground='k'), pe.Normal()])

			water_plot_6, = self.ax4.plot(self.h2o_bulk_list[i][self.idx_moho:],self.depth[self.idx_moho:] / 1000.0, linestyle = '-.', color = '#37bb9c', linewidth = 4, alpha = 0.85, label = r'$C_w^{Bulk}$')

		self.ax4.axhline(MATE.moho/1000.0, linestyle = '--',color = '#BA43C2', alpha = 0.85,linewidth = 2.5)
		self.ax4.axhline(MATE.lab/1000.0, linestyle = '--', color = 'k', alpha = 0.85,linewidth = 2.5)
		self.ax4.axhline(self.depth_spinel / 1000.0, linestyle = '--', color = '#7EB345', alpha = 0.85,linewidth = 2.5)

		if MATE.water_file_read == True:
			color_list_mineral = ['#0b820f','#0b3c82','#dbc14e','#ad0f1f']
			marker_list_mineral = ['o','^','^','s']
			water_depth = []
			if MATE.add_water_method == 0:
				for i in range(0,len(MATE.P_depth_water)):
					water_csv_idx, = np.where(self.p == self.find_nearest(self.p,MATE.P_depth_water[i]))
					water_csv_idx = int(water_csv_idx)
					water_depth.append(self.depth[water_csv_idx]/1000.0)
			else:
				water_depth = MATE.P_depth_water
			for i in range(0,len(MATE.H_water)):
				if MATE.water_mineral[i] == 'ol':
					self.ax4.errorbar([MATE.H_water[i]],[water_depth[i]],xerr = [[MATE.H_water_err[i]],[MATE.H_water_err[i]]],fmt = marker_list_mineral[0],capthick = 2, ecolor = color_list_mineral[0],color = color_list_mineral[0])
				elif MATE.water_mineral[i] == 'opx':
					self.ax4.errorbar([MATE.H_water[i]],[water_depth[i]],xerr = [[MATE.H_water_err[i]],[MATE.H_water_err[i]]],fmt = marker_list_mineral[1],capthick = 2, ecolor = color_list_mineral[1],color = color_list_mineral[1])
				elif MATE.water_mineral[i] == 'cpx':
					self.ax4.errorbar([MATE.H_water[i]],[water_depth[i]],xerr = [[MATE.H_water_err[i]],[MATE.H_water_err[i]]],fmt = marker_list_mineral[2],capthick = 2, ecolor = color_list_mineral[2],color = color_list_mineral[2])
				elif MATE.water_mineral[i] == 'gt':
					self.ax4.errorbar([MATE.H_water[i]],[water_depth[i]],xerr = [[MATE.H_water_err[i]],[MATE.H_water_err[i]]],fmt = marker_list_mineral[3],capthick = 2, ecolor = color_list_mineral[3],color = color_list_mineral[3])
				else:
					self.ax4.errorbar([MATE.H_water[i]],[water_depth[i]],xerr = [MATE.H_water_err[i],MATE.H_water_err[i]],fmt = 'o',capthick = 2, ecolor = 'k',color = 'k')

		handle_list = [water_plot_0,water_plot_1,water_plot_2]
		if MATE.part_px_method == '1':
			handle_list.append(water_plot_3)
			handle_list.append(water_plot_4)
		elif MATE.part_px_method == '0':
			handle_list.append(water_plot_3)
		if MATE.amp_method == '0':
			handle_list.append(water_plot_5)
		if MATE.pl_method == '0':
			handle_list.append(water_plot_6)
		for tick in self.ax4.xaxis.get_major_ticks():
			tick.label.set_fontsize(fontsize_labels)
		if method == 'draw':
			self.ax4.set_yticks([])
		if method == 'save':
			self.ax4.set_ylabel(r'$Depth \, (km)$',fontsize = fontsize_labels)
			#self.ax4.legend(fontsize = fontsize_labels,bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.1,handles = handle_list)
			for tick in self.ax4.yaxis.get_major_ticks():
				tick.label.set_fontsize(fontsize_labels)

		if MATE.melt_method == '0':
			self.ax4.set_xlim((1,self.maxwater))
			self.ax4.set_xscale('log')
		else:
			self.ax4.set_xlim((0,MATE.waterplotlim_up))

		self.ax4.set_xlabel(r'$C_w \, (H_2O \, ppm \, wt)$', fontsize = fontsize_labels)
		self.ax4.set_ylim((MATE.lab / 1000.0) + 25.0, 0.0)
		crust_obj = patches.Rectangle((0,0) ,1e10,MATE.moho / 1000.0, color = '#b76314', alpha = 0.6,hatch = 'xxxx')
		ast_obj = patches.Rectangle((0,MATE.lab / 1000.0),1e10,1e5, color = '#b73114', alpha = 0.6,hatch = 'xx')
		self.ax4.add_patch(crust_obj)
		self.ax4.add_patch(ast_obj)

		for i in range(0,len(self.depth_comp_plot)):
			self.ax4.axhline(self.depth_comp_plot[i]/1000.0,linewidth = 0.75, alpha = 0.5, color = 'k',linestyle = '-.')

		if MATE.melt_method != '0':
			if MATE.sol_plot_scale_method == 1:
				self.ax4.set_xscale('log')
				self.ax4.set_xlim((1e-1,1e4))

		if (MATE.sol_method == 1) or (MATE.sol_method == 2):

			QMessageBox.about(self,'May take time','Solublities are calculated, press OK to continue.')

		if method == 'draw':
			self.canvas.draw()
		elif method == 'save':
			plt.savefig(self.png_file_name + '_water.png',dpi = 300,bbox_inches = "tight")
			os.system(self.commandmv + ' ' + self.png_file_name + '_water.png ' + self.dir_path)

	def plot_conductivity(self, method = None, boundaries = None):

		if boundaries == False:
			self.last_draw_method = 0
		else:
			self.last_draw_method = 1

		if (method == 'draw') and (boundaries == False):

			self.bulk_cond_min_list.append(self.bulk_cond_min)
			self.bulk_cond_max_list.append(self.bulk_cond_max)
			self.bulk_cond_list.append(self.bulk_cond)
			self.linestyle_list.append(MATE.condlinestyle_list[MATE.condlinestyle_select])
			self.linewidth_list.append(MATE.condlinewidth)

		if len(self.bulk_cond_list) <= 8:
			self.color_list_cond = ['#179c9a','#CB3026','#27A411','#B926CB','#D09605','#05D0AE','#D005CA','#050ED0']
		else:
			r_color = lambda: random.randint(0,255)
			self.color_list_cond.append('#%02X%02X%02X' % (r_color(),r_color(),r_color()))

		if method == 'draw':
			self.ax5 = plt.subplot2grid((16,16),(0,11), rowspan = 16,colspan = 5, fig = self.fig)
			fontsize_labels = 8
		elif method == 'save':
			self.figure_cond_save = plt.figure(figsize = (4,7))
			self.ax5 = plt.subplot(111)
			fontsize_labels = 10

		if MATE.bounds_select !=0:

			if MATE.bounds_select == 1:

				self.phase_mixing_function(method = 1, melt_method = MATE.phs_melt_mix_method,indexing_method = 'array', sol_idx = None)
				extremal_lower = self.bulk_cond
				self.phase_mixing_function(method = 2, melt_method = MATE.phs_melt_mix_method,indexing_method = 'array', sol_idx = None)
				extremal_upper = self.bulk_cond

			elif MATE.bounds_select == 2:

				self.phase_mixing_function(method = 3, melt_method = MATE.phs_melt_mix_method,indexing_method = 'array', sol_idx = None)
				extremal_lower = self.bulk_cond
				self.phase_mixing_function(method = 4, melt_method = MATE.phs_melt_mix_method,indexing_method = 'array', sol_idx = None)
				extremal_upper = self.bulk_cond

			self.ax5.fill_betweenx(self.depth[self.idx_moho:]/1000.0, 1.0/extremal_upper[self.idx_moho:],1.0/extremal_lower[self.idx_moho:], color = '#5b5e5d',alpha = 0.50)
			self.phase_mixing_function(method = MATE.phs_mix_method, melt_method = MATE.phs_melt_mix_method,indexing_method = 'array', sol_idx = None) #reinstating the original conductivity

		if (self.ModEM_dat_read == True) and (self.ModEM_model_read == True):

			if MATE.ModEM_data_submit == True:
				if (MATE.curve_method == 0) or (MATE.curve_method == 1):
					self.ax5.plot(MATE.res_profile_plot_list[0],MATE.z_depth_plot_list[0], linewidth = 2, color = '#ce0808')
					if MATE.mt_model_errs == True:
						self.ax5.fill_betweenx(MATE.z_depth_plot_list[0],MATE.mt_model_min,MATE.mt_model_max,color = '#ce0808',alpha = 0.3)

				elif MATE.curve_method == 2:
					for k in range(0,len(MATE.res_profile_plot_list)):
						self.ax5.plot(MATE.res_profile_plot_list[k],MATE.z_depth_plot_list[k], linewidth = 2, color = '#b3bcc9',alpha = 0.3)

		if (self.csv_MT_read == True):

			self.color_list_csv = ['#cf56d5','#b10000','k','#d08300', '#30c245','#468afe','#5fb9da','#ffcf00']
			self.marker_list_csv = ['-','-','-','-','-','-','-','-','-']
			if len(MATE.z_depth_plot_list) > 8:
				r_color = lambda: random.randint(0,255)
				for i in range(0,len(MATE.z_depth_plot_list)):
					self.color_list_csv.append('#%02X%02X%02X' % (r_color(),r_color(),r_color()))
					if i % 3 == 0:
						self.marker_list_csv.append('-,')
					else:
						self.marker_list_csv.append('--')
			for csvmt in range(0,len(MATE.res_profile_plot_list)):
				self.ax5.fill_betweenx(MATE.z_depth_plot_list[csvmt],MATE.res_profile_min_plot_list[csvmt],MATE.res_profile_max_plot_list[csvmt],color = self.color_list_csv[csvmt],alpha = 0.3)
				self.ax5.plot(MATE.res_profile_plot_list[csvmt],MATE.z_depth_plot_list[csvmt],self.marker_list_csv[csvmt],linewidth = 2.0,color = self.color_list_csv[csvmt])

		if boundaries == False:
			for i in range(0,len(self.bulk_cond_min_list)):
				if MATE.condrange_method == 0:
					self.ax5.fill_betweenx(self.depth[self.idx_moho:]/1000.0,1.0/self.bulk_cond_min_list[i][self.idx_moho:],1.0/self.bulk_cond_max_list[i][self.idx_moho:], color = self.color_list_cond[i],alpha = 0.25)
				self.ax5.plot(1.0/self.bulk_cond_list[i][self.idx_moho:],self.depth[self.idx_moho:]/1000.0,color = self.color_list_cond[i],linestyle = self.linestyle_list[i],alpha = 0.9,linewidth = self.linewidth_list[i])
		else:
			if MATE.condrange_method == 0:
				self.ax5.fill_betweenx(self.depth[self.idx_moho:]/1000.0, 1.0/self.upper_uncertainty_cond[self.idx_moho:],1.0/self.lower_uncertainty_cond[self.idx_moho:], color = self.color_list_cond[0],alpha = 0.25)
			self.ax5.fill_betweenx(self.depth[self.idx_moho:]/1000.0, 1.0/self.upper_bound_cond[self.idx_moho:],1.0/self.lower_bound_cond[self.idx_moho:], color = self.color_list_cond[0],alpha = 0.25)

		self.ax5.set_xlabel(r'$Resistivity \, (\Omega m)$', fontsize = 9)
		self.ax5.set_ylim((MATE.lab / 1000.0) + 25.0, 0.0)
		self.ax5.set_xlim((10**MATE.condplotlim_down,10**MATE.condplotlim_up))
		self.ax5.set_xscale('log')
		if method == 'draw':
			self.ax5.set_yticks([])


		if method == 'save':
			self.ax5.set_ylabel(r'$Depth \, (km)$',fontsize = 10)
			#self.ax5.legend(fontsize = fontsize_labels,bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.1)
			for tick in self.ax5.yaxis.get_major_ticks():
				tick.label.set_fontsize(fontsize_labels)

		for tick in self.ax5.xaxis.get_major_ticks():
			tick.label.set_fontsize(fontsize_labels)

		self.ax5.axhline(MATE.moho/1000.0, linestyle = '--',color = '#BA43C2', alpha = 0.85,linewidth = 2.5)
		self.ax5.axhline(MATE.lab/1000.0, linestyle = '--', color = 'k', alpha = 0.85,linewidth = 2.5)
		self.ax5.axhline(self.depth_spinel / 1000.0, linestyle = '--', color = '#7EB345', alpha = 0.85,linewidth = 2.5)

		if MATE.trange_method == 0:

			index_t_max_ol, =  np.where(self.T == self.find_nearest(self.T[self.idx_moho:],MATE.t_max[0][MATE.ol_cond_selection]))
			index_t_max_ol = int(index_t_max_ol)
			index_t_min_ol, =  np.where(self.T == self.find_nearest(self.T[self.idx_moho:],MATE.t_min[0][MATE.ol_cond_selection]))
			index_t_min_ol = int(index_t_min_ol)

			index_t_max_opx, =  np.where(self.T == self.find_nearest(self.T[self.idx_moho:],MATE.t_max[1][MATE.opx_cond_selection]))
			index_t_max_opx = int(index_t_max_opx)
			index_t_min_opx, =  np.where(self.T == self.find_nearest(self.T[self.idx_moho:],MATE.t_min[1][MATE.opx_cond_selection]))
			index_t_min_opx = int(index_t_min_opx)

			index_t_max_cpx, =  np.where(self.T == self.find_nearest(self.T[self.idx_moho:],MATE.t_max[2][MATE.cpx_cond_selection]))
			index_t_max_cpx = int(index_t_max_cpx)
			index_t_min_cpx, =  np.where(self.T == self.find_nearest(self.T[self.idx_moho:],MATE.t_min[2][MATE.cpx_cond_selection]))
			index_t_min_cpx = int(index_t_min_cpx)

			index_t_max_gt, =  np.where(self.T == self.find_nearest(self.T[self.idx_moho:],MATE.t_max[3][MATE.gt_cond_selection]))
			index_t_max_gt = int(index_t_max_gt)
			index_t_min_gt, =  np.where(self.T == self.find_nearest(self.T[self.idx_moho:],MATE.t_min[3][MATE.gt_cond_selection]))
			index_t_min_gt = int(index_t_min_gt)

			ol_t_object = patches.Rectangle((1e1,self.depth[index_t_min_ol]/1000.0),200,
			(self.depth[index_t_max_ol] - self.depth[index_t_min_ol]) / 1000.0 , color = '#0b820f', alpha = 1)
			self.ax3.add_patch(ol_t_object)

			opx_t_object = patches.Rectangle((1e-5,self.depth[index_t_min_opx]/1000.0), 150,
			(self.depth[index_t_max_opx] - self.depth[index_t_min_opx]) / 1000.0 , color = '#0b3c82', alpha = 1)
			self.ax3.add_patch(opx_t_object)

			cpx_t_object = patches.Rectangle((1e-5,self.depth[index_t_min_cpx]/1000.0), 100,
			(self.depth[index_t_max_cpx] - self.depth[index_t_min_cpx]) / 1000.0 , color = '#dbc14e', alpha =1)
			self.ax3.add_patch(cpx_t_object)

			gt_t_object = patches.Rectangle((1e-5,self.depth[index_t_min_gt]/1000.0), 50	,
			(self.depth[index_t_max_gt] - self.depth[index_t_min_gt]) / 1000.0 , color = '#ad0f1f', alpha = 1)
			self.ax3.add_patch(gt_t_object)

		crust_obj = patches.Rectangle((1e-5,0) ,1e10,MATE.moho / 1000.0, color = '#b76314', alpha = 0.6,hatch = 'xxxx')
		ast_obj = patches.Rectangle((1e-5,MATE.lab / 1000.0),1e10,1e5, color = '#b73114', alpha = 0.6,hatch = 'xx')
		self.ax5.add_patch(crust_obj)
		self.ax5.add_patch(ast_obj)

		for i in range(0,len(self.depth_comp_plot)):
			self.ax5.axhline(self.depth_comp_plot[i]/1000.0,linewidth = 0.75, alpha = 0.5, color = 'k',linestyle = '-.')

		if method == 'draw':
			self.ax5.text(50,-1000,'Hello.',fontsize = 8, color = 'k')
			self.canvas.draw()

		elif method == 'save':
			plt.savefig(self.png_file_name + '_conductivity.png',dpi = 300,bbox_inches = "tight")
			os.system(self.commandmv + ' ' + self.png_file_name + '_conductivity.png ' + self.dir_path)

	def plot_legend(self):

		plt.ion()
		fig_legend = plt.figure(figsize = (5,5))
		ax_legend = plt.subplot(111)
		ax_legend.grid(None)
		ax_legend.axis('off')
		ax_legend.text(0.05,1.05,'--Composition--', fontweight = 'semibold')
		ax_legend.add_patch(patches.Rectangle((0.01,0.95),0.05,0.05,color = '#0b820f'))
		ax_legend.text(0.08,0.96, 'Olivine')
		ax_legend.add_patch(patches.Rectangle((0.01,0.89),0.05,0.05,color = '#0b3c82'))
		ax_legend.text(0.08,0.90, 'Orthopyroxene')
		ax_legend.add_patch(patches.Rectangle((0.01,0.83),0.05,0.05,color = '#dbc14e'))
		ax_legend.text(0.08,0.84, 'Clinopyroxene')
		ax_legend.add_patch(patches.Rectangle((0.01,0.77),0.05,0.05,color = '#ad0f1f'))
		ax_legend.text(0.08,0.78, 'Garnet')
		ax_legend.add_patch(patches.Rectangle((0.01,0.71),0.05,0.05,color = '#0fadad'))
		ax_legend.text(0.08,0.72, 'Spinel-Chromite')
		ax_legend.add_patch(patches.Rectangle((0.01,0.65),0.05,0.05,color = '#2dff5b'))
		ax_legend.text(0.08,0.66, 'Phlogopite')
		ax_legend.add_patch(patches.Rectangle((0.01,0.59),0.05,0.05,color = '#853de3'))
		ax_legend.text(0.08,0.60, 'Amphibole')

		ax_legend.text(0.7,1.05,'--Lines--', fontweight = 'semibold')
		ax_legend.plot([0.5,0.65],[0.98,0.98], color = '#BA43C2', linewidth = 2.5, linestyle = '--')
		ax_legend.text(0.67,0.965, 'MOHO')
		ax_legend.plot([0.5,0.65],[0.9,0.9], color = 'k', linewidth = 2.5, linestyle = '--')
		ax_legend.text(0.67,0.885, 'Max. Depth')
		ax_legend.plot([0.5,0.65],[0.82,0.82], color = '#7EB345', linewidth = 2.5, linestyle = '--')
		ax_legend.text(0.67,0.805, 'Sp-gt transition.')
		ax_legend.plot([0.5,0.65],[0.74,0.74], color = '#D83A3A', linewidth = 2.5, linestyle = '--')
		ax_legend.text(0.67,0.725, 'Upper-crust')
		ax_legend.plot([0.5,0.65],[0.66,0.66], color = 'k', linewidth = 0.75, linestyle = '-.')
		ax_legend.text(0.67,0.645, 'Composition Layer Mark')

		ax_legend.text(0.05,0.45, '--Geotherm Figure--', fontweight = 'semibold')
		ax_legend.plot([0.0,0.15], [0.40,0.4] , color = 'k', linestyle = '-', linewidth = 1)
		ax_legend.text(0.17,0.385, 'Conductive Geotherm')
		ax_legend.plot([0.0,0.15], [0.32,0.32] , color = 'k', linestyle = '--', linewidth = 1)
		ax_legend.text(0.17,0.305, 'Adiabat')
		ax_legend.plot([0.08], [0.24] , 'o', color = '#bd3b24')
		ax_legend.text(0.17,0.225, 'Xenolith Data')
		ax_legend.text(0.08,0.15, '--Water Figure--', fontweight = 'semibold')
		ax_legend.plot([0.0,0.15], [0.07,0.07] , color = 'k', linestyle = '--', linewidth = 2.5)
		ax_legend.text(0.17,0.055, 'Bulk Water - Solid')
		ax_legend.set_xlim((0,1))
		ax_legend.set_ylim((0,1))
		plt.show()
		plt.ioff()

	def generate_Tcondplot(self):

		if (self.data_existence == True) and (self.geotherm_existence == True):
			plt.ion()
			genax_fig = plt.figure(figsize = (10,7))
			genax = plt.subplot(111)
			water_gen = [0,100.0]
			markerlist = ['--','-']
			labelz = ['Dry','100ppm']

			for i in range(0,2):

				self.ol_h2o = (np.ones(len(self.T)) * water_gen[i])
				self.opx_h2o = (np.ones(len(self.T)) * water_gen[i])
				self.cpx_h2o = (np.ones(len(self.T)) * water_gen[i])
				self.px_h2o = (np.ones(len(self.T)) * water_gen[i])
				self.gt_h2o = (np.ones(len(self.T)) * water_gen[i])

				self.calculate_ol_conductivity(method = 'array', sol_idx = None)
				self.calculate_opx_conductivity(method = 'array', sol_idx = None)
				self.calculate_cpx_conductivity(method = 'array', sol_idx = None)
				self.calculate_gt_conductivity(method = 'array', sol_idx = None)
				self.calculate_sp_chr_conductivity(method = 'array', sol_idx = None)
				self.calculate_melt_conductivity(method = 'array', sol_idx = None)


				genax.plot(10000.0/self.T[self.idx_moho:], self.ol_cond[self.idx_moho:],markerlist[i],color = '#0b820f',label = 'ol ' + MATE.name[0][MATE.ol_cond_selection] + '  ' + labelz[i],lw = 1.5 )
				genax.plot(10000.0/self.T[self.idx_moho:], self.opx_cond[self.idx_moho:],markerlist[i],color = '#0b3c82',label = 'opx ' + MATE.name[1][MATE.opx_cond_selection] + '  ' + labelz[i],lw = 1.5)
				genax.plot(10000.0/self.T[self.idx_moho:], self.cpx_cond[self.idx_moho:],markerlist[i],color = '#dbc14e',label = 'cpx ' + MATE.name[2][MATE.cpx_cond_selection] + '  ' + labelz[i],lw = 1.5)
				genax.plot(10000.0/self.T[self.idx_moho:], self.gt_cond[self.idx_moho:],markerlist[i],color = '#ad0f1f',label = 'gt ' + MATE.name[3][MATE.gt_cond_selection] + '  ' + labelz[i],lw = 1.5)

			if self.amp_method == '0':
				self.calculate_amp_conductivity()
				genax.plot(10000.0/self.T[self.idx_moho:], self.amp_cond[self.idx_moho:],markerlist[1],color = '#e07e14',label = 'amp' + MATE.name[4][MATE.amp_cond_selection],lw = 1.5 )
			if self.pl_method == '0':
				self.calculate_pl_conductivity()
				genax.plot(10000.0/self.T[self.idx_moho:], self.pl_cond[self.idx_moho:],markerlist[1],color = '#c952de',label = 'phlg' + MATE.name[5][MATE.pl_cond_selection],lw = 1.5 )

			genax.grid(which = 'both')
			genax.set_yscale('log')
			genax.set_ylabel(r'$Conductivity \, (S/m)$')
			genax.set_xlabel(r'$10^{3}/T \, (K^{-1})$')
			genax.set_ylim((10**-8,1e0))
			genax.set_xlim((7, 16))
			genax.legend(fontsize = 11)
			plt.show()

			#recalculate everything
			self.adjust_composition()
			self.calculate_pressure()
			if MATE.thermal_cond_method != '2':
				self.calculate_geotherm()
			else:
				self.load_input_geotherm()
			self.mineral_stabilities()
			self.calculate_water(method = 'array', idx = None)
			if MATE.sol_plot == True:
				self.solubility_ol()
				self.solubility_partitioning()

			plt.ioff()
		else:
			QMessageBox.about(self,'Input Missing!','You have to input composition and calculate geotherm first to continue.')



	def generate_composition_plot(self):

		if MATE.lodge_check == False:
			QMessageBox.about(self,'Input Missing!','You have to input a composition file first to continue.')
		else:
			plt.ion()
			self.figure_other_comp = plt.figure(figsize = (16,16))
			fontsize_labels = 8
			#Mg plot
			self.ax_mg = plt.subplot2grid((16,16),(0,0), rowspan = 16,colspan = 3, fig = self.figure_other_comp)

			self.ax_mg.plot((1.0 - self.fe_ol[self.idx_moho:]) * 100.0, self.depth[self.idx_moho:] / 1000.0,color = '#0b820f', linewidth = 1.5, linestyle = '--',label = 'Ol')
			self.ax_mg.plot((1.0 - self.fe_opx[self.idx_moho:]) * 100.0, self.depth[self.idx_moho:] / 1000.0,color = '#0b3c82', linewidth = 1.5, linestyle = '--',label = 'Opx')
			self.ax_mg.plot((1.0 - self.fe_cpx[self.idx_moho:]) * 100.0, self.depth[self.idx_moho:] / 1000.0,color = '#dbc14e', linewidth = 1.5, linestyle = '--', label = 'Cpx')
			self.ax_mg.plot((1.0 - self.fe_gt[self.idx_moho:]) * 100.0, self.depth[self.idx_moho:] / 1000.0,color = '#ad0f1f', linewidth = 1.5, linestyle = '--', label = 'Gt')

			self.ax_mg.axhline(MATE.moho/1000.0, linestyle = '--',color = '#BA43C2', alpha = 0.85,linewidth = 2.5,label = 'Moho')
			self.ax_mg.axhline(MATE.lab/1000.0, linestyle = '--', color = 'k', alpha = 0.85,linewidth = 2.5)
			self.ax_mg.set_xlabel('')

			arrays_fe = [np.amin((1.0 - self.fe_ol[self.idx_moho:]) * 100.0),np.amin((1.0 - self.fe_opx[self.idx_moho:]) * 100.0),
			np.amin((1.0 - self.fe_cpx[self.idx_moho:]) * 100.0),np.amin((1.0 - self.fe_gt[self.idx_moho:]) * 100.0)]

			self.ax_mg.set_xlim((min(arrays_fe) - 5.0),95.0)
			self.ax_mg.set_ylim((MATE.lab / 1000.0) + 25.0, 0.0)
			self.ax_mg.set_xlabel(r'$Mg\#$',fontsize = 9)
			self.ax_mg.set_ylabel('Depth [km]')
			self.ax_mg.legend(fontsize = fontsize_labels, bbox_to_anchor=(0.8, 1.14), borderaxespad=0.1)

			crust_obj = patches.Rectangle((0,0) ,100.0,MATE.moho / 1000.0, color = '#b76314', alpha = 0.6,hatch = 'xxxx')
			ast_obj = patches.Rectangle((0,MATE.lab / 1000.0),100.0,1e5, color = '#b73114', alpha = 0.6,hatch = 'xx')
			self.ax_mg.add_patch(crust_obj)
			self.ax_mg.add_patch(ast_obj)

			#Al2o3 plot
			self.ax_al = plt.subplot2grid((16,16),(0,3), rowspan = 16,colspan = 3, fig = self.figure_other_comp)

			self.ax_al.plot(self.al_opx[self.idx_moho:], self.depth[self.idx_moho:] / 1000.0, color = '#083fb5', linewidth = 1.5)
			self.ax_al.set_xlim((0.0,6.5))
			self.ax_al.set_xlabel(r'$Al_2O_3 \, in \, opx$ [wt%]',fontsize = 9)
			self.ax_al.set_ylim((MATE.lab / 1000.0) + 25.0, 0.0)

			self.ax_al.axhline(MATE.moho/1000.0, linestyle = '--',color = '#BA43C2', alpha = 0.85,linewidth = 2.5)
			self.ax_al.axhline(MATE.lab/1000.0, linestyle = '--', color = 'k', alpha = 0.85,linewidth = 2.5)

			for tick in self.ax_al.xaxis.get_major_ticks():
				tick.label.set_fontsize(fontsize_labels)

			self.ax_al.set_yticklabels([])

			crust_obj = patches.Rectangle((0,0) ,300.0,MATE.moho / 1000.0, color = '#b76314', alpha = 0.6,hatch = 'xxxx')
			ast_obj = patches.Rectangle((0,MATE.lab / 1000.0),300.0,1e5, color = '#b73114', alpha = 0.6,hatch = 'xx')
			self.ax_al.add_patch(crust_obj)
			self.ax_al.add_patch(ast_obj)

			#TiO2 Ol plot

			self.ax_ti = plt.subplot2grid((16,16),(0,6), rowspan = 16,colspan = 3, fig = self.figure_other_comp)

			self.ax_ti.plot(self.ti_ol[self.idx_moho:], self.depth[self.idx_moho:] / 1000.0, color = '#083fb5', linewidth = 1.5)
			corr = [1,10,100,1000,10000]
			ti_max_corr_idx = [np.amax(self.ti_ol[self.idx_moho:])*item%1 for item in corr].index(0.0)
			ti_max = 10**-(ti_max_corr_idx-1)
			self.ax_ti.set_xlim((0.0,ti_max))
			self.ax_ti.set_xlabel(r'$TiO_2 \, in \, ol$ [wt%]',fontsize = 9)
			self.ax_ti.set_ylim((MATE.lab / 1000.0) + 25.0, 0.0)

			self.ax_ti.axhline(MATE.moho/1000.0, linestyle = '--',color = '#BA43C2', alpha = 0.85,linewidth = 2.5)
			self.ax_ti.axhline(MATE.lab/1000.0, linestyle = '--', color = 'k', alpha = 0.85,linewidth = 2.5)

			for tick in self.ax_ti.xaxis.get_major_ticks():
				tick.label.set_fontsize(fontsize_labels)

			self.ax_ti.set_yticklabels([])

			crust_obj = patches.Rectangle((0,0) ,300.0,MATE.moho / 1000.0, color = '#b76314', alpha = 0.6,hatch = 'xxxx')
			ast_obj = patches.Rectangle((0,MATE.lab / 1000.0),300.0,1e5, color = '#b73114', alpha = 0.6,hatch = 'xx')
			self.ax_ti.add_patch(crust_obj)
			self.ax_ti.add_patch(ast_obj)

			#Fluorine in phlogopite

			self.ax_flour = plt.subplot2grid((16,16),(0,9), rowspan = 16,colspan = 3, fig = self.figure_other_comp)

			self.ax_flour.plot(self.flu[self.idx_moho:], self.depth[self.idx_moho:] / 1000.0, color = '#083fb5', linewidth = 1.5)

			self.ax_flour.set_xlim((0.0,2.0))
			self.ax_flour.set_xlabel(r'$F \, in \, phlg$ [wt%]',fontsize = 9)
			self.ax_flour.set_ylim((MATE.lab / 1000.0) + 25.0, 0.0)

			self.ax_flour.axhline(MATE.moho/1000.0, linestyle = '--',color = '#BA43C2', alpha = 0.85,linewidth = 2.5)
			self.ax_flour.axhline(MATE.lab/1000.0, linestyle = '--', color = 'k', alpha = 0.85,linewidth = 2.5)

			for tick in self.ax_flour.xaxis.get_major_ticks():
				tick.label.set_fontsize(fontsize_labels)

			self.ax_flour.set_yticklabels([])

			crust_obj = patches.Rectangle((0,0) ,300.0,MATE.moho / 1000.0, color = '#b76314', alpha = 0.6,hatch = 'xxxx')
			ast_obj = patches.Rectangle((0,MATE.lab / 1000.0),300.0,1e5, color = '#b73114', alpha = 0.6,hatch = 'xx')
			self.ax_flour.add_patch(crust_obj)
			self.ax_flour.add_patch(ast_obj)

			#CO2 melt

			self.ax_carbon = plt.subplot2grid((16,16),(0,9), rowspan = 16,colspan = 3, fig = self.figure_other_comp)

			self.ax_carbon.plot(self.co2[self.idx_moho:], self.depth[self.idx_moho:] / 1000.0, color = '#083fb5', linewidth = 1.5)

			self.ax_carbon.set_xlim((0.0,1e3))
			self.ax_carbon.set_xlabel(r'$CO_2 \, in \, melt$ [wt%]',fontsize = 9)
			self.ax_carbon.set_ylim((MATE.lab / 1000.0) + 25.0, 0.0)

			self.ax_carbon.axhline(MATE.moho/1000.0, linestyle = '--',color = '#BA43C2', alpha = 0.85,linewidth = 2.5)
			self.ax_carbon.axhline(MATE.lab/1000.0, linestyle = '--', color = 'k', alpha = 0.85,linewidth = 2.5)

			for tick in self.ax_carbon.xaxis.get_major_ticks():
				tick.label.set_fontsize(fontsize_labels)

			self.ax_carbon.set_yticklabels([])

			crust_obj = patches.Rectangle((0,0), 10000.0, MATE.moho / 1000.0, color = '#b76314', alpha = 0.6,hatch = 'xxxx')
			ast_obj = patches.Rectangle((0, MATE.lab / 1000.0), 10000.0, 1e5, color = '#b73114', alpha = 0.6,hatch = 'xx')
			self.ax_carbon.add_patch(crust_obj)
			self.ax_carbon.add_patch(ast_obj)

			#NaO melt

			self.ax_na2o = plt.subplot2grid((16,16),(0,9), rowspan = 16,colspan = 3, fig = self.figure_other_comp)

			self.ax_na2o.plot(self.na2o_melt[self.idx_moho:], self.depth[self.idx_moho:] / 1000.0, color = '#083fb5', linewidth = 1.5)

			self.ax_na2o.set_xlim((0.0,5))
			self.ax_na2o.set_xlabel(r'$Na_2O \, in \, melt$ [wt%]',fontsize = 9)
			self.ax_na2o.set_ylim((MATE.lab / 1000.0) + 25.0, 0.0)

			self.ax_na2o.axhline(MATE.moho/1000.0, linestyle = '--',color = '#BA43C2', alpha = 0.85,linewidth = 2.5)
			self.ax_na2o.axhline(MATE.lab/1000.0, linestyle = '--', color = 'k', alpha = 0.85,linewidth = 2.5)

			for tick in self.ax_na2o.xaxis.get_major_ticks():
				tick.label.set_fontsize(fontsize_labels)

			self.ax_na2o.set_yticklabels([])

			crust_obj = patches.Rectangle((0,0), 10000.0, MATE.moho / 1000.0, color = '#b76314', alpha = 0.6,hatch = 'xxxx')
			ast_obj = patches.Rectangle((0, MATE.lab / 1000.0), 10000.0, 1e5, color = '#b73114', alpha = 0.6,hatch = 'xx')
			self.ax_na2o.add_patch(crust_obj)
			self.ax_na2o.add_patch(ast_obj)

			#K2O melt

			self.ax_k2o = plt.subplot2grid((16,16),(0,12), rowspan = 16,colspan = 3, fig = self.figure_other_comp)

			self.ax_k2o.plot(self.k2o_melt[self.idx_moho:], self.depth[self.idx_moho:] / 1000.0, color = '#083fb5', linewidth = 1.5)

			self.ax_k2o.set_xlim((0.0,2))
			self.ax_k2o.set_xlabel(r'$K_2O \, in \, melt$ [wt%]',fontsize = 9)
			self.ax_k2o.set_ylim((MATE.lab / 1000.0) + 25.0, 0.0)

			self.ax_k2o.axhline(MATE.moho/1000.0, linestyle = '--',color = '#BA43C2', alpha = 0.85,linewidth = 2.5)
			self.ax_k2o.axhline(MATE.lab/1000.0, linestyle = '--', color = 'k', alpha = 0.85,linewidth = 2.5)

			for tick in self.ax_k2o.xaxis.get_major_ticks():
				tick.label.set_fontsize(fontsize_labels)

			self.ax_k2o.set_yticklabels([])

			crust_obj = patches.Rectangle((0,0), 10000.0, MATE.moho / 1000.0, color = '#b76314', alpha = 0.6,hatch = 'xxxx')
			ast_obj = patches.Rectangle((0, MATE.lab / 1000.0), 10000.0, 1e5, color = '#b73114', alpha = 0.6,hatch = 'xx')
			self.ax_k2o.add_patch(crust_obj)
			self.ax_k2o.add_patch(ast_obj)

			plt.show()
			plt.ioff()

	def plot_geotherm_button(self):

		ok_to_plot_geotherm = True
		self.geotherm_existence = False

		if self.drawn_3 != 0:

			self.ax3.remove()

		if self.data_existence == True:
			if MATE.thermal_cond_method != '2':
				self.calculate_geotherm()
			else:
				self.load_input_geotherm()

			self.mineral_stabilities()
			if ok_to_plot_geotherm == True:
				self.plot_geotherm(method = 'draw')
				self.drawn_3 = self.drawn_3 + 1
				self.geotherm_existence = True
				self.geot_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #679c5f}")
		else:
			QMessageBox.about(self,'Input Missing!','You have to input a composition file first to continue.')

	def reset_geotherm(self):

		self.T_list = []
		self.geot_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #93db88}")

	def plot_composition_button(self):

		#checking whether composition array is entered.
		if MATE.lodge_check == False:
			QMessageBox.about(self,'Input Missing!','You have to input a composition file first to continue.')
		else:

			if self.drawn != 0:
				try:
					self.ax0.remove()
				except KeyError:
					pass

			self.adjust_composition()
			#Create error if the total mineralogy is indifferent to 1 at any layer.
			ok_to_compute_comp = True

			if ok_to_compute_comp == True:

				if self.continue_adjusting == 1:
					layers_bad_comp = []
					for i in range(0,len(self.ol_frac_comp),2):

						total_frac_solid = self.ol_frac_comp[i] + self.opx_frac_comp[i] + self.cpx_frac_comp[i] +\
						 self.gt_frac_comp[i] + self.pl_frac_comp[i] + self.amp_frac_comp[i] + \
						 self.cond_frac_comp[i]

						if total_frac_solid != 1.0:
							if i == 0:
								layers_bad_comp.append(i+1)
							else:
								layers_bad_comp.append(i-1)
							ok_to_compute_comp = False

					if ok_to_compute_comp == False:
						QMessageBox.about(self,'Error in comp file','Sum of solid-state minerals do not add up to 100% at layers' + ','.join(str(item) for item in layers_bad_comp))

					if ok_to_compute_comp == True:
						self.calculate_pressure()
						self.plot_composition(method = 'draw')
						if MATE.melt_method == '0':
							self.plot_melt_frac(method = 'draw')
							self.solidus_wet_calculated = False
							self.solidus_carbon_calculated = False

						self.drawn = self.drawn + 1
						self.drawn_11 = self.drawn_11 + 1
						self.act_comp_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #679c5f}")

	def plot_water_button(self):

		self.water_existence = False

		if self.drawn_4 != 0:
			self.ax4.remove()

		self.drawn_4 = self.drawn_4 + 1

		if (self.data_existence == True) and (self.geotherm_existence == True):

			if MATE.al_method == '1':
				if (MATE.d_opx_type[MATE.opx_part_select] == '1') or (MATE.d_opx_type[MATE.opx_part_select] == '2'):
					QMessageBox.about(self,'WARNING!','You have to enter a new type of partitioning coefficient from before since the Al-method is disabled.')
					self.drawn_4 = 0
					return
				if (MATE.d_cpx_type[MATE.opx_part_select] == '1') or (MATE.d_cpx_type[MATE.opx_part_select] == '2'):
					QMessageBox.about(self,'WARNING!','You have to enter a new type of partitioning coefficient from before since the Al-method is disabled.')
					self.drawn_4 = 0
					return
				if (MATE.d_px_type[MATE.opx_part_select] == '1') or (MATE.d_px_type[MATE.opx_part_select] == '2'):
					QMessageBox.about(self,'WARNING!','You have to enter a new type of partitioning coefficient from before since the Al-method is disabled.')
					self.drawn_4 = 0
					return
			self.calculate_water(method = 'array', idx = None)
			if MATE.sol_plot == True:
				self.solubility_ol()
				self.solubility_partitioning()
			if self.solidus_wet_calculated == True:
				self.plot_geotherm(method = 'draw')
			self.plot_water(method = 'draw')
			self.water_existence = True
			self.plt_water_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #679c5f}")
		else:
			QMessageBox.about(self,'Input Missing!','You have to input a composition file and calculate the geotherm first to continue.')

	def plot_water_reset(self):

		self.h2o_bulk_list = []
		self.h2o_list = []
		self.h2o_max_list = []
		self.h2o_min_list = []
		self.ol_h2o_list = []
		self.ol_h2o_max_list = []
		self.ol_h2o_min_list = []
		self.opx_h2o_list = []
		self.opx_h2o_max_list = []
		self.opx_h2o_min_list = []
		self.cpx_h2o_list = []
		self.cpx_h2o_max_list = []
		self.cpx_h2o_min_list = []
		self.px_h2o_list = []
		self.px_h2o_max_list = []
		self.px_h2o_min_list = []
		self.gt_h2o_list = []
		self.gt_h2o_max_list = []
		self.gt_h2o_min_list = []
		self.amp_h2o_list = []
		self.amp_h2o_max_list = []
		self.amp_h2o_min_list = []
		self.pl_h2o_list = []
		self.pl_h2o_max_list = []
		self.pl_h2o_min_list = []
		self.melt_h2o_list = []
		self.melt_h2o_max_list = []
		self.melt_h2o_min_list = []
		self.plt_water_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #93db88}")

		self.solidus_wet_calculated = False
		self.solidus_carbon_calculated = False
		self.water_inverted = False

	def plot_conductivity_button(self):

		if (self.data_existence == True) and (self.geotherm_existence == True) and (self.water_existence == True):

			if self.drawn_5 != 0:
				self.ax5.remove()

			self.drawn_5 = self.drawn_5 + 1

			self.ol_cond = np.zeros(len(self.T))
			self.ol_cond_max = np.zeros(len(self.T))
			self.ol_cond_min = np.zeros(len(self.T))

			self.opx_cond = np.zeros(len(self.T))
			self.opx_cond_max = np.zeros(len(self.T))
			self.opx_cond_min = np.zeros(len(self.T))

			self.cpx_cond = np.zeros(len(self.T))
			self.cpx_cond_max = np.zeros(len(self.T))
			self.cpx_cond_min = np.zeros(len(self.T))

			self.gt_cond = np.zeros(len(self.T))
			self.gt_cond_max = np.zeros(len(self.T))
			self.gt_cond_min = np.zeros(len(self.T))

			self.amp_cond = np.zeros(len(self.T))
			self.amp_cond_max = np.zeros(len(self.T))
			self.amp_cond_min = np.zeros(len(self.T))

			self.pl_cond = np.zeros(len(self.T))
			self.pl_cond_max = np.zeros(len(self.T))
			self.pl_cond_min = np.zeros(len(self.T))

			self.sp_chr_cond = np.zeros(len(self.T))
			self.sp_chr_cond_max = np.zeros(len(self.T))
			self.sp_chr_cond_min = np.zeros(len(self.T))

			self.melt_cond = np.zeros(len(self.T))
			self.melt_cond_max = np.zeros(len(self.T))
			self.melt_cond_min = np.zeros(len(self.T))

			self.bulk_cond = np.zeros(len(self.T))
			self.bulk_cond_max = np.zeros(len(self.T))
			self.bulk_cond_min = np.zeros(len(self.T))

			self.dens_melt = np.zeros(len(self.T))

			self.calculate_ol_conductivity(method = 'array', sol_idx = None)
			self.calculate_opx_conductivity(method = 'array', sol_idx = None)
			self.calculate_cpx_conductivity(method = 'array', sol_idx = None)
			self.calculate_gt_conductivity(method = 'array', sol_idx = None)
			if MATE.pl_method == '0':
				self.calculate_pl_conductivity(method = 'array', sol_idx = None)
			if MATE.amp_method == '0':
				self.calculate_amp_conductivity(method = 'array', sol_idx = None)
			self.calculate_sp_chr_conductivity(method = 'array', sol_idx = None)
			self.calculate_melt_conductivity(method = 'array', sol_idx = None)
			self.phase_mixing_function(method = MATE.phs_mix_method, melt_method = MATE.phs_melt_mix_method,indexing_method = 'array', sol_idx = None)
			self.plot_conductivity(method = 'draw',boundaries = False)
			self.plt_cond_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #679c5f}")

			self.write_out = True

		else:

			QMessageBox.about(self,'Input Missing!','You have to input a composition file and calculate the geotherm and water content first to continue.')

	def store_upper_bound_cond(self):

		self.upper_bound_cond = self.bulk_cond
		self.upper_uncertainty_cond = self.bulk_cond_max
		self.store_upper_bound_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #4b81b3}")
		self.upper_bound_load = True

	def store_lower_bound_cond(self):

		self.lower_bound_cond = self.bulk_cond
		self.lower_uncertainty_cond = self.bulk_cond_min
		self.store_lower_bound_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #4b81b3}")
		self.lower_bound_load = True

	def plot_bounds(self):

		if (self.upper_bound_load == True) and (self.lower_bound_load == True):

			if (self.data_existence == True) and (self.geotherm_existence == True) and (self.water_existence == True):

				if self.drawn_5 != 0:
					self.ax5.remove()

			self.plot_conductivity(method = 'draw',boundaries = True)

		else:
			QMessageBox.about(self, 'Warning!', "Bounds have to be determined first!")

	def plot_conductivity_reset(self):

		self.bulk_cond_max_list = []
		self.bulk_cond_min_list = []
		self.bulk_cond_list = []
		self.linestyle_list = []
		self.linewidth_list = []
		self.plt_cond_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #93db88}")

	def reset_all_plot(self):

		self.fig.clear()
		plt.style.use(MATE.plot_style_list[MATE.plot_style_selection])
		self.canvas.draw()

		self.drawn = 0
		self.drawn_1 = 0
		self.drawn_11 = 0
		self.drawn_3 = 0
		self.drawn_4 = 0
		self.drawn_5 = 0

		self.T_list = []
		self.bulk_cond_max_list = []
		self.bulk_cond_min_list = []
		self.bulk_cond_list = []
		self.linestyle_list = []
		self.linewidth_list = []
		self.h2o_bulk_list = []
		self.h2o_list = []
		self.h2o_max_list = []
		self.h2o_min_list = []
		self.ol_h2o_list = []
		self.ol_h2o_max_list = []
		self.ol_h2o_min_list = []
		self.opx_h2o_list = []
		self.opx_h2o_max_list = []
		self.opx_h2o_min_list = []
		self.cpx_h2o_list = []
		self.cpx_h2o_max_list = []
		self.cpx_h2o_min_list = []
		self.px_h2o_list = []
		self.px_h2o_max_list = []
		self.px_h2o_min_list = []
		self.gt_h2o_list = []
		self.gt_h2o_max_list = []
		self.gt_h2o_min_list = []
		self.amp_h2o_list = []
		self.amp_h2o_max_list = []
		self.amp_h2o_min_list = []
		self.pl_h2o_list = []
		self.pl_h2o_max_list = []
		self.pl_h2o_min_list = []
		self.melt_h2o_list = []
		self.melt_h2o_max_list = []
		self.melt_h2o_min_list = []
		MATE.z_depth_plot_list = []
		MATE.res_profile_plot_list = []
		MATE.res_profile_max_plot_list = []
		MATE.res_profile_min_plot_list = []
		self.color_list_csv = []
		self.depth_xen = []
		self.p_xen = []
		self.T_xen = []

		MATE.loaded_file = False

		self.ModEM_dat_read = False
		self.csv_MT_read = False

		self.upper_bound_load = False
		self.lower_bound_load = False
		self.xenolith_existence = False

		MATE.melt_partitions_calculated = False
		MATE.mineral_partitions_calculated = False

		self.solidus_dry_calculated = False
		self.solidus_wet_calculated = False
		self.solidus_carbon_calculated = False

		MATE.geotherm_asked = False

		self.melt_calc_from_zero_melt = False

		self.act_comp_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #93db88}")
		self.geot_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #93db88}")
		self.plt_water_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #93db88}")
		self.plt_cond_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #93db88}")
		self.store_lower_bound_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #7daedb}")
		self.store_upper_bound_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #7daedb}")

		self.write_out = False
		self.water_inverted = False

	def save_figures(self):

		self.png_file_save_name = QFileDialog.getSaveFileName(self, 'Save File')

		if self.png_file_save_name[0] != '':

			self.png_file_save_name = str(self.png_file_save_name[0])
			self.dir_path = self.png_file_save_name[:self.png_file_save_name.rfind('/')+1]
			self.png_file_name = self.png_file_save_name[self.png_file_save_name.rfind('/')+1:]

			if self.drawn != 0:
				self.plot_composition(method = 'save')
			if self.drawn_3 != 0:
				self.plot_geotherm(method = 'save')
			if self.drawn_4 != 0:
				self.plot_water(method = 'save')
			if self.drawn_5 != 0:
				if self.last_draw_method == 0:
					self.plot_conductivity(method = 'save',boundaries = False)
				else:
					self.plot_conductivity(method = 'save',boundaries = True)

	def quit(self):

		sys.exit()

	def write_data(self):

		if self.write_out == True:

			self.write_file_save_name = QFileDialog.getSaveFileName(self, 'Save File')

			if self.write_file_save_name[0] != '':

				self.fo2 = self.calculate_fugacity(MATE.o2_buffer) * 1e-4

				if MATE.sol_plot == False:
					self.max_ol_h2o = np.zeros(len(self.T))
					self.max_opx_h2o = np.zeros(len(self.T))
					self.max_cpx_h2o = np.zeros(len(self.T))
					self.max_gt_h2o = np.zeros(len(self.T))
					if self.h2o_fugacity_calculated == False:
						self.h2o_fug = np.zeros(len(self.T))

				if MATE.part_px_method == '0':

					self.opx_h2o = self.px_h2o
					self.cpx_h2o = self.px_h2o
					if MATE.sol_plot == True:
						self.max_opx_h2o = self.max_px_h2o
						self.max_cpx_h2o = self.max_px_h2o

				if MATE.pl_method == '1':
					self.pl_cond = self.pl_cond * -999.0

				comp_lines = ['#\n']
				comp_lines.append('Depth(Km),T(K),P(GPa),FO2(GPa),Ol,Opx,Cpx,Gt,Phlg,Amph,Cond,Melt,Ol_m,Opx_m,Cpx_m,Gt_m,Phlg_m,Amp_m,cond_m,melt_m,Ol_gs(mm),XFe_Ol,XFe_Opx,XFe_Cpx,XFe_Gt,Al_Opx(%wt),Ti_Ol(%wt),CO2_melt(ppm),Na2O_Melt(%wt),K2O_Melt(%wt),F_phlg(ppm),t_k_cond(W/mK),heat_prod(mW/m^2),density(g/cm^3)\n')

				water_lines = ['#\n']
				water_lines.append('Depth(Km),T(K),P(GPa),FH2O(GPa),H2O_bulk(ppm),H2O_Ol(ppm),H2O_Opx(ppm),H2O_Cpx(ppm),H2O_gt(ppm),H2O_melt(ppm),H2O_Cap_ol(ppm),H2O_Cap_opx(ppm),H2O_Cap_cpx(ppm),H2O_Cap_gt(ppm)\n')

				cond_lines = ['#\n']
				cond_lines.append('Depth(Km),T(K),P(GPa),sigma_ol,sigma_opx,sigma_cpx,sigma_gt,sigma_phlg,sigma_amp,sigma_cond,sigma_melt,sigma_bulk,sigma_bulk_max,sigma_bulk_min\n')

				solidus_lines = ['#\n']
				solidus_lines.append('Depth(Km),T(K),P(GPa),T_Dry_Solidus(K),T_Water_Solidus(K),T_Carbon_Solidus(K)\n')
				
				if self.solidus_dry_calculated == False:
					self.T_dry_solidus = np.zeros(len(self.T))
				if self.solidus_wet_calculated == False:
					self.T_wet_solidus = np.zeros(len(self.T))
				if self.solidus_carbon_calculated == False:
					self.T_carbon_solidus = np.zeros(len(self.T))
	
				for i in range(self.idx_moho,len(self.depth)):
					comp_lines.append('  ' + str('%4.3f' %  float(self.depth[i] / 1000.0)) + ',' +\
					str('%4.3f' %  self.T[i]) + ',' +\
					str('%4.3f' %  self.p[i]) + ',' +\
					str('%1.5E' %  self.fo2[i]) + ',' +\
					str('%4.3f' %  (self.ol_frac[i]*100.0)) + ',' +\
					str('%4.3f' %  (self.opx_frac[i]*100.0)) + ',' +\
					str('%4.3f' %  (self.cpx_frac[i]*100.0)) + ',' +\
					str('%4.3f' %  (self.gt_frac[i]*100.0)) + ',' +\
					str('%4.3f' %  (self.pl_frac[i]*100.0)) + ',' +\
					str('%4.3f' %  (self.amp_frac[i]*100.0)) + ',' +\
					str('%4.3f' %  (self.cond_frac[i]*100.0)) + ',' +\
					str('%4.3f' %  (self.melt_mass_frac[i]*100.0)) + ',' +\
					str('%4.2f' %  self.ol_m[i]) + ',' +\
					str('%4.2f' %  self.opx_m[i]) + ',' +\
					str('%4.2f' %  self.cpx_m[i]) + ',' +\
					str('%4.2f' %  self.gt_m[i]) + ',' +\
					str('%4.2f' %  self.pl_m[i]) + ',' +\
					str('%4.2f' %  self.amp_m[i]) + ',' +\
					str('%4.2f' %  self.cond_m[i]) + ',' +\
					str('%4.2f' %  self.melt_m[i]) + ',' +\
					str('%4.2f' %  self.ol_gs[i]) + ',' +\
					str('%4.2f' %  self.fe_ol[i]) + ',' +\
					str('%4.2f' %  self.fe_opx[i]) + ',' +\
					str('%4.2f' %  self.fe_cpx[i]) + ',' +\
					str('%4.2f' %  self.fe_gt[i]) + ',' +\
					str('%4.2f' %  self.al_opx[i]) + ',' +\
					str('%4.2f' %  self.ti_ol[i]) + ',' +\
					str('%4.2f' %  self.co2[i]) + ',' +\
					str('%4.2f' %  self.na2o_melt[i]) + ',' +\
					str('%4.2f' %  self.k2o_melt[i]) + ',' +\
					str('%1.5E' %  self.flu[i]) + ',' +\
					str('%1.5E' %  self.cond_t_k[i]) + ',' +\
					str('%1.5E' %  self.heat_prod_mantle[i]) + ',' +\
					str('%1.5E' %  self.density_mantle[i]) + '\n')


					water_lines.append('  ' + str('%4.3f' %  float(self.depth[i] / 1000.0)) + ',' +\
					str('%4.3f' %  self.T[i]) + ',' +\
					str('%4.3f' %  self.p[i]) + ',' +\
					str('%1.5E' %  self.h2o_fug[i]) + ',' +\
					str('%1.5E' %  self.h2o_list[-1][i]) + ',' +\
					str('%1.5E' %  self.ol_h2o[i]) + ',' +\
					str('%1.5E' %  self.opx_h2o[i]) + ',' +\
					str('%1.5E' %  self.cpx_h2o[i]) + ',' +\
					str('%1.5E' %  self.gt_h2o[i]) + ',' +\
					str('%1.5E' %  self.melt_h2o[i]) + ',' +\
					str('%1.5E' %  self.max_ol_h2o[i]) + ',' +\
					str('%1.5E' %  self.max_opx_h2o[i]) + ',' +\
					str('%1.5E' %  self.max_cpx_h2o[i]) + ',' +\
					str('%1.5E' %  self.max_gt_h2o[i]) + '\n')

					cond_lines.append('  ' + str('%4.3f' %  float(self.depth[i] / 1000.0)) + ',' +\
					str('%4.3f' %  self.T[i]) + ',' +\
					str('%4.3f' %  self.p[i]) + ',' +\
					str('%1.5E' %  self.ol_cond[i]) + ',' +\
					str('%1.5E' %  self.opx_cond[i]) + ',' +\
					str('%1.5E' %  self.cpx_cond[i]) + ',' +\
					str('%1.5E' %  self.gt_cond[i]) + ',' +\
					str('%1.5E' %  self.pl_cond[i]) + ',' +\
					str('%1.5E' %  self.amp_cond[i]) + ',' +\
					str('%1.5E' %  self.cond_cond[i]) + ',' +\
					str('%1.5E' %  self.melt_cond[i]) + ',' +\
					str('%1.5E' %  self.bulk_cond[i]) + ',' +\
					str('%1.5E' %  self.bulk_cond_max[i]) + ',' +\
					str('%1.5E' %  self.bulk_cond_min[i]) + '\n')
										
					solidus_lines.append('  ' + str('%4.3f' %  float(self.depth[i] / 1000.0)) + ',' +\
					str('%4.3f' %  self.T[i]) + ',' +\
					str('%4.3f' %  self.p[i]) + ',' +\
					str('%4.3f' %  self.T_dry_solidus[i]) + ',' +\
					str('%4.3f' %  self.T_wet_solidus[i]) + ',' +\
					str('%4.3f' %  self.T_carbon_solidus[i]) + '\n')
					

				self.write_file_save_name = str(self.write_file_save_name[0])
				self.dir_path_write = self.write_file_save_name[:self.write_file_save_name.rfind('/')+1]
				self.write_file_name = self.write_file_save_name[self.write_file_save_name.rfind('/')+1:]

				filesave_comp = open(os.path.join(self.dir_path_write, (self.write_file_name+'_comp.csv')) ,'w')
				filesave_comp.writelines(comp_lines)
				filesave_comp.close()

				filesave_water = open(os.path.join(self.dir_path_write, (self.write_file_name+'_water.csv')) ,'w')
				filesave_water.writelines(water_lines)
				filesave_water.close()

				filesave_cond = open(os.path.join(self.dir_path_write, (self.write_file_name+'_cond.csv')) ,'w')
				filesave_cond.writelines(cond_lines)
				filesave_cond.close()
				
				filesave_solidus = open(os.path.join(self.dir_path_write, (self.write_file_name+'_solidus.csv')) ,'w')
				filesave_solidus.writelines(solidus_lines)
				filesave_solidus.close()

				QMessageBox.about(self, 'Hey sup!', "Files are saved at the location " + self.dir_path_write)

		else:
			QMessageBox.about(self, 'Warning!', "A calculation has to be made on the canvas in order to write a data file.")

	def solve_for_water_melt(self):

		QMessageBox.about(self, 'Warning!', "This function does not work yet.")
		"""
		if MATE.watermelt_solve_method == 0:
			#First solve for water without any melt
			self.melt_mass_frac[self.idx_moho:] = 0.0
			MATE.melt_method = '1'
			self.solve_for_water()
			MATE.melt_method = '0'

			self.melt_solution = True

			f_res_profile = interp1d(np.array(MATE.z_depth_plot_list[-1]),MATE.res_profile_plot_list[-1])
			res_to_invert = f_res_profile(self.depth[self.idx_moho:]/1e3)

			for i in range(0,self.idx_moho):
				res_to_invert = np.insert(res_to_invert,0,0)

			residuals_current = (1.0/self.bulk_cond - res_to_invert)

			self.idx_resid_for_melt_list = [i for i in range(0,len(residuals_current)) if residuals_current[i] < -50	]

			# self.solve_for_water()

			self.melt_solution = False
		"""
	def solve_for_water(self):

		#Brute solver for peridotite water content.

		if len(MATE.res_profile_plot_list) != 0:

			if self.write_out == True:

				self.water_end = False

				if MATE.w_inp_method == '0':
					self.h2o_max = np.zeros(len(self.h2o))
					self.h2o_min = np.zeros(len(self.h2o))
					calc_count = 3
				else:
					calc_count = 1
				
				self.solidus_wet_calculated = False
				self.solidus_carbon_calculated = False
				QMessageBox.about(self, 'Info', "Solving for water content at each layer. Watch Calc. Progress bar for the process. Disregard the program not responding popups if there is any.")
				self.progressBar.setMinimum(self.idx_moho)
				self.progressBar.setMaximum(len(self.depth))

				if MATE.cond_uncert_method == '0':
					res_profile = (MATE.res_profile_plot_list[-1])
				elif MATE.cond_uncert_method == '1':
					res_profile = (MATE.res_profile_max_plot_list[-1])
				elif MATE.cond_uncert_method == '2':
					res_profile = (MATE.res_profile_min_plot_list[-1])

				f_res_profile = interp1d(np.array(MATE.z_depth_plot_list[-1]),res_profile)
				res_to_invert = f_res_profile(self.depth[self.idx_moho:]/1e3)

				for i in range(0,self.idx_moho):
					res_to_invert = np.insert(res_to_invert,0,0)

				self.solubility_ol()
				MATE.sol_model_pref_select = 0
				self.solubility_partitioning()
				MATE.sol_model_pref_select = 1
				timelist = []

				def _solve_(sol_index, water_search_start, water_search_end, water_search_increment):

					self.water_end = False
					water_search = np.arange(water_search_start, water_search_end[sol_index],water_search_increment)
					restart = True
					while restart:

						self.residual_list = []
						res_check = []
						restart = False
						for j in range(0,len(water_search)):
							self.h2o[sol_index] = water_search[j]
							self.calculate_water(method = 'index', idx = sol_index)
							self.calculate_ol_conductivity(method = 'index', sol_idx = sol_index)
							self.calculate_opx_conductivity(method = 'index', sol_idx = sol_index)
							self.calculate_cpx_conductivity(method = 'index', sol_idx = sol_index)
							self.calculate_gt_conductivity(method = 'index', sol_idx = sol_index)
							if MATE.pl_method == '0':
								self.calculate_pl_conductivity(method = 'index', sol_idx = sol_index)
							if MATE.amp_method == '0':
								self.calculate_amp_conductivity(method = 'index', sol_idx = sol_index)
							self.calculate_sp_chr_conductivity(method = 'index', sol_idx = sol_index)
							if MATE.melt_method == '0':
								self.calculate_melt_conductivity(method = 'index', sol_idx = sol_index)
							self.phase_mixing_function(method = MATE.phs_mix_method, melt_method = MATE.phs_melt_mix_method,indexing_method = 'index', sol_idx = sol_index)

							if MATE.w_inp_method == '0':
								residual = (1.0/self.bulk_cond[sol_index] - res_to_invert[sol_index])
							elif MATE.w_inp_method == '1':
								residual = (1.0/self.bulk_cond_min[sol_index] - res_to_invert[sol_index])
							elif MATE.w_inp_method == '2':
								residual = (1.0/self.bulk_cond_max[sol_index] - res_to_invert[sol_index])

							if j == 0:
								if residual < 0.0:
									if water_search_start != 0.0:
										water_search_start = water_search_start - (water_search_start * 0.1)
										if water_search_start <= 20:
											water_search_start = 0
										water_search = np.arange(water_search_start,water_search_end[sol_index],water_search_increment)
										restart = True
										break

							self.residual_list.append(abs(residual))
							res_check.append(residual)

							chek = 0
							if len(res_check) > 5:
								for k in range(-1,-4,-1):
									if res_check[k] < 0.0:
										chek = chek + 1
								if chek > 2:
									water_search_increment = water_search_increment / 2.0
									if water_search[j] >= water_search_increment:
										water_search_start = water_search[j-5]
									else:
										water_search_start = 0.0

									water_search = np.arange(water_search_start,water_search_end[sol_index],water_search_increment)
									if water_search_increment <= 0.5:
										restart = False
										break
									else:
										restart = True
										break

					if len(self.residual_list) == 0:
						self.h2o[sol_index] = 0.0
					else:
						min_idx = self.residual_list.index(min(self.residual_list))
						self.h2o[sol_index] = water_search[min_idx]
				start_time = timeit.default_timer()

				#Actual solution loop.
				for i in range(self.idx_moho,len(self.depth)):

					if i != self.idx_moho:
						sol_start = self.h2o[i-1] - (self.h2o[i-1]*MATE.solver_search_ratio) #using the previous layer as the next layer solutions initial start
						# sol_start = 0
						if sol_start < 20: #if the guess is too small or negative start from 0
							sol_start = 0
					else:
						sol_start = 0.0

					_solve_(sol_index = i, water_search_start = sol_start, water_search_end = self.h2o_from_sol,  water_search_increment = MATE.water_search_increment_start)

					self.progressBar.setValue(i+1)

				self.progressBar.setValue(self.idx_moho)
				total_time = str((timeit.default_timer()-start_time))

				self.calculate_water(method = 'array', idx = None)
				self.calculate_ol_conductivity(method = 'array', sol_idx = None)
				self.calculate_opx_conductivity(method = 'array', sol_idx = None)
				self.calculate_cpx_conductivity(method = 'array', sol_idx = None)
				self.calculate_gt_conductivity(method = 'array', sol_idx = None)
				if MATE.pl_method == '0':
					self.calculate_pl_conductivity(method = 'array', sol_idx = None)
				if MATE.amp_method == '0':
					self.calculate_amp_conductivity(method = 'array', sol_idx = None)
				self.calculate_sp_chr_conductivity(method = 'array', sol_idx = None)
				if MATE.melt_method == '0':
					self.calculate_melt_conductivity(method = 'array', sol_idx = None)
				self.phase_mixing_function(method = MATE.phs_mix_method, melt_method = MATE.phs_melt_mix_method,indexing_method = 'array', sol_idx = None)
				self.plot_water_reset()
				self.plot_water(method = 'draw')
				self.plt_water_btn.setStyleSheet("QPushButton {min-width: 10em; font: bold; font-size: 9pt;background-color: #679c5f}")
				self.plot_conductivity(method = 'draw', boundaries = False)

				self.water_inverted = True

				QMessageBox.about(self, 'Info', "The calculation has finished in " + str(total_time) + " seconds.")

			else:

				QMessageBox.about(self, 'Warning!', "The user have to at least calculate through conductivities once to perform this action.")

		else:

			QMessageBox.about(self, 'Warning!', "An external resistivity profile has to be imported in order to solve the water contents...")

	def solve_for_geotherm(self):

		#Brute solver for Heat Flow with the given parameters.

		if self.xenolith_existence == True:

			if MATE.thermal_cond_method != '2':

				self.depth_xen = []
				index_depth_xen = []
				t_exclude = []
				if MATE.z_xen_method == '0':
					for i in range(0,len(self.p_xen)):
						if self.p_xen[i] < np.amax(self.p):
							index_depth_xen.append(np.where(self.p == self.find_nearest(self.p,self.p_xen[i])))
							self.depth_xen.append(self.depth[index_depth_xen[i]][0]) #Finding the nearest value of depth equivalents of P values.
						else:
							t_exclude.append(i)

				t_exclude = t_exclude[::-1]
				self.T_xen_plot = np.asarray(self.T_xen)
				self.p_xen_plot = np.asarray(self.p_xen)
				for i in t_exclude:
					self.T_xen_plot = np.delete(self.T_xen_plot,i)
					self.p_xen_plot = np.delete(self.p_xen_plot,i)
				temp_err = np.ones(len(self.T_xen_plot)) * MATE.xen_temp_err
				pres_err = np.ones(len(self.p_xen_plot)) * MATE.xen_pressure_err

				#Finding the data-equivalent T-P

				self.heat_flow_search = np.arange(MATE.heat_flow_search_start,MATE.heat_flow_search_end,MATE.heat_flow_search_incr)

				misfit_list = []

				for i in range(0,len(self.heat_flow_search)):

					MATE.q_0 = self.heat_flow_search[i]

					self.calculate_geotherm()

					self.P_equivalent = []
					self.T_equivalent = []

					for i in index_depth_xen:

						self.P_equivalent.append(self.p[i][0])
						self.T_equivalent.append(self.T[i][0])

					self.P_equivalent = np.asarray(self.P_equivalent)
					self.T_equivalent = np.asarray(self.T_equivalent)
					misfit_func = self.xenolith_RMS(T = self.T_xen_plot,P = self.p_xen_plot,std_T = MATE.xen_temp_err,std_P = MATE.xen_pressure_err,P_eq = self.P_equivalent,T_eq = self.T_equivalent)
					misfit_list.append(misfit_func)

				index_rms_misfit = misfit_list.index(min(misfit_list))
				MATE.q_0 = self.heat_flow_search[index_rms_misfit]

				fig_rms = plt.figure(figsize = (5,5))
				ax_rms = plt.subplot(111)
				ax_rms.plot(self.heat_flow_search,misfit_list,color = 'k')
				ax_rms.plot(self.heat_flow_search[index_rms_misfit],misfit_list[index_rms_misfit],'o',color = '#bf170c',label = 'Solution = ' + str('%4.2f' % self.heat_flow_search[index_rms_misfit]) + r'$mW/m^2$')
				ax_rms.set_xlabel(r'Heat Flow [$mW/m^2$]')
				ax_rms.set_ylabel('RMS')
				ax_rms.grid(which = 'major')
				ax_rms.set_title('Misfit')
				ax_rms.set_xlim((self.heat_flow_search_start-1,self.heat_flow_search_end+1))
				plt.show()

				self.plot_geotherm_button()

			else:

				QMessageBox.about(self, 'Warning!', "You can not fit a geotherm to thermobarometric data with -Input Geotherm- method.")

		else:

			QMessageBox.about(self, 'Warning!', "Thermobarometry or some form of thermal input data has to be imported for this function to work.")

	def solve_for_melt_fraction(self):
		
		QMessageBox.about(self, 'Warning!', "This function is not available to use yet! Check for updates if you want to use it in the future.")
		
		"""
		if self.water_existence == True:

			self.melt_mass_frac = self.calculate_melt_fraction_iterative(method = 'array', sol_idx = None)
			#Adding the non-nan sections into the array(crust)

			for i in range(0,self.idx_moho):
				self.melt_mass_frac = np.insert(self.melt_mass_frac,0,-999)

			if self.melt_calc_from_zero_melt == True:
				self.plot_composition(method = 'draw')
			self.plot_melt_frac(method = 'draw')
			self.calculate_water(method = 'array', idx = None)
			self.plot_water_reset()
			self.plot_water(method = 'draw')

		else:

			QMessageBox.about(self, 'Warning!', "Water calculation has to be made at least once before using this functionality.")
		"""
	def wat_solver_properties(self):

		if self.wat_solver is None:
			self.wat_solver_pop = WAT_SOLV_POP()
			self.wat_solver_pop.setGeometry(QtCore.QRect(1000, 500, 100, 100))
		self.wat_solver_pop.show()

	def xen_solver_properties(self):

		if self.xen_solver is None:
			self.xen_solver_pop = XEN_SOLV_POP()
			self.xen_solver_pop.setGeometry(QtCore.QRect(1000, 100, 100, 100))
		self.xen_solver_pop.show()

	def melt_fraction_solver_properties(self):

		if self.melt_frac_solver is None:
			self.melt_frac_solver_pop = MELT_FRAC_POP()
			self.melt_frac_solver_pop.setGeometry(QtCore.QRect(1000, 100, 100, 100))
		self.melt_frac_solver_pop.show()

	def forward_model_selection(self):

		if self.fwd_model_pop is None:
			self.fwd_model_pop = W_POP()
			self.fwd_model_pop.setGeometry(QtCore.QRect(1000, 100, 100, 100))
		self.fwd_model_pop.show()

	def exported_model_selection(self):

		if self.exported_model_pop is None:
			self.exported_model_pop = COND_UNCERT_POP()
			self.exported_model_pop.setGeometry(QtCore.QRect(1000, 100, 100, 100))
		self.exported_model_pop.show()

	def import_solution_to_comp(self):

		if self.water_inverted == True:

			for i in range(0,len(self.h2o_comp)):
				idx_water, = np.where(self.depth == self.find_nearest(self.depth,self.depth_comp[i]))
				idx_water = int(idx_water)
				self.h2o_comp[i] = self.h2o[idx_water]

			MATE.text = "Depth(km),H2O_bulk(ppm),CO2_melt(ppm),ol_frac,opx_frac,cpx_frac,gt_frac,sp_chr_frac,pl_frac,amp_frac,cond_frac,cond_cond(ohm_m),melt_mass_frac,XFe-ol,XFe-opx,XFe-cpx,XFe-gt,m_ol,m_opx,m_cpx,m_gt,m_sp_chr,m_pl,m_amp,m_cond,m_melt,Al-opx(wt%),Ti-ol(wt%),NaO_melt(wt%),K2O_melt(wt%),t_k_cond(W/mK),fl_pl(wt%),ol_gs(mm),heat_prod(mW/m^2)\n"

			for i in range(0,len(self.depth_comp)-1):
				line = ','.join(('%4.2f' % (self.depth_comp[i]/1e3),'%4.2f' % self.h2o_comp[i],
				'%4.2f' % self.co2_comp[i],
				'%4.2f' % (self.ol_frac_comp[i]*100.0),'%4.2f' % (self.opx_frac_comp[i]*100.0),
				'%4.2f' % (self.cpx_frac_comp[i]*100.0),'%4.2f' % (self.gt_frac_comp[i]*100.0),
				'%4.2f' % (self.sp_chr_frac_comp[i]*100.0),
				'%4.2f' % (self.pl_frac_comp[i]*100.0),'%4.2f' % (self.amp_frac_comp[i]*100.0),
				'%4.2f' % (self.cond_frac_comp[i]*100.0),'%1.3E' % self.cond_cond_comp[i],
				'%4.2f' % (self.melt_frac_comp[i]*100.0),
				'%4.2f' % self.fe_ol_comp[i],'%4.2f' % self.fe_opx_comp[i],
				'%4.2f' % self.fe_cpx_comp[i],'%4.2f' % self.fe_gt_comp[i],
				'%4.2f' % self.ol_m_comp[i],'%4.2f' % self.opx_m_comp[i],
				'%4.2f' % self.cpx_m_comp[i],'%4.2f' % self.gt_m_comp[i],
				'%4.2f' % self.sp_chr_m_comp[i],
				'%4.2f' % self.pl_m_comp[i],'%4.2f' % self.amp_m_comp[i],
				'%4.2f' % self.cond_m_comp[i], '%4.2f' % self.melt_m_comp[i],
				'%4.2f' % self.al_opx_comp[i],'%4.2f' % self.ti_ol_comp[i],
				'%4.2f' % self.na2o_melt_comp[i], '%4.2f' % self.k2o_melt_comp[i],
				'%4.2f' % self.cond_t_k_comp[i],
				'%4.2f' % self.flu_comp[i],'%4.2f' % self.ol_gs_comp[i],
				(('%1.3E' % 4e-5)+'\n')))
				MATE.text = MATE.text + line
			self.editor_pop = None
			QMessageBox.about(self, 'Warning!', "Calculated water contents exporetd to the input file. Click -Composition Entry- ")
		else:

			QMessageBox.about(self, 'Warning!', "First you have to invert the water contents from an MT model...")

	def write_batch_process_output(self):

		self.write_batch_file_save_name = QFileDialog.getSaveFileName(self, 'Save File')

		if self.write_batch_file_save_name[0] != '':

			lines_batch_file = ['Parameter,Value\n']

			lines_batch_file.append('moho,' + str(MATE.moho) + '\n')
			lines_batch_file.append('max_depth,' + str(MATE.lab) + '\n')
			lines_batch_file.append('dz,' + str(MATE.dz) + '\n')
			lines_batch_file.append('part_px_method,' + str(MATE.part_px_method) + '\n')
			lines_batch_file.append('opx_part_select,' + str(MATE.opx_part_select) + '\n')
			lines_batch_file.append('cpx_part_select,' + str(MATE.cpx_part_select) + '\n')
			lines_batch_file.append('px_part_select,' + str(MATE.px_part_select) + '\n')
			lines_batch_file.append('gt_part_select,' + str(MATE.gt_part_select) + '\n')
			lines_batch_file.append('amp_part_select,' + str(MATE.amp_part_select) + '\n')
			lines_batch_file.append('pl_part_select,' + str(MATE.pl_part_select) + '\n')

			lines_batch_file.append('ol_melt_part_select,' + str(MATE.ol_melt_part_select) + '\n')
			lines_batch_file.append('opx_melt_part_select,' + str(MATE.opx_melt_part_select) + '\n')
			lines_batch_file.append('cpx_melt_part_select,' + str(MATE.cpx_melt_part_select) + '\n')
			lines_batch_file.append('gt_melt_part_select,' + str(MATE.gt_melt_part_select) + '\n')

			lines_batch_file.append('hydr_part_method,' + str(MATE.hydr_part_method) + '\n')
			lines_batch_file.append('w_inp_method,' + str(MATE.w_inp_method) + '\n')

			lines_batch_file.append('sol_method,' + str(MATE.sol_method) + '\n')
			lines_batch_file.append('ol_sol_calib,' + str(MATE.ol_sol_calib) + '\n')
			lines_batch_file.append('ol_calib,' + str(MATE.ol_calib) + '\n')
			lines_batch_file.append('px_calib,' + str(MATE.px_calib) + '\n')
			lines_batch_file.append('al_method,' + str(MATE.al_method) + '\n')

			lines_batch_file.append('amph_stab_select,' + str(MATE.amph_stab_select) + '\n')

			lines_batch_file.append('sol_model_pref_select,' + str(MATE.sol_model_pref_select) + '\n')

			lines_batch_file.append('amp_method,' + str(MATE.amp_method) + '\n')
			lines_batch_file.append('pl_method,' + str(MATE.pl_method) + '\n')
			lines_batch_file.append('phs_mix_method,' + str(MATE.phs_mix_method) + '\n')
			lines_batch_file.append('phs_melt_mix_method,' + str(MATE.phs_melt_mix_method) + '\n')

			lines_batch_file.append('ol_dry_selection,' + str(MATE.ol_dry_selection) + '\n')
			lines_batch_file.append('opx_dry_selection,' + str(MATE.opx_dry_selection) + '\n')
			lines_batch_file.append('cpx_dry_selection,' + str(MATE.cpx_dry_selection) + '\n')
			lines_batch_file.append('gt_dry_selection,' + str(MATE.gt_dry_selection) + '\n')

			lines_batch_file.append('ol_cond_selection,' + str(MATE.ol_cond_selection) + '\n')
			lines_batch_file.append('opx_cond_selection,' + str(MATE.opx_cond_selection) + '\n')
			lines_batch_file.append('cpx_cond_selection,' + str(MATE.cpx_cond_selection) + '\n')
			lines_batch_file.append('gt_cond_selection,' + str(MATE.gt_cond_selection) + '\n')
			lines_batch_file.append('amp_cond_selection,' + str(MATE.amp_cond_selection) + '\n')
			lines_batch_file.append('pl_cond_selection,' + str(MATE.pl_cond_selection) + '\n')
			lines_batch_file.append('sp_chr_cond_selection,' + str(MATE.sp_chr_cond_selection) + '\n')
			lines_batch_file.append('melt_cond_selection,' + str(MATE.melt_cond_selection) + '\n')

			lines_batch_file.append('px_cond_method,' + str(MATE.px_cond_method) + '\n')

			lines_batch_file.append('D_gb,' + str(MATE.D_gb) + '\n')
			lines_batch_file.append('delta,' + str(self.delta) + '\n')
			lines_batch_file.append('GB_ol_select,' + str(MATE.GB_ol_select) + '\n')
			lines_batch_file.append('GB_gt_select,' + str(MATE.GB_gt_select) + '\n')

			lines_batch_file.append('o2_buffer,' + str(MATE.o2_buffer) + '\n')

			lines_batch_file.append('water_end,' + str(self.water_end) + '\n')

			lines_batch_file.append('model_method_ol,' + str(MATE.model_method_ol) + '\n')
			lines_batch_file.append('model_method_opx,' + str(MATE.model_method_opx) + '\n')
			lines_batch_file.append('model_method_cpx,' + str(MATE.model_method_cpx) + '\n')
			lines_batch_file.append('model_method_gt,' + str(MATE.model_method_gt) + '\n')

			lines_batch_file.append('solidus_dry_model_selection,' + str(MATE.solidus_dry_model_selection) + '\n')
			lines_batch_file.append('solidus_wet_model_selection,' + str(MATE.solidus_wet_model_selection) + '\n')
			lines_batch_file.append('solidus_carbon_model_selection,' + str(MATE.solidus_carbon_model_selection) + '\n')
			lines_batch_file.append('melt_fraction_function_selection,' + str(MATE.melt_fraction_function_selection) + '\n')

			self.write_batch_file_save_name = str(self.write_batch_file_save_name[0])
			self.dir_path_write = self.write_batch_file_save_name[:self.write_batch_file_save_name.rfind('/')+1]
			self.write_file_name = self.write_batch_file_save_name[self.write_batch_file_save_name.rfind('/')+1:]

			filesave_batch = open(os.path.join(self.dir_path_write, (self.write_file_name+'_batch.csv')) ,'w')
			filesave_batch.writelines(lines_batch_file)
			filesave_batch.close()

class COMP_EDITOR(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		editor_layout = QVBoxLayout(self)



		self.read_button = QPushButton('Read File')
		self.read_button.clicked.connect(self.opentextfile)
		editor_layout.addWidget(self.read_button)

		self.save_button = QPushButton('Save File')
		self.save_button.clicked.connect(self.savetextfile)
		editor_layout.addWidget(self.save_button)

		self.textEdit = QTextEdit()
		self.textEdit.setText(MATE.text)
		editor_layout.addWidget(self.textEdit)

		if MATE.arguments_load == False:
			MATE.text = MATE.text
		else:
			self.opentextfile()
			self.lodge()

		self.lodge_button = QPushButton('Submit Data')
		self.lodge_button.clicked.connect(self.lodge)
		editor_layout.addWidget(self.lodge_button)

		self.open_outside_button = QPushButton('Open The Spreadsheet Externally')
		self.open_outside_button.clicked.connect(self.open_ext)
		editor_layout.addWidget(self.open_outside_button)

		self.comp_editor_info = QPushButton('Info')
		self.comp_editor_info.clicked.connect(self.comp_editor_info_box)
		editor_layout.addWidget(self.comp_editor_info)

	def opentextfile(self):

		if MATE.arguments_load == True:
			self.text_name = MATE.composition_args_path
			MATE.arguments_load = False
		else:
			self.text_name = QFileDialog.getOpenFileName(self, 'Open File')

		if self.text_name[0] != '':

			MATE.loaded_file = True
			if MATE.composition_args_path == False:
				text_file = open(str(self.text_name[0]),'rt',encoding = "utf8")
			else:
				text_file = open(str(self.text_name),'rt',encoding = "utf8")
				MATE.composition_args_path = False
			text_csv = csv.reader(text_file,delimiter = '~')
			self.text_data = ''
			data_text = []
			for row in text_csv:
				data_text.append(row)
			data_text = list(filter(None,data_text))
			for i in range(0,len(data_text)):
				self.text_data = self.text_data + data_text[i][0] + '\n'
			self.textEdit.setText(self.text_data)
		else:
			pass

	def savetextfile(self):

		self.text_save_name = QFileDialog.getSaveFileName(self, 'Save File')

		if self.text_save_name[0] != '':

			filesave_txt = open(str(self.text_save_name[0]),'w')
			filesave_txt.write(self.textEdit.toPlainText())
			filesave_txt.close()
		else:
			pass

	def lodge(self):

		text_take = self.textEdit.toPlainText()
		MATE.text = text_take
		MATE.lodge_check = True

	def open_ext(self):

		if MATE.loaded_file == True:
			if platform.system() == 'Windows':
				os.system('open ' + self.text_name[0])
			else:
				os.system(MATE.spreadsheet + ' ' +  self.text_name[0] + ' &')

		else:
			QMessageBox.about(self,"Warning!","First you have to load a file in order to open it externally with a spreadsheet program...")

	def comp_editor_info_box(self):

		str_msg = "Here, the user defines the composition of the lithosphere. This can either be done via manual entry into the text box or via a .csv file that can be uploaded with the ‘Read File’ button. Lithosphere composition can be defined for a number of layers, "\
		"with each layer starting on a new line. Even if the parameters are not active and won't be used in the calculation, "\
		"the user has to define them as some value in numbers (string entries will not be read!). For inactive parameters, a value of zero would be the most ideal. The first line will not be read and will be regarded as header. "\
		"It is suggested that users should edit their layers in a spreadsheet program with a header line added and open it in here.\n\n"\
		"Parameters Used:\n"\
		"- Depth(km): Top of the layer in km. The first layer has to match with the MOHO depth.\n\n"\
		"- Cw_bulk(ppm): Bulk water content of the layer in ppm (parts per million).\n\n"\
		"- ol_frac, opx_frac, cpx_frac, gt_frac, sp_chr_frac, pl_frac, amp_frac, cond_frac : Fractions of constituent minerals in percentage (olivine, orthopyroxene, clinopyroxene, garnet, spinel/chromite, phlogopite, amphibole and temperature independent conductive phase respectively).\n\n"\
		"- cond_cond : Resistivity value of temperature independent conductive phase (cond_frac) in ohm meters.\n\n"\
		"- X_fe-ol, X_fe-opx, X_fe-cpx, X_fe-gt: Iron content of constituent minerals. These values have to be between 0 and 1 and are equivalent to (1-Mg#/100).\n\n"\
		"- Al-opx(wt%): Al content of opx in weight percent. If an Al model is entered, this value will be replaced over the active P-region of the selected model.\n\n"\
		"- Ti-ol(wt%): Ti content of ol in weight percent. It is only used in calculating olivine water solubility model of Padron-Navarta2017.\n\n"\
		"- m_ol, m_opx, m_cpx, m_gt, m_sp_chr, m_pl, m_amp, m_cond : Modified Archie's Law phase exponents for the respective minerals, which represent the connectivity of the minerals."\
		" If Archie's Law is not used to define the geometric model, the value entered here is not used.\n\n"\
		"- t_k_cond thermal conductivity rate of the temperature independent conductive phase in W/mK.\n\n"\
		"- fl_pl(wt%): Fluorine content of phlogopite, which is only relevant if certain models are used for phlogopite conductivity. Otherwise, any value(numbers) can be entered instead.\n\n" \
		"- ol_gs: Olivine grain size in mm. This value only will be used if olivine conductivity is calculated from grain boundary and lattice diffusion models.\n\n"\
		"- heat prod: Heat production rate of the layer (mW/m^3).\n\n"\
		"After entering or uploading parameters, press the Submit button to make them functional."

		QMessageBox.about(self,"Info on this",str_msg)

class G_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		heat_layout = QFormLayout(self)

		self.btn_intro = QPushButton("Geotherm Method")
		self.btn_intro.clicked.connect(self.get_geoth_select)
		heat_layout.addRow(self.btn_intro)

		self.btn_adiabat = QPushButton("Adiabat")
		self.btn_adiabat.clicked.connect(self.get_adiabat)
		self.adiabat_textbox = QLineEdit(MATE.adiabat_options[MATE.adiabat_selection])
		self.adiabat_textbox.setEnabled(False)
		heat_layout.addRow(self.btn_adiabat,self.adiabat_textbox)

		self.btn0 = QPushButton("Surface heat flow (mW/m^2)")
		self.btn0.clicked.connect(self.get_heat_prod_0)
		self.surf_hw_textbox = QLineEdit(str(MATE.q_0))
		self.surf_hw_textbox.setEnabled(False)
		heat_layout.addRow(self.btn0,self.surf_hw_textbox)

		self.btn01 = QPushButton("Surface temperature (C)")
		self.btn01.clicked.connect(self.get_heat_prod_01)
		self.surf_temp_textbox = QLineEdit(str(MATE.T_0 - 273.0))
		self.surf_temp_textbox.setEnabled(False)
		heat_layout.addRow(self.btn01,self.surf_temp_textbox)

		self.btn1 = QPushButton("Upper-crustal heat production (mW/m^3)")
		self.btn1.clicked.connect(self.get_heat_prod_1)
		self.heat_prod_textbox = QLineEdit(str(MATE.A_upper_crust))
		self.heat_prod_textbox.setEnabled(False)
		heat_layout.addRow(self.btn1,self.heat_prod_textbox)

		self.btn2 = QPushButton("Depth of the heat-producing upper crust (km)")
		self.btn2.clicked.connect(self.get_heat_prod_2)
		self.upper_crst_depth = QLineEdit(str(MATE.hr / 1000.0) )
		self.upper_crst_depth.setEnabled(False)
		heat_layout.addRow(self.btn2,self.upper_crst_depth)

		self.btn3 = QPushButton("Lower-crustal heat production (mW/m^3)")
		self.btn3.clicked.connect(self.get_heat_prod_3)
		self.heat_prod_textbox_2 = QLineEdit(str(MATE.A_lower_crust))
		self.heat_prod_textbox_2.setEnabled(False)
		heat_layout.addRow(self.btn3,self.heat_prod_textbox_2)

		self.btn35 = QPushButton("Input Geotherm Properties")
		self.btn35.clicked.connect(self.get_geothermp_input_prop)
		heat_layout.addRow(self.btn35)

		self.btn4 = QPushButton("Input Geotherm")
		self.btn4.clicked.connect(self.get_geotherm_input)
		heat_layout.addRow(self.btn4)

		self.gpop_info = QPushButton('Info')
		self.gpop_info.clicked.connect(self.gpop_info_box)
		heat_layout.addWidget(self.gpop_info)

		self.geoth_select_prop = None
		self.geoth_message = "You selected the geotherm input method, you can not change these parameters if you chosen this method."

	def get_geoth_select(self):

		self.geoth_select = GEOTH_SELECT()
		self.geoth_select.setGeometry(QtCore.QRect(1000, 100, 100, 100))
		self.geoth_select.show()

	def get_geothermp_input_prop(self):

		if MATE.thermal_cond_method == '2':
			if self.geoth_select_prop is None:
				self.geoth_select_prop = GEOTH_INPUT_POP()
				self.geoth_select_prop.setGeometry(QtCore.QRect(1000, 100, 100, 100))
			self.geoth_select_prop.show()
		else:
			QMessageBox.about(self,"Warning!","This option can only be available if the user select the Geotherm Input method from the Geotherm methods")

	def get_adiabat(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Conductivity model", MATE.adiabat_options, 0, False)

		if ok and item:
			self.adiabat_textbox.setText(item)

		MATE.adiabat_selection = MATE.adiabat_options.index(item)

	def get_heat_prod_0(self):

		if MATE.thermal_cond_method != '2':
			text, ok = QInputDialog.getText(self, 'Surface  Dialogue', 'Enter the value in (mW/m^2):')
			if ok:
				try:
					float(text)
					self.surf_hw_textbox.setText(str(text))
					MATE.q_0 = float(text)
				except ValueError:
					QMessageBox.about(self,"Warning!","Please enter a value that can be converted to floating number.")
		else:
			QMessageBox.about(self,"Warning!",self.geoth_message)
	def get_heat_prod_01(self):

		if MATE.thermal_cond_method != '2':
			text, ok = QInputDialog.getText(self, 'Heat Production Dialogue', 'Enter the value in (C):')
			if ok:
				try:
					float(text)
					self.surf_temp_textbox.setText(str(text))
					MATE.T_0 = float(text) + 273.0
				except ValueError:
					QMessageBox.about(self,"Warning!","Please enter a value that can be converted to floating number.")
		else:
			QMessageBox.about(self,"Warning!",self.geoth_message)

	def get_heat_prod_1(self):

		if MATE.thermal_cond_method != '2':
			text, ok = QInputDialog.getText(self, 'Heat Production Dialogue', 'Enter the value in (mW/m^3):')
			if ok:
				try:
					float(text)
					self.heat_prod_textbox.setText(str(text))
					MATE.A_upper_crust = float(text)
				except ValueError:
					QMessageBox.about(self,"Warning!","Please enter a value that can be converted to floating number.")
		else:
			QMessageBox.about(self,"Warning!",self.geoth_message)

	def get_heat_prod_2(self):
		if MATE.thermal_cond_method != '2':
			text, ok = QInputDialog.getText(self, 'Upper Crust Depth Dialogue', 'Enter the value in (km):')
			if ok:
				try:
					float(text)
					self.upper_crst_depth.setText(str(text))
					MATE.hr = float(text) * 1000.0
				except ValueError:
					QMessageBox.about(self,"Warning!","Please enter a value that can be converted to floating number.")
		else:
			QMessageBox.about(self,"Warning!",self.geoth_message)

	def get_heat_prod_3(self):

		if MATE.thermal_cond_method != '2':
			text, ok = QInputDialog.getText(self, 'Heat Production Dialogue', 'Enter the value in (mW/m^3):')
			if ok:
				try:
					float(text)
					self.heat_prod_textbox_2.setText(str(text))
					MATE.A_lower_crust = float(text)
				except ValueError:
					QMessageBox.about(self,"Warning!","Please enter a value that can be converted to floating number.")
		else:
			QMessageBox.about(self,"Warning!",self.geoth_message)

	def get_geotherm_input(self):

		if MATE.thermal_cond_method == '2':
			self.geotherm_file_name = QFileDialog.getOpenFileName(self, 'Open File')

			if self.geotherm_file_name[0] != '':

				self.read_geotherm_input()

			else:
				pass
		else:
			QMessageBox.about(self,"Warning!","This option can only be available if the user select the Geotherm Input method from the Geotherm methods")

	def read_csv(self,filename,delim):

		#Simple function for reading csv files and give out filtered output for given delimiter (delim)

		file_obj = open(filename,'rt',encoding = "utf8") #Creating file object
		file_csv = csv.reader(file_obj,delimiter = delim) #Reading the file object with csv module, delimiter assigned to ','
		data = [] #Creating empty array to append data

		#Appending data from csb object
		for row in file_csv:
			data.append(row)

		#Filtering data for None elements read.
		for j in range(0,len(data)):
			data[j] = list(filter(None,data[j]))
		data = list(filter(None,data))

		return data

	def read_geotherm_input(self):

		self.geotherm_data = self.read_csv(self.geotherm_file_name[0],delim = ',')

		MATE.depth_geotherm = []
		MATE.T_geotherm = []

		try:
			try:
				if float(self.geotherm_data[1][1]) != 0.0:
					MATE.depth_geotherm.append(0.0)
					if MATE.geotherm_inp_temp_method == '0':
						MATE.T_geotherm.append(MATE.T_0+273)
					else:
						MATE.T_geotherm.append(MATE.T_0)
				for i in range(1,len(self.geotherm_data)):
					MATE.depth_geotherm.append(float(self.geotherm_data[i][1]))

					if MATE.geotherm_inp_temp_method == '0':
						MATE.T_geotherm.append(float(self.geotherm_data[i][0]))
					else:
						MATE.T_geotherm.append(float(self.geotherm_data[i][0]) + 273.0)
			except ValueError:
				QMessageBox.about(self,'Warning!','There is an element in the file that can not be transformed into floating number...')
				return
		except IndexError:
			QMessageBox.about(self,'Warning!','Structure of the csv file seems to be wrong.')
			return

		QMessageBox.about(self,'Success',str(self.geotherm_file_name[0]) + ' file was succesfully imported to the program!')
		self.geotherm_input_existence = True

	def gpop_info_box(self):

		str_msg_3 = "Here, the user can edit the parameters that are used in geotherm calculations. These parameters are:\n\n"\
		"- Surface heat flow: Heat flow value measured on surface in mW/m^2.\n\n"\
		"- Surface temperature: Temperature at surface in Celsius (C)\n\n"\
		"- Upper-crustal heat production: Average upper-crustal heat production from radiogenic elements in mW/m^3.\n\n"\
		"- Depth of the upper crust: Thickness of the upper crust in km\n\n"\
		"- Lower-crustal heat production: Average lower-crustal heat production from radiogenic elements in mW/m^3.\n\n"\
		"The geotherm can either be composition dependent, via thermal conductivities of constituent minerals and input compositional layers,"\
		" or can be assumed to be an average cratonic composition (Hasterok and Chapman, 2011). Thermal conductivities of minerals and the general methodology are taken from Hasterok and Chapman (2011) and Hasterok (2010)."\
		" Values of radial and lattice thermal conductivities can be changed in the parameter files.\n\n"\
		"In the geotherm plot the colored fields on the left hand side represent"\
		" the temperature ranges of the experimetal conductivity models.\n\n"\
		"Geotherm can be also given as an input file from a csv file. In this csv file,"\
		"there has to be a header on first row while first column should be temperature "\
		"and second being depth in kilometres."

		QMessageBox.about(self,"Info on this",str_msg_3)

class GEOTH_INPUT_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		geoth_inp_layout = QFormLayout(self)

		self.geoth_inp_btn_1 = QPushButton("Temperature")
		self.geoth_inp_btn_1.clicked.connect(self.get_geoth_inp_temp)
		geoth_inp_layout.addRow(self.geoth_inp_btn_1)
		self.geoth_inp_temp_pop = None

	def get_geoth_inp_temp(self):

		if self.geoth_inp_temp_pop is None:
			self.geoth_inp_temp_pop = GEOTH_INP_TEMP_POP()
			self.geoth_inp_temp_pop.setGeometry(QtCore.QRect(100, 100, 100, 100))
		self.geoth_inp_temp_pop.show()

class GEOTH_INP_TEMP_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		geoth_inp_temp_layout = QVBoxLayout(self)

		self.geoth_inp_temp_radio_1 = QRadioButton("Kelvin")
		self.geoth_inp_temp_radio_1.toggled.connect(lambda:self.btnstate_temp_xen(self.geoth_inp_temp_radio_1))
		self.geoth_inp_temp_radio_2 = QRadioButton("Celsius")
		self.geoth_inp_temp_radio_2.toggled.connect(lambda:self.btnstate_temp_xen(self.geoth_inp_temp_radio_2))

		if MATE.geotherm_inp_temp_method == '0':
			self.geoth_inp_temp_radio_1.setChecked(True)
		elif MATE.geotherm_inp_temp_method == '1':
			self.geoth_inp_temp_radio_2.setChecked(True)

		geoth_inp_temp_layout.addWidget(self.geoth_inp_temp_radio_1)
		geoth_inp_temp_layout.addWidget(self.geoth_inp_temp_radio_2)

	def btnstate_temp_xen(self,b):

		if b.text() == "Kelvin":
			if b.isChecked() == True:
				MATE.geotherm_inp_temp_method = '0'
		elif b.text() == "Celsius":
			if b.isChecked() == True:
				MATE.geotherm_inp_temp_method = '1'

class GEOTH_SELECT(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		geoth_layout = QVBoxLayout(self)

		self.b1 = QRadioButton("Generalized Cratonic Mantle Composition (Hasterok-Chapman 2011)")
		self.b1.toggled.connect(lambda:self.btnstate(self.b1))
		self.b2 = QRadioButton("Composition Dependent")
		self.b2.toggled.connect(lambda:self.btnstate(self.b2))
		self.b3 = QRadioButton("Input Geotherm")
		self.b3.toggled.connect(lambda:self.btnstate(self.b3))
		self.b4 = QRadioButton("Generalized Cratonic Mantle Composition + 26 % Upper Crustal Radiogenic Heat Production (Hasterok-Chapman 2011)")
		self.b4.toggled.connect(lambda:self.btnstate(self.b4))

		if MATE.thermal_cond_method == '0':
			self.b1.setChecked(True)
		elif MATE.thermal_cond_method == '1':
			self.b2.setChecked(True)
		elif MATE.thermal_cond_method == '2':
			self.b3.setChecked(True)
		elif MATE.thermal_cond_method == '3':
			self.b4.setChecked(True)

		geoth_layout.addWidget(self.b1)
		geoth_layout.addWidget(self.b4)
		geoth_layout.addWidget(self.b2)
		geoth_layout.addWidget(self.b3)


	def btnstate(self,b):

		if b.text() == "Generalized Cratonic Mantle Composition (Hasterok-Chapman 2011)":
			if b.isChecked() == True:
				MATE.thermal_cond_method = '0'
		elif b.text() == "Composition Dependent":
			if b.isChecked() == True:
				MATE.thermal_cond_method = '1'
		elif b.text() == "Input Geotherm":
			if b.isChecked() == True:
				MATE.thermal_cond_method = '2'
		elif b.text() == "Generalized Cratonic Mantle Composition + 26 % Upper Crustal Radiogenic Heat Production (Hasterok-Chapman 2011)":
			if b.isChecked() == True:
				MATE.thermal_cond_method = '3'

class DES_COMP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		compdes_layout = QVBoxLayout(self)

		self.al_button = QPushButton('Al-Dependency')
		self.al_button.clicked.connect(self.al_popup)
		compdes_layout.addWidget(self.al_button)

		self.descomp_editor_info = QPushButton('Info')
		self.descomp_editor_info.clicked.connect(self.descomp_editor_info_box)
		compdes_layout.addWidget(self.descomp_editor_info)

		self.al_pop = None

	def al_popup(self):

		if self.al_pop is None:
			self.al_pop = SUBCLASS_AL()
			self.al_pop.setGeometry(QtCore.QRect(100, 100, 100, 100))
		self.al_pop.show()

	def descomp_editor_info_box(self):

		str_msg_2 = "This button defines some of the parameters required for the main 'Composition Entry' button.\n\n"\
		"- Al-dependency: Al content in opx could change the partitioning of water between pyroxenes and olivine "\
		"significantly. Here, the user can choose whether to consider Al-dependency or not. Also a model for Al-incorporation "\
		"in opx can be entered from the box below.\n\n"\

		QMessageBox.about(self,"Composition Setup Info",str_msg_2)

class SUBCLASS_AL(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		part_layout = QFormLayout(self)

		self.part_radio_1 = QRadioButton("Al-Dependent")
		self.part_radio_1.toggled.connect(lambda:self.btnstate_part(self.part_radio_1))
		self.part_radio_2 = QRadioButton("Al-Free")
		self.part_radio_2.toggled.connect(lambda:self.btnstate_part(self.part_radio_2))
		part_layout.addRow(self.part_radio_1,self.part_radio_2)

		if MATE.al_method == '0':
			self.part_radio_1.setChecked(True)
		elif MATE.al_method == '1':
			self.part_radio_2.setChecked(True)

		self.al_opx_model_button = QPushButton("Al-opx model")
		self.al_opx_model_textbox = QLineEdit(MATE.al_opx_model_display[MATE.al_opx_model_select])
		self.al_opx_model_textbox.setEnabled(False)
		self.al_opx_model_button.clicked.connect(self.get_al_opx_model)
		part_layout.addRow(self.al_opx_model_button,self.al_opx_model_textbox)

	def btnstate_part(self,b):

		if b.text() == "Al-Dependent":
			if b.isChecked() == True:
				MATE.al_method = '0'
		elif b.text() == "Al-Free":
			if b.isChecked() == True:
				MATE.al_method = '1'

	def get_al_opx_model(self):
		if MATE.al_method == '0':
			item, ok = QInputDialog.getItem(self, "select input dialog",
				"Select Al-opx_model", MATE.al_opx_model_display, 0, False)

			if ok and item:
				self.al_opx_model_textbox.setText(item)

			MATE.al_opx_model_select = int(MATE.al_opx_model_display.index(item))
		else:
			QMessageBox.about(self,"Warning!","You can only open this dialogue box, if the Al-dependency is activated.")

class DEPTH_FIX(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		depth_layout = QFormLayout(self)

		self.btn4 = QPushButton("Depth of the Moho (km)")
		self.btn4.clicked.connect(self.get_heat_prod_4)
		self.moho_depth_textbox = QLineEdit(str(MATE.moho / 1000.0))
		self.moho_depth_textbox.setEnabled(False)
		depth_layout.addRow(self.btn4,self.moho_depth_textbox)

		self.btn6 = QPushButton("Maximum Depth (km)")
		self.btn6.clicked.connect(self.get_heat_prod_6)
		self.lab_depth_textbox = QLineEdit(str(MATE.lab / 1000.0))
		self.lab_depth_textbox.setEnabled(False)
		depth_layout.addRow(self.btn6,self.lab_depth_textbox)

		self.dz_btn = QPushButton("Interpolation Thickness (km)")
		self.dz_btn.clicked.connect(self.get_interp_thick)
		self.dz_btn_txt = QLineEdit(str(MATE.dz / 1000.0))
		self.dz_btn_txt.setEnabled(False)
		depth_layout.addRow(self.dz_btn,self.dz_btn_txt)

	def get_heat_prod_4(self):

		text, ok = QInputDialog.getText(self, 'Moho Depth Dialogue', 'Enter the value in (km):')
		if ok:
			try:
				float(text)
				self.moho_depth_textbox.setText(str(text))
				MATE.moho = float(text) * 1000.0
			except ValueError:
				QMessageBox.about(self,"Warning!","Please enter a value that can be converted to floating number.")


	def get_heat_prod_6(self):

		text, ok = QInputDialog.getText(self, 'Max Depth Dialogue', 'Enter the value in (km):')
		if ok:
			try:
				float(text)
				if float(text)*1000.0 < MATE.moho:
					QMessageBox.about(self,"Warning!","Please enter a value that is larger than the Moho depth.")
				else:
					self.lab_depth_textbox.setText(str(text))
					MATE.lab = float(text) * 1000.0
			except ValueError:
				QMessageBox.about(self,"Warning!","Please enter a value that can be converted to floating number.")

	def get_interp_thick(self):

		text, ok = QInputDialog.getText(self, 'Interpolation Thickness Dialogue', 'Enter the value in (km):')
		if ok:
			try:
				float(text)
				if (float(text) * 1000) >= (MATE.lab / 3.0):
					QMessageBox.about(self,"Warning!","Interpretation layer thickness cannot be larger than LAB/3 kms")
				else:
					MATE.dz = float(text) * 1000.0
					self.dz_btn_txt.setText(str(text))
			except ValueError:
				QMessageBox.about(self,"Warning!","Please enter a value that can be converted to floating number.")

class PART_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		self.adjust_al()

		part_layout = QFormLayout(self)

		self.peridotite_label = QLabel(self)
		self.peridotite_label.setText('---Solid-state Water Partitioning---')
		part_layout.addRow(self.peridotite_label)

		self.px_radio_1 = QRadioButton("Px Handled Together")
		self.px_radio_1.toggled.connect(lambda:self.btnstate_px(self.px_radio_1))
		self.px_radio_2 = QRadioButton("Px Handled Independently")
		self.px_radio_2.toggled.connect(lambda:self.btnstate_px(self.px_radio_2))

		if MATE.part_px_method == '0':
			self.px_radio_1.setChecked(True)
		elif MATE.part_px_method == '1':
			self.px_radio_2.setChecked(True)

		part_layout.addRow(self.px_radio_1,self.px_radio_2)

		self.pyx_button = QPushButton("Pyroxenes")
		part_layout.addRow(self.pyx_button)
		self.pyx_button.clicked.connect(self.open_px_window)
		self.px_pop = None

		self.gt_button = QPushButton("gt/ol")
		self.gt_part_textbox = QLineEdit(MATE.gt_display)
		self.gt_part_textbox.setEnabled(False)
		part_layout.addRow(self.gt_button,self.gt_part_textbox)
		self.gt_button.clicked.connect(self.get_gtol)

		self.hydr_button = QPushButton("Hydrous Mineral Setup")
		self.hydr_button.clicked.connect(self.open_hydr)
		part_layout.addRow(self.hydr_button)
		self.hydr_pop = None

		self.amp_button = QPushButton("amp/ol")
		self.amp_part_textbox = QLineEdit(MATE.amp_display)
		self.amp_part_textbox.setEnabled(False)
		self.amp_button.clicked.connect(self.get_ampol)
		part_layout.addRow(self.amp_button,self.amp_part_textbox)

		self.pl_button = QPushButton("phlg/ol")
		self.pl_part_textbox = QLineEdit(MATE.pl_display)
		self.pl_part_textbox.setEnabled(False)
		self.pl_button.clicked.connect(self.get_plol)
		part_layout.addRow(self.pl_button,self.pl_part_textbox)

		empty_label = QLabel(self)
		empty_label.setText('')
		part_layout.addRow(empty_label)
		self.melt_per_label = QLabel(self)
		self.melt_per_label.setText('---Melt/Peridotite Water Partitioning---')
		part_layout.addRow(self.melt_per_label)


		self.ol_melt_button = QPushButton("ol/melt")
		self.ol_melt_textbox = QLineEdit(MATE.ol_melt_display)
		self.ol_melt_textbox.setEnabled(False)
		self.ol_melt_button.clicked.connect(self.get_ol_melt)
		part_layout.addRow(self.ol_melt_button,self.ol_melt_textbox)

		self.opx_melt_button = QPushButton("opx/melt")
		self.opx_melt_textbox = QLineEdit(MATE.opx_melt_display)
		self.opx_melt_textbox.setEnabled(False)
		self.opx_melt_button.clicked.connect(self.get_opx_melt)
		part_layout.addRow(self.opx_melt_button,self.opx_melt_textbox)

		self.cpx_melt_button = QPushButton("cpx/melt")
		self.cpx_melt_textbox = QLineEdit(MATE.cpx_melt_display)
		self.cpx_melt_textbox.setEnabled(False)
		self.cpx_melt_button.clicked.connect(self.get_cpx_melt)
		part_layout.addRow(self.cpx_melt_button,self.cpx_melt_textbox)

		self.gt_melt_button = QPushButton("gt/melt")
		self.gt_melt_textbox = QLineEdit(MATE.gt_melt_display)
		self.gt_melt_textbox.setEnabled(False)
		self.gt_melt_button.clicked.connect(self.get_gt_melt)
		part_layout.addRow(self.gt_melt_button,self.gt_melt_textbox)

		self.w_part_info = QPushButton('Info')
		self.w_part_info.clicked.connect(self.w_part_info_box)
		part_layout.addRow(self.w_part_info)


	def adjust_al(self):

		def adjusting_type(typelist,getlist):
			displaylist = []

			for i in range(0,len(typelist)):
				if (typelist[i] == '3') or (typelist[i] == '4') or (typelist[i] == '5'):
					displaylist.append(getlist[i])
			return displaylist

		if MATE.al_method == '1':

			MATE.d_px_display_items = adjusting_type(MATE.d_px_type,MATE.d_px_items)
			MATE.d_opx_display_items = adjusting_type(MATE.d_opx_type,MATE.d_opx_items)
			MATE.d_cpx_display_items = adjusting_type(MATE.d_cpx_type,MATE.d_cpx_items)
			MATE.d_gt_display_items = adjusting_type(MATE.d_gt_type,MATE.d_gt_items)
			MATE.d_amp_display_items = adjusting_type(MATE.d_amp_type,MATE.d_amp_items)
			MATE.d_pl_display_items = adjusting_type(MATE.d_pl_type,MATE.d_pl_items)

		else:

			MATE.d_px_display_items = MATE.d_px_items
			MATE.d_opx_display_items = MATE.d_opx_items
			MATE.d_cpx_display_items = MATE.d_cpx_items
			MATE.d_gt_display_items = MATE.d_gt_items
			MATE.d_amp_display_items = MATE.d_amp_items
			MATE.d_pl_display_items = MATE.d_pl_items

	def btnstate_px(self,b):

		if b.text() == "Px Handled Together":
			if b.isChecked() == True:
				MATE.part_px_method = '0'
		elif b.text() == "Px Handled Independently":
			if b.isChecked() == True:
				MATE.part_px_method = '1'

	def get_gtol(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Partitioning method", MATE.d_gt_display_items, 0, False)

		if ok and item:
			self.gt_part_textbox.setText(item)

		MATE.gt_display = item

		MATE.gt_part_select = int(MATE.d_gt_items.index(item))

		MATE.mineral_partitions_calculated = False

	def get_ampol(self):

			item, ok = QInputDialog.getItem(self, "select input dialog",
				"Partitioning method", MATE.d_amp_display_items, 0, False)

			if ok and item:
				self.amp_part_textbox.setText(item)

			MATE.amp_display = item

			MATE.amp_part_select = int(MATE.d_amp_items.index(item))

			MATE.mineral_partitions_calculated = False

	def get_plol(self):

			item, ok = QInputDialog.getItem(self, "select input dialog",
				"Partitioning method", MATE.d_pl_display_items, 0, False)

			if ok and item:
				self.pl_part_textbox.setText(item)

			MATE.pl_display = item

			MATE.pl_part_select = int(MATE.d_pl_items.index(item))

			MATE.mineral_partitions_calculated = False


	def get_ol_melt(self):

		

		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Partitioning method", MATE.d_melt_ol_items, 0, False)

		if ok and item:
			self.ol_melt_textbox.setText(item)

		MATE.ol_melt_display = item

		MATE.ol_melt_part_select = int(MATE.d_melt_ol_items.index(item))
		

	def get_opx_melt(self):



		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Partitioning method", MATE.d_melt_opx_items, 0, False)

		if ok and item:
			self.opx_melt_textbox.setText(item)

		MATE.opx_melt_display = item

		MATE.opx_melt_part_select = int(MATE.d_melt_opx_items.index(item))

		MATE.melt_partitions_calculated = False


	def get_cpx_melt(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Partitioning method", MATE.d_melt_cpx_items, 0, False)

		if ok and item:
			self.cpx_melt_textbox.setText(item)

		MATE.cpx_melt_display = item

		MATE.cpx_melt_part_select = int(MATE.d_melt_cpx_items.index(item))

		MATE.melt_partitions_calculated = False

	def get_gt_melt(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Partitioning method", MATE.d_melt_gt_items, 0, False)

		if ok and item:
			self.gt_melt_textbox.setText(item)

		MATE.gt_melt_display = item

		MATE.gt_melt_part_select = int(MATE.d_melt_gt_items.index(item))

		MATE.melt_partitions_calculated = False

	def open_px_window(self):

		self.px_pop = PYROXENE_POP()
		self.px_pop.setGeometry(QtCore.QRect(100, 100, 1200, 100))
		self.px_pop.show()

	def open_hydr(self):

		if self.hydr_pop is None:
			self.hydr_pop = HYDR_POP()
			self.hydr_pop.setGeometry(QtCore.QRect(100, 100, 100, 100))
		self.hydr_pop.show()

	def w_part_info_box(self):

		str_wt_part = "Water partitions unequally between the nominally anhydrous mantle minerals. The user can choose between various different experimental constraints to define this partitioning."\
		" Pyroxenes can either be handled together, where orthopyroxene and clinopyroxene are assumed to have the same water partitioning relationships with olivine and garnet,"\
		" or handled independently, where water is assumed to partition unequally between orthopyroxene and clinopyroxene."\
		" The user also has the ability to turn on/off partitioning of water into hydrous minerals.\n\n"\
		"Pyroxene partitioning models can be implemented through other entered parameters from lithospheric column (e.g., P,T,Al-in-opx)."\
		" Types of models in relation to the parameters that are being denoted in the front as follows:\n\n"\
		"- Type 1: Al-dependent function over all pressure range.\n"\
		"This type of partitoning function is dependent on the Al content in opx over the whole lithospheric block.\n\n"\
		"- Type 2: Al-dependent functions over two-distinct pressure ranges.\n"\
		"This type of partitioning function is dependent on the Al content in opx over two distinct pressure ranges.\n\n"\
		"- Type 3: Pressure dependent function.\n"\
		"Pyroxene water partitioning is dependent only on pressure throughout the lithopsheric column.\n\n"\
		"- Type 4: Single value partitioning rate.\n"\
		"Single value partitioning rate, not dependent on pressure or Al content.\n\n"\
		"- Type 5: cpx/opx dependent function.\n"\
		"cpx or opx water content dependent on more stable cpx/opx partitioning rates with a defined function."\
		"If this type of model is selected, water of cpx will be determined via orthoyproxene water content."


		QMessageBox.about(self, "Info on this",str_wt_part)

class HYDR_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		hydr_layout = QFormLayout(self)

		self.hydr_label = QLabel(self)
		self.hydr_label.setText('Hydrous Minerals Included in H-partitioning scheme?')
		hydr_layout.addRow(self.hydr_label)

		self.hydr_radio_1 = QRadioButton("True")
		self.hydr_radio_1.toggled.connect(lambda:self.btnstate_hydr(self.hydr_radio_1))
		self.hydr_radio_2 = QRadioButton("False")
		self.hydr_radio_2.toggled.connect(lambda:self.btnstate_hydr(self.hydr_radio_2))

		if MATE.hydr_part_method == 0:
			self.hydr_radio_1.setChecked(True)
		elif MATE.hydr_part_method == 1:
			self.hydr_radio_2.setChecked(True)

		hydr_layout.addRow(self.hydr_radio_1,self.hydr_radio_2)

	def btnstate_hydr(self,b):

		if b.text() == "True":
			if b.isChecked() == True:
				MATE.hydr_part_method = 0
		elif b.text() == "False":
			if b.isChecked() == True:
				MATE.hydr_part_method = 1

class PYROXENE_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		pyx_layout = QFormLayout(self)

		self.btn1_part = QPushButton("Opx/Ol")
		self.btn2_part = QPushButton("Cpx/Ol")

		self.btn1_part_textbox = QLineEdit(MATE.opx_display)
		self.btn1_part_textbox.setEnabled(False)
		self.btn2_part_textbox = QLineEdit(MATE.cpx_display)
		self.btn2_part_textbox.setEnabled(False)

		if MATE.part_px_method == '0':
			self.btn1_part.clicked.connect(self.get_pxol)
			self.btn2_part.clicked.connect(self.get_pxol)
		elif MATE.part_px_method == '1':
			self.btn1_part.clicked.connect(self.get_opxol)
			self.btn2_part.clicked.connect(self.get_cpxol)

		pyx_layout.addRow(self.btn1_part,self.btn1_part_textbox)
		pyx_layout.addRow(self.btn2_part,self.btn2_part_textbox)

	def get_pxol(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Partitioning method", MATE.d_px_display_items, 0, False)

		if ok and item:
			self.btn1_part_textbox.setText(item)
			self.btn2_part_textbox.setText(item)

		MATE.opx_display = item
		MATE.cpx_display = item

		MATE.cpx_part_select = int(MATE.d_px_items.index(item)) * -1
		MATE.opx_part_select = int(MATE.d_px_items.index(item)) * -1

	def get_opxol(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Partitioning method", MATE.d_opx_display_items, 0, False)

		if ok and item:
			self.btn1_part_textbox.setText(item)

		MATE.opx_display = item

		MATE.opx_part_select = int(MATE.d_opx_items.index(item))

		MATE.mineral_partitions_calculated = False

	def get_cpxol(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Partitioning method", MATE.d_cpx_display_items, 0, False)

		if ok and item:
			self.btn2_part_textbox.setText(item)

		MATE.cpx_display = item

		MATE.cpx_part_select = int(MATE.d_cpx_items.index(item))

		MATE.mineral_partitions_calculated = False

class XEN_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		xen_layout = QFormLayout(self)

		self.xen_btn_1 = QPushButton("Temperature")
		self.xen_btn_1.clicked.connect(self.get_xen_temp)

		self.xen_btn_2 = QPushButton("Depth-Pressure")
		self.xen_btn_2.clicked.connect(self.get_xen_pressure)

		self.xen_btn_3 = QPushButton("Temperature Uncertainty")
		self.xen_btn_3_txt = QLineEdit(str(MATE.xen_temp_err))
		self.xen_btn_3_txt.setEnabled(False)
		self.xen_btn_3.clicked.connect(self.get_xen_temp_uncert)

		self.xen_btn_4 = QPushButton("Pressure-Depth Uncertainty")
		self.xen_btn_4_txt = QLineEdit(str(MATE.xen_pressure_err))
		self.xen_btn_4_txt.setEnabled(False)
		self.xen_btn_4.clicked.connect(self.get_xen_pressure_uncert)

		xen_layout.addRow(self.xen_btn_1)
		xen_layout.addRow(self.xen_btn_2)
		xen_layout.addRow(self.xen_btn_3,self.xen_btn_3_txt)
		xen_layout.addRow(self.xen_btn_4,self.xen_btn_4_txt)

		self.xen_temp_pop = None
		self.xen_p_pop = None

		self.xen_infobtn = QPushButton('Info')
		self.xen_infobtn.clicked.connect(self.xen_info)
		xen_layout.addRow(self.xen_infobtn)

	def get_xen_temp(self):

		if self.xen_temp_pop is None:
			self.xen_temp_pop = XEN_TEMP_POP()
			self.xen_temp_pop.setGeometry(QtCore.QRect(100, 100, 100, 100))
		self.xen_temp_pop.show()

	def get_xen_pressure(self):

		if self.xen_p_pop is None:
			self.xen_p_pop = XEN_P_POP()
			self.xen_p_pop.setGeometry(QtCore.QRect(100, 100, 100, 100))
		self.xen_p_pop.show()

	def get_xen_temp_uncert(self):

		text, ok = QInputDialog.getText(self, 'Value-based error', 'Enter the value in absolute temperature for Kelvin and Celsius')
		if ok:
			try:
				float(text)
				self.xen_btn_3_txt.setText(str(text))
				MATE.xen_temp_err = float(text)
			except ValueError:
				QMessageBox.about(self,"Warning!","Please enter a value that can be converted to floating number.")

	def get_xen_pressure_uncert(self):

		text, ok = QInputDialog.getText(self, 'Value-based error', 'Enter the value in GPa')
		if ok:
			try:
				float(text)
				self.xen_btn_4_txt.setText(str(text))
				MATE.xen_pressure_err = float(text)
			except ValueError:
				QMessageBox.about(self,"Warning!","Please enter a value that can be converted to floating number.")

	def xen_info(self):

		str_xen = "Here the user can enter the thermobarometric results dependent on selections on the units."\
		" You can enter uncertainties in one standard deviation here in temperature and pressure (Depth has to be entered in pressure(GPa) as well)."
		QMessageBox.about(self, "Info on this", str_xen)

class XEN_TEMP_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		xen_temp_layout = QVBoxLayout(self)

		self.xen_temp_radio_1 = QRadioButton("Kelvin")
		self.xen_temp_radio_1.toggled.connect(lambda:self.btnstate_temp_xen(self.xen_temp_radio_1))
		self.xen_temp_radio_2 = QRadioButton("Celsius")
		self.xen_temp_radio_2.toggled.connect(lambda:self.btnstate_temp_xen(self.xen_temp_radio_2))

		if MATE.z_xen_method_2 == '0':
			self.xen_temp_radio_1.setChecked(True)
		elif MATE.z_xen_method_2 == '1':
			self.xen_temp_radio_2.setChecked(True)

		xen_temp_layout.addWidget(self.xen_temp_radio_1)
		xen_temp_layout.addWidget(self.xen_temp_radio_2)

	def btnstate_temp_xen(self,b):

		if b.text() == "Kelvin":
			if b.isChecked() == True:
				MATE.z_xen_method_2 = '0'
		elif b.text() == "Celsius":
			if b.isChecked() == True:
				MATE.z_xen_method_2 = '1'

class XEN_P_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		xen_P_layout = QVBoxLayout(self)

		self.xen_P_radio_1 = QRadioButton("Pressure(GPa)")
		self.xen_P_radio_1.toggled.connect(lambda:self.btnstate_P_xen(self.xen_P_radio_1))
		self.xen_P_radio_2 = QRadioButton("Depth(km)")
		self.xen_P_radio_2.toggled.connect(lambda:self.btnstate_P_xen(self.xen_P_radio_2))

		if MATE.z_xen_method == '0':
			self.xen_P_radio_1.setChecked(True)
		elif MATE.z_xen_method == '1':
			self.xen_P_radio_2.setChecked(True)

		xen_P_layout.addWidget(self.xen_P_radio_1)
		xen_P_layout.addWidget(self.xen_P_radio_2)

	def btnstate_P_xen(self,b):

		if b.text() == "Pressure(GPa)":
			if b.isChecked() == True:
				MATE.z_xen_method = '0'
		elif b.text() == "Depth(km)":
			if b.isChecked() == True:
				MATE.z_xen_method = '1'

class FUG_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		fug_layout = QVBoxLayout(self)

		self.fug_radio_1 = QRadioButton("FMQ")
		self.fug_radio_2 = QRadioButton("IW")
		self.fug_radio_3 = QRadioButton("QIF")
		self.fug_radio_4 = QRadioButton("NNO")
		self.fug_radio_5 = QRadioButton("MMO")
		self.fug_radio_6 = QRadioButton("LOAD DATA log(FMQ) format")

		self.fug_radio_1.toggled.connect(lambda:self.btnstate_fug(self.fug_radio_1))
		self.fug_radio_2.toggled.connect(lambda:self.btnstate_fug(self.fug_radio_2))
		self.fug_radio_3.toggled.connect(lambda:self.btnstate_fug(self.fug_radio_3))
		self.fug_radio_4.toggled.connect(lambda:self.btnstate_fug(self.fug_radio_4))
		self.fug_radio_5.toggled.connect(lambda:self.btnstate_fug(self.fug_radio_5))
		self.fug_radio_6.toggled.connect(lambda:self.btnstate_fug(self.fug_radio_6))

		if MATE.o2_buffer == 0:
			self.fug_radio_1.setChecked(True)
		elif MATE.o2_buffer == 1:
			self.fug_radio_2.setChecked(True)
		elif MATE.o2_buffer == 2:
			self.fug_radio_3.setChecked(True)
		elif MATE.o2_buffer == 3:
			self.fug_radio_4.setChecked(True)
		elif MATE.o2_buffer == 4:
			self.fug_radio_5.setChecked(True)
		elif MATE.o2_buffer == 5:
			self.fug_radio_6.setChecked(True)

		fug_layout.addWidget(self.fug_radio_1)
		fug_layout.addWidget(self.fug_radio_2)
		fug_layout.addWidget(self.fug_radio_3)
		fug_layout.addWidget(self.fug_radio_4)
		fug_layout.addWidget(self.fug_radio_5)
		fug_layout.addWidget(self.fug_radio_6)

	def btnstate_fug(self,b):

		if b.text() == "FMQ":
			if b.isChecked() == True:
				MATE.o2_buffer = 0
		elif b.text() == "IW":
			if b.isChecked() == True:
				MATE.o2_buffer = 1
		elif b.text() == "QIF":
			if b.isChecked() == True:
				MATE.o2_buffer = 2
		elif b.text() == "NNO":
			if b.isChecked() == True:
				MATE.o2_buffer = 3
		elif b.text() == "MMO":
			if b.isChecked() == True:
				MATE.o2_buffer = 4
		elif b.text() == "LOAD DATA log(FMQ) format":
			if b.isChecked() == True:
				MATE.o2_buffer = 5

class OL_CALIB_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		calib_layout = QVBoxLayout(self)

		self.calib_radio_0 = QRadioButton("Default")
		self.calib_radio_1 = QRadioButton("Withers2012")
		self.calib_radio_2 = QRadioButton("Bell2003")
		self.calib_radio_3 = QRadioButton("Paterson1980")

		self.calib_radio_0.toggled.connect(lambda:self.btnstate_calib(self.calib_radio_0))
		self.calib_radio_1.toggled.connect(lambda:self.btnstate_calib(self.calib_radio_1))
		self.calib_radio_2.toggled.connect(lambda:self.btnstate_calib(self.calib_radio_2))
		self.calib_radio_3.toggled.connect(lambda:self.btnstate_calib(self.calib_radio_3))

		if MATE.ol_calib == 0:
			self.calib_radio_1.setChecked(True)
		elif MATE.ol_calib == 1:
			self.calib_radio_2.setChecked(True)
		elif MATE.ol_calib == 2:
			self.calib_radio_3.setChecked(True)
		elif MATE.ol_calib == 3:
			self.calib_radio_0.setChecked(True)

		calib_layout.addWidget(self.calib_radio_0)
		calib_layout.addWidget(self.calib_radio_2)
		calib_layout.addWidget(self.calib_radio_3)
		calib_layout.addWidget(self.calib_radio_1)

		self.ol_calib_info = QPushButton('Info')
		self.ol_calib_info.clicked.connect(self.ol_info_box)

		calib_layout.addWidget(self.ol_calib_info)

	def btnstate_calib(self,b):

		if b.text() == "Withers2012":
			if b.isChecked() == True:
				MATE.ol_calib = 0
		elif b.text() == "Bell2003":
			if b.isChecked() == True:
				MATE.ol_calib = 1
		elif b.text() == "Paterson1980":
			if b.isChecked() == True:
				MATE.ol_calib = 2
		elif b.text() == "Default":
			if b.isChecked() == True:
				MATE.ol_calib = 3

	def ol_info_box(self):

		QMessageBox.about(self, "Info on this", "This preferential settings relates to the selection of fixes related to water-calibrations."+
		" Calibration method selected here affects the water-uptake of conductivity models and calculated solubility models.")

class OL_CALIB_SOL_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		calib_layout = QVBoxLayout(self)

		self.calib_radio_0 = QRadioButton("Default")
		self.calib_radio_1 = QRadioButton("Withers2012")
		self.calib_radio_2 = QRadioButton("Bell2003")
		self.calib_radio_3 = QRadioButton("Paterson1980")

		self.calib_radio_0.toggled.connect(lambda:self.btnstate_calib(self.calib_radio_0))
		self.calib_radio_1.toggled.connect(lambda:self.btnstate_calib(self.calib_radio_1))
		self.calib_radio_2.toggled.connect(lambda:self.btnstate_calib(self.calib_radio_2))
		self.calib_radio_3.toggled.connect(lambda:self.btnstate_calib(self.calib_radio_3))

		if MATE.ol_sol_calib == 0:
			self.calib_radio_1.setChecked(True)
		elif MATE.ol_sol_calib == 1:
			self.calib_radio_2.setChecked(True)
		elif MATE.ol_sol_calib == 2:
			self.calib_radio_3.setChecked(True)
		elif MATE.ol_sol_calib == 3:
			self.calib_radio_0.setChecked(True)

		calib_layout.addWidget(self.calib_radio_0)
		calib_layout.addWidget(self.calib_radio_2)
		calib_layout.addWidget(self.calib_radio_3)
		calib_layout.addWidget(self.calib_radio_1)

		self.ol_calib_info = QPushButton('Info')
		self.ol_calib_info.clicked.connect(self.ol_info_box)

		calib_layout.addWidget(self.ol_calib_info)

	def btnstate_calib(self,b):

		if b.text() == "Withers2012":
			if b.isChecked() == True:
				MATE.ol_sol_calib = 0
		elif b.text() == "Bell2003":
			if b.isChecked() == True:
				MATE.ol_sol_calib = 1
		elif b.text() == "Paterson1980":
			if b.isChecked() == True:
				MATE.ol_sol_calib = 2
		elif b.text() == "Default":
			if b.isChecked() == True:
				MATE.ol_sol_calib = 3

	def ol_info_box(self):

		QMessageBox.about(self, "Info on this", "This preferential settings relates to the selection of fixes related to water-calibrations."+
		" Calibration method selected here affects the water-uptake of conductivity models and calculated solubility models.")

class PX_CALIB_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		px_calib_layout = QVBoxLayout(self)

		self.px_calib_radio_0 = QRadioButton("Default")
		self.px_calib_radio_1 = QRadioButton("Bell1995")
		self.px_calib_radio_2 = QRadioButton("Paterson1980")

		self.px_calib_radio_0.toggled.connect(lambda:self.btnstate_px_calib(self.px_calib_radio_0))
		self.px_calib_radio_1.toggled.connect(lambda:self.btnstate_px_calib(self.px_calib_radio_1))
		self.px_calib_radio_2.toggled.connect(lambda:self.btnstate_px_calib(self.px_calib_radio_2))

		if MATE.px_calib == 0:
			self.px_calib_radio_1.setChecked(True)
		elif MATE.px_calib == 1:
			self.px_calib_radio_2.setChecked(True)
		elif MATE.px_calib == 2:
			self.px_calib_radio_0.setChecked(True)

		px_calib_layout.addWidget(self.px_calib_radio_0)
		px_calib_layout.addWidget(self.px_calib_radio_1)
		px_calib_layout.addWidget(self.px_calib_radio_2)

		self.px_calib_info = QPushButton('Info')
		self.px_calib_info.clicked.connect(self.px_info_box)

		px_calib_layout.addWidget(self.px_calib_info)

	def btnstate_px_calib(self,b):

		if b.text() == "Bell1995":
			if b.isChecked() == True:
				MATE.px_calib = 0
		elif b.text() == "Paterson1980":
			if b.isChecked() == True:
				MATE.px_calib = 1
		elif b.text() == "Default":
			if b.isChecked() == True:
				MATE.px_calib = 2

	def px_info_box(self):

		QMessageBox.about(self, "Info on this", "This preferential settings relates to the selection of fixes related to water-calibrations."+
		" Calibration method selected here affects the water-uptake of conductivity models and calculated solubility models.")

class COND_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		conduc_layout = QFormLayout(self)

		self.model_method_button = QPushButton('Model Methods')
		self.model_method_button.clicked.connect(self.model_method_get)

		self.ol_cond_btn = QPushButton('Ol Model')
		self.ol_cond_text_box = QLineEdit(MATE.name[0][MATE.ol_cond_selection])
		self.ol_cond_text_box.setEnabled(False)
		self.px_cond_btn = QPushButton('Px Models')
		self.gt_cond_btn = QPushButton('Gt Model')
		self.gt_cond_text_box = QLineEdit(MATE.name[3][MATE.gt_cond_selection])
		self.gt_cond_text_box.setEnabled(False)
		self.amp_cond_btn = QPushButton('Amp Model')
		self.amp_cond_text_box = QLineEdit(MATE.name[4][MATE.amp_cond_selection])
		self.amp_cond_text_box.setEnabled(False)
		self.pl_cond_btn = QPushButton('Phlg Model')
		self.pl_cond_text_box = QLineEdit(MATE.name[5][MATE.pl_cond_selection])
		self.pl_cond_text_box.setEnabled(False)
		self.sp_chr_cond_btn = QPushButton('Sp-Chr Model')
		self.sp_chr_cond_text_box = QLineEdit(MATE.name[6][MATE.sp_chr_cond_selection])
		self.sp_chr_cond_text_box.setEnabled(False)
		self.melt_cond_btn = QPushButton('Melt Model')
		self.melt_cond_text_box = QLineEdit(MATE.name[7][MATE.melt_cond_selection])
		self.melt_cond_text_box.setEnabled(False)

		self.ol_cond_btn.clicked.connect(self.ol_cond_get)

		self.px_cond_radio_1 = QRadioButton("Px handled independently")
		self.px_cond_radio_2 = QRadioButton("Px handled together")

		self.px_cond_radio_1.toggled.connect(lambda:self.btnstate_px_cond(self.px_cond_radio_1))
		self.px_cond_radio_2.toggled.connect(lambda:self.btnstate_px_cond(self.px_cond_radio_2))

		if MATE.px_cond_method == 0:
			self.px_cond_radio_1.setChecked(True)
		elif MATE.px_cond_method == 1:
			self.px_cond_radio_2.setChecked(True)

		self.px_cond_btn.clicked.connect(self.px_cond_pop_btn)
		self.gt_cond_btn.clicked.connect(self.gt_cond_get)
		self.amp_cond_btn.clicked.connect(self.amp_cond_get)
		self.pl_cond_btn.clicked.connect(self.pl_cond_get)
		self.sp_chr_cond_btn.clicked.connect(self.sp_chr_cond_get)
		self.melt_cond_btn.clicked.connect(self.melt_cond_get)

		self.gen_cond_infobtn = QPushButton('Info')
		self.gen_cond_infobtn.clicked.connect(self.gen_cond_info)

		conduc_layout.addRow(self.model_method_button)
		conduc_layout.addRow(self.ol_cond_btn,self.ol_cond_text_box)
		conduc_layout.addRow(self.px_cond_radio_1,self.px_cond_radio_2)
		conduc_layout.addRow(self.px_cond_btn)
		conduc_layout.addRow(self.gt_cond_btn,self.gt_cond_text_box)
		conduc_layout.addRow(self.sp_chr_cond_btn,self.sp_chr_cond_text_box)
		conduc_layout.addRow(self.amp_cond_btn,self.amp_cond_text_box)
		conduc_layout.addRow(self.pl_cond_btn,self.pl_cond_text_box)
		conduc_layout.addRow(self.melt_cond_btn,self.melt_cond_text_box)
		conduc_layout.addRow(self.gen_cond_infobtn)


		self.px_cond_pop = None
		self.model_method_pop = None

	def ol_cond_get(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Conductivity model", MATE.name[0], 0, False)

		if ok and item:
			self.ol_cond_text_box.setText(item)

		MATE.ol_cond_selection = MATE.name[0].index(item)

	def gt_cond_get(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Conductivity model", MATE.name[3], 0, False)

		if ok and item:
			self.gt_cond_text_box.setText(item)

		MATE.gt_cond_selection = MATE.name[3].index(item)

	def amp_cond_get(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Conductivity model", MATE.name[4], 0, False)

		if ok and item:
			self.amp_cond_text_box.setText(item)

		MATE.amp_cond_selection = MATE.name[4].index(item)

	def pl_cond_get(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Conductivity model", MATE.name[5], 0, False)

		if ok and item:
			self.pl_cond_text_box.setText(item)

		MATE.pl_cond_selection = MATE.name[5].index(item)

	def sp_chr_cond_get(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Conductivity model", MATE.name[6], 0, False)

		if ok and item:
			self.sp_chr_cond_text_box.setText(item)

		MATE.sp_chr_cond_selection = MATE.name[6].index(item)

	def melt_cond_get(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Conductivity model", MATE.name[7], 0, False)

		if ok and item:
			self.melt_cond_text_box.setText(item)

		MATE.melt_cond_selection = MATE.name[7].index(item)

	def px_cond_pop_btn(self):

		if self.px_cond_pop is None:
			self.px_cond_pop = PX_COND_POP()
			self.px_cond_pop.setGeometry(QtCore.QRect(100, 100, 400, 400))
		self.px_cond_pop.show()

	def btnstate_px_cond(self,b):

		if b.text() == "Px handled independently":
			if b.isChecked() == True:
				MATE.px_cond_method = 0
		elif b.text() == "Px handled together":
			if b.isChecked() == True:
				MATE.px_cond_method = 1

	def model_method_get(self):

		if self.model_method_pop is None:
			self.model_method_pop = MODEL_GET()
			self.model_method_pop.setGeometry(QtCore.QRect(100, 100, 400, 100))
		self.model_method_pop.show()

	def gen_cond_info(self):

		str_cond = "Various experimental and theoretical models have been proposed "\
		"for the electrical conductivity of the mantle minerals olivine, orthopyroxene, "\
		"clinopyroxene and garnet. Here, the user can select which conductivity models "\
		"will be used in the overall conductivity calculation. Pyroxenes can either be "\
		"handled together (where the conductivity of orthopyroxene and clinopyroxene "\
		"is assumed to be the same) or individually. Many experimental models focus "\
		"on proton conduction. Through the ‘Model Method’ button, the user can decide "\
		"whether to take all conduction parameters from the chosen model or only the proton "\
		"conductivity. In the latter case, the dry conductivity will be taken from the Dry "\
		"Conductivity selection on the upper menu bar.\n\n"\
		"* Models including iron dependency\n\n ** Models with higher Fe content sample (might not be representative of usual mantle.)\n\n"\
		"*** Models including effects of oxygen fugacity.\n\n"\
		"**** Models derived from lattice hydrogen diffusion measurements via the Nernst-Einstein equation.\n\n"\
		"***** Models derived from lattice and grain boundary hydrogen diffusion measurements via the Nernst-Einstein equation and effective diffusivity."

		QMessageBox.about(self, "Info on this", str_cond)

class MODEL_GET(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		self.modelget_layout = QFormLayout(self)

		self.ol_model_method_btn = QPushButton('Ol Method')
		self.ol_model_method_btn_text_box = QLineEdit(MATE.model_method_list[MATE.model_method_ol])
		self.ol_model_method_btn_text_box.setEnabled(False)
		self.ol_model_method_btn.clicked.connect(self.ol_model_method_get)
		self.modelget_layout.addRow(self.ol_model_method_btn,self.ol_model_method_btn_text_box)

		self.opx_model_method_btn = QPushButton('Opx Method')
		self.opx_model_method_btn_text_box = QLineEdit(MATE.model_method_list[MATE.model_method_opx])
		self.opx_model_method_btn_text_box.setEnabled(False)
		self.opx_model_method_btn.clicked.connect(self.opx_model_method_get)
		self.modelget_layout.addRow(self.opx_model_method_btn,self.opx_model_method_btn_text_box)

		self.cpx_model_method_btn = QPushButton('Cpx Method')
		self.cpx_model_method_btn_text_box = QLineEdit(MATE.model_method_list[MATE.model_method_cpx])
		self.cpx_model_method_btn_text_box.setEnabled(False)
		self.cpx_model_method_btn.clicked.connect(self.cpx_model_method_get)
		self.modelget_layout.addRow(self.cpx_model_method_btn,self.cpx_model_method_btn_text_box)

		self.gt_model_method_btn = QPushButton('Gt Method')
		self.gt_model_method_btn_text_box = QLineEdit(MATE.model_method_list[MATE.model_method_gt])
		self.gt_model_method_btn_text_box.setEnabled(False)
		self.gt_model_method_btn.clicked.connect(self.gt_model_method_get)
		self.modelget_layout.addRow(self.gt_model_method_btn,self.gt_model_method_btn_text_box)

		self.model_get_infobtn = QPushButton('Info')
		self.model_get_infobtn.clicked.connect(self.model_get_info)
		self.modelget_layout.addRow(self.model_get_infobtn)

	def model_get_info(self):

		QMessageBox.about(self, "Info on this", "This section allows user to choose between using proton conduction model only or the whole model. If proton method is selected, dry conductivities" +
		"will be chosen from Dry Conductivity section on the Menu.")

	def ol_model_method_get(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Conductivity model", MATE.model_method_list, 0, False)

		if ok and item:
			self.ol_model_method_btn_text_box.setText(item)

		MATE.model_method_ol = MATE.model_method_list.index(item)
		MATE.model_method[0] = MATE.model_method_ol

	def opx_model_method_get(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Conductivity model", MATE.model_method_list, 0, False)

		if ok and item:
			self.opx_model_method_btn_text_box.setText(item)

		MATE.model_method_opx = MATE.model_method_list.index(item)
		MATE.model_method[1] = MATE.model_method_opx

	def cpx_model_method_get(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Conductivity model", MATE.model_method_list, 0, False)

		if ok and item:
			self.cpx_model_method_btn_text_box.setText(item)

		MATE.model_method_cpx = MATE.model_method_list.index(item)
		MATE.model_method[2] = MATE.model_method_cpx

	def gt_model_method_get(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Conductivity model", MATE.model_method_list, 0, False)

		if ok and item:
			self.gt_model_method_btn_text_box.setText(item)

		MATE.model_method_gt = MATE.model_method_list.index(item)
		MATE.model_method[3] = MATE.model_method_gt

class PX_COND_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		px_cond_layout = QFormLayout(self)

		self.adjust_px_cond()

		self.opx_cond_btn = QPushButton('Opx Model')
		self.opx_cond_text_box = QLineEdit(MATE.name[1][MATE.opx_cond_selection])
		self.opx_cond_text_box.setEnabled(False)
		self.cpx_cond_btn = QPushButton('Cpx Model')
		if MATE.px_cond_method == 0:
			self.cpx_cond_text_box = QLineEdit(MATE.name[2][MATE.cpx_cond_selection])
			self.cpx_cond_text_box.setEnabled(False)
		else:
			self.cpx_cond_text_box = QLineEdit(self.px_cond_display_list[MATE.px_display_item])
			self.cpx_cond_text_box.setEnabled(False)

		self.opx_cond_btn.clicked.connect(self.opx_cond_get)

		if MATE.px_cond_method == 0:
			self.cpx_cond_btn.clicked.connect(self.cpx_cond_get)
		elif MATE.px_cond_method == 1:
			self.cpx_cond_btn.clicked.connect(self.opx_cond_get)

		self.px_cond_infobtn = QPushButton('Info')
		self.px_cond_infobtn.clicked.connect(self.px_cond_info)

		px_cond_layout.addRow(self.opx_cond_btn,self.opx_cond_text_box)
		px_cond_layout.addRow(self.cpx_cond_btn,self.cpx_cond_text_box)
		px_cond_layout.addRow(self.px_cond_infobtn)

	def adjust_px_cond(self):

		self.px_cond_display_list = []

		if MATE.px_cond_method == 0:

			for i in MATE.name[1]:
				self.px_cond_display_list.append(i)
		else:
			for i in MATE.name[1]:
				self.px_cond_display_list.append(i)
			for i in MATE.name[2]:
				self.px_cond_display_list.append(i)

	def opx_cond_get(self):
		self.adjust_px_cond()
		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Conductivity model", self.px_cond_display_list, 0, False)

		if ok and item:
			self.opx_cond_text_box.setText(item)
			MATE.px_display_item = self.px_cond_display_list.index(item)
			if MATE.px_cond_method == 1:
				self.cpx_cond_text_box.setText(item)
			else:
				pass
		if MATE.px_cond_method == 1:
			if self.px_cond_display_list.index(item) > len(MATE.name[1]):
				if MATE.name[2].index(item) != 0:
					MATE.opx_cond_selection = -1 * MATE.name[2].index(item)
				else:
					MATE.opx_cond_selection = -999 #This is a bit spaghetti but it works...
				MATE.cpx_cond_selection = MATE.name[2].index(item)
			else:
				MATE.opx_cond_selection = MATE.name[1].index(item)
				if MATE.name[1].index(item) != 0:
					MATE.cpx_cond_selection = -1 * MATE.name[1].index(item)
				else:
					MATE.cpx_cond_selection = -999 #This is a bit spaghetti but it works...

		else:

			MATE.opx_cond_selection = MATE.name[1].index(item)

	def cpx_cond_get(self):

		self.adjust_px_cond()

		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Conductivity model", MATE.name[2], 0, False)

		if ok and item:
			self.cpx_cond_text_box.setText(item)

		MATE.cpx_cond_selection = MATE.name[2].index(item)

	def px_cond_info(self):

		QMessageBox.about(self, "Info on this", "Select pyroxene conductivity model. Keep in mind that the selection to handling them together" +
		"could be selected. If so, opx and cpx boxes will show the same list of models.\n\n" +
		"* Models including iron dependency\n ** Models with higher Fe content sample (might not be representative of usual mantle.)\n")

class DRY_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		dry_cond_layout = QFormLayout(self)

		self.dry_cond_btn1 = QPushButton('Olivine Model')
		self.dry_cond_btn1.clicked.connect(self.get_ol_dry)
		self.dry_cond_textbox = QLineEdit(MATE.name_dry[0][MATE.ol_dry_selection])
		self.dry_cond_textbox.setEnabled(False)
		self.dry_cond_btn2 = QPushButton('Opx Model')
		self.dry_cond_btn2.clicked.connect(self.get_opx_dry)
		self.dry_cond_textbox_2 = QLineEdit(MATE.name_dry[1][MATE.opx_dry_selection])
		self.dry_cond_textbox_2.setEnabled(False)
		self.dry_cond_btn3 = QPushButton('Cpx Model')
		self.dry_cond_btn3.clicked.connect(self.get_cpx_dry)
		self.dry_cond_textbox_3 = QLineEdit(MATE.name_dry[2][MATE.cpx_dry_selection])
		self.dry_cond_textbox_3.setEnabled(False)
		self.dry_cond_btn4 = QPushButton('Gt Model')
		self.dry_cond_btn4.clicked.connect(self.get_gt_dry)
		self.dry_cond_textbox_4 = QLineEdit(MATE.name_dry[3][MATE.gt_dry_selection])
		self.dry_cond_textbox_4.setEnabled(False)
		self.dry_cond_infobtn = QPushButton('Info')
		self.dry_cond_infobtn.clicked.connect(self.dry_cond_info)

		dry_cond_layout.addRow(self.dry_cond_btn1,self.dry_cond_textbox)
		dry_cond_layout.addRow(self.dry_cond_btn2,self.dry_cond_textbox_2)
		dry_cond_layout.addRow(self.dry_cond_btn3,self.dry_cond_textbox_3)
		dry_cond_layout.addRow(self.dry_cond_btn4,self.dry_cond_textbox_4)
		dry_cond_layout.addRow(self.dry_cond_infobtn)

	def get_ol_dry(self):
		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Conductivity model", MATE.name_dry[0], 0, False)

		if ok and item:
			self.dry_cond_textbox.setText(item)

		MATE.ol_dry_selection = MATE.name_dry[0].index(item)

	def get_opx_dry(self):
		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Conductivity model", MATE.name_dry[1], 0, False)

		if ok and item:
			self.dry_cond_textbox_2.setText(item)

		MATE.opx_dry_selection = MATE.name_dry[1].index(item)

	def get_cpx_dry(self):
		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Conductivity model", MATE.name_dry[2], 0, False)

		if ok and item:
			self.dry_cond_textbox_3.setText(item)

		MATE.cpx_dry_selection = MATE.name_dry[2].index(item)

	def get_gt_dry(self):
		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Conductivity model", MATE.name_dry[3], 0, False)

		if ok and item:
			self.dry_cond_textbox_4.setText(item)

		MATE.gt_dry_selection = MATE.name_dry[3].index(item)

	def dry_cond_info(self):

		QMessageBox.about(self, "Info on this", "Ionic and polaron conductivities that will be used if these parameters are not provided by the " +
		"conductivity models selected or if the user chooses a model method that excludes dry conductivities.\n\n" +
		"* Models including iron dependency\n ** Models with higher Fe content sample (might not be representative of normal mantle.)\n" +
		"*** Models including effects of oxygen fugacity.\n" +
		"**** Models including the effects of shear stress on polaron conductivity of a sample.")

class PHS_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		phs_mix_layout = QVBoxLayout(self)

		self.label_1_mixing = QLabel(self)
		self.label_1_mixing.setText('--------Solid-State Mixing--------')
		phs_mix_layout.addWidget(self.label_1_mixing)

		bg1 = QButtonGroup(self)

		self.btn_mix_1 = QRadioButton("Generalized Archie's Law (Glover, 2010)")
		self.btn_mix_1.toggled.connect(lambda:self.btnstate_phsmix(self.btn_mix_1))
		self.btn_mix_2 = QRadioButton("Hashin-Shtrikman Lower Bound (Berryman, 1995)")
		self.btn_mix_2.toggled.connect(lambda:self.btnstate_phsmix(self.btn_mix_2))
		self.btn_mix_3 = QRadioButton("Hashin-Shtrikman Upper Bound (Berryman, 1995)")
		self.btn_mix_3.toggled.connect(lambda:self.btnstate_phsmix(self.btn_mix_3))
		self.btn_mix_4 = QRadioButton("Parallel Model (Guegen and Palciauskas, 1994)")
		self.btn_mix_4.toggled.connect(lambda:self.btnstate_phsmix(self.btn_mix_4))
		self.btn_mix_5 = QRadioButton("Perpendicular Model (Guegen and Palciauskas, 1994)")
		self.btn_mix_5.toggled.connect(lambda:self.btnstate_phsmix(self.btn_mix_5))
		self.btn_mix_6 = QRadioButton("Random Model (Guegen and Palciauskas, 1994)")
		self.btn_mix_6.toggled.connect(lambda:self.btnstate_phsmix(self.btn_mix_6))

		if MATE.phs_mix_method == 0:
			self.btn_mix_1.setChecked(True)
		elif MATE.phs_mix_method == 1:
			self.btn_mix_2.setChecked(True)
		elif MATE.phs_mix_method == 2:
			self.btn_mix_3.setChecked(True)
		elif MATE.phs_mix_method == 3:
			self.btn_mix_4.setChecked(True)
		elif MATE.phs_mix_method == 4:
			self.btn_mix_5.setChecked(True)
		elif MATE.phs_mix_method == 5:
			self.btn_mix_6.setChecked(True)

		self.prop_info_btn = QPushButton("Info")
		self.prop_info_btn.clicked.connect(self.mixing_info)


		bg1.addButton(self.btn_mix_1)
		bg1.addButton(self.btn_mix_2)
		bg1.addButton(self.btn_mix_3)
		bg1.addButton(self.btn_mix_4)
		bg1.addButton(self.btn_mix_5)
		bg1.addButton(self.btn_mix_6)

		phs_mix_layout.addWidget(self.btn_mix_1)
		phs_mix_layout.addWidget(self.btn_mix_2)
		phs_mix_layout.addWidget(self.btn_mix_3)
		phs_mix_layout.addWidget(self.btn_mix_4)
		phs_mix_layout.addWidget(self.btn_mix_5)
		phs_mix_layout.addWidget(self.btn_mix_6)


		self.label_2_mixing = QLabel(self)
		self.label_2_mixing.setText('')
		phs_mix_layout.addWidget(self.label_2_mixing)

		self.label_3_mixing = QLabel(self)
		self.label_3_mixing.setText('--------Melt-Solid Mixing--------')
		phs_mix_layout.addWidget(self.label_3_mixing)

		self.btn_mix_melt_1 = QRadioButton("Modified Archie's Law (Glover et al., 2000)")
		self.btn_mix_melt_1.toggled.connect(lambda:self.btnstate_phsmix_melt(self.btn_mix_melt_1))
		self.btn_mix_melt_2 = QRadioButton("Tubes Model (ten Grotenhuis et al., 2005)")
		self.btn_mix_melt_2.toggled.connect(lambda:self.btnstate_phsmix_melt(self.btn_mix_melt_2))
		self.btn_mix_melt_3 = QRadioButton("Spheres Model (ten Grotenhuis et al., 2005)")
		self.btn_mix_melt_3.toggled.connect(lambda:self.btnstate_phsmix_melt(self.btn_mix_melt_3))
		self.btn_mix_melt_4 = QRadioButton("Modified Brick-layer Model (Schilling et al., 1997)")
		self.btn_mix_melt_4.toggled.connect(lambda:self.btnstate_phsmix_melt(self.btn_mix_melt_4))
		self.btn_mix_melt_5 = QRadioButton("Hashin-Shtrikman Upper-Bound (Glover et al., 2000)")
		self.btn_mix_melt_5.toggled.connect(lambda:self.btnstate_phsmix_melt(self.btn_mix_melt_5))
		self.btn_mix_melt_6 = QRadioButton("Hashin-Shtrikman Lower-Bound (Glover et al., 2000)")
		self.btn_mix_melt_6.toggled.connect(lambda:self.btnstate_phsmix_melt(self.btn_mix_melt_6))

		bg2 = QButtonGroup(self)

		bg2.addButton(self.btn_mix_melt_1)
		bg2.addButton(self.btn_mix_melt_2)
		bg2.addButton(self.btn_mix_melt_3)
		bg2.addButton(self.btn_mix_melt_4)
		bg2.addButton(self.btn_mix_melt_5)
		bg2.addButton(self.btn_mix_melt_6)

		phs_mix_layout.addWidget(self.btn_mix_melt_1)
		phs_mix_layout.addWidget(self.btn_mix_melt_2)
		phs_mix_layout.addWidget(self.btn_mix_melt_3)
		phs_mix_layout.addWidget(self.btn_mix_melt_4)
		phs_mix_layout.addWidget(self.btn_mix_melt_5)
		phs_mix_layout.addWidget(self.btn_mix_melt_6)

		if MATE.phs_melt_mix_method == 0:
			self.btn_mix_melt_1.setChecked(True)
		elif MATE.phs_melt_mix_method == 1:
			self.btn_mix_melt_2.setChecked(True)
		elif MATE.phs_melt_mix_method == 2:
			self.btn_mix_melt_3.setChecked(True)
		elif MATE.phs_melt_mix_method == 3:
			self.btn_mix_melt_4.setChecked(True)
		elif MATE.phs_melt_mix_method == 4:
			self.btn_mix_melt_5.setChecked(True)
		elif MATE.phs_melt_mix_method == 5:
			self.btn_mix_melt_6.setChecked(True)


		phs_mix_layout.addWidget(self.prop_info_btn)

	def btnstate_phsmix(self,b):

		if b.text() == "Generalized Archie's Law (Glover, 2010)":
			if b.isChecked() == True:
				MATE.phs_mix_method = 0
		if b.text() == "Hashin-Shtrikman Lower Bound (Berryman, 1995)":
			if b.isChecked() == True:
				MATE.phs_mix_method = 1
		if b.text() == "Hashin-Shtrikman Upper Bound (Berryman, 1995)":
			if b.isChecked() == True:
				MATE.phs_mix_method = 2
		if b.text() == "Parallel Model (Guegen and Palciauskas, 1994)":
			if b.isChecked() == True:
				MATE.phs_mix_method = 3
		if b.text() == "Perpendicular Model (Guegen and Palciauskas, 1994)":
			if b.isChecked() == True:
				MATE.phs_mix_method = 4
		if b.text() == "Random Model (Guegen and Palciauskas, 1994)":
			if b.isChecked() == True:
				MATE.phs_mix_method = 5

	def btnstate_phsmix_melt(self, b2):

		if b2.text() == "Modified Archie's Law (Glover et al., 2000)":
			if b2.isChecked() == True:
				MATE.phs_melt_mix_method = 0
				MATE.phs_melt_mix_type = 0
		elif b2.text() == "Tubes Model (ten Grotenhuis et al., 2005)":
			if b2.isChecked() == True:
				MATE.phs_melt_mix_method = 1
				MATE.phs_melt_mix_type = 1
		elif b2.text() == "Spheres Model (ten Grotenhuis et al., 2005)":
			if b2.isChecked() == True:
				MATE.phs_melt_mix_method = 2
				MATE.phs_melt_mix_type = 1
		elif b2.text() == "Modified Brick-layer Model (Glover et al., 2000)":
			if b2.isChecked() == True:
				MATE.phs_melt_mix_method = 3
				MATE.phs_melt_mix_type = 1
		elif b2.text() == "Hashin-Shtrikman Upper-Bound (Glover et al., 2000)":
			if b2.isChecked() == True:
				MATE.phs_melt_mix_method = 4
				MATE.phs_melt_mix_type = 1
		elif b2.text() == "Hashin-Shtrikman Lower-Bound (Glover et al., 2000)":
			if b2.isChecked() == True:
				MATE.phs_melt_mix_method = 5
				MATE.phs_melt_mix_type = 1



	def mixing_info(self):

		mix_str = "Phase mixing models define the geometry and interconnectedness "\
		"of the different mineral phases. They are used for calculating the bulk "\
		"conductivity, given the conductivities of the individual phases. Here, "\
		"the user can choose between six different phase mixing models. The "\
		"first model (Generalized Archie's Law) uses a cementation exponent m for each individual "\
		"mineral, where m=1 for a perfectly connected phase and m increases "\
		"with decreasing interconnection. In order to use the Archie's Law, "\
		"interconnectivity of the minerals have to be entered "\
		"in the input file. For more detailed information check out the "\
		"article, manual or see Glover (2010) - Geophysics 75"

		QMessageBox.about(self, "Info on this", mix_str)

class MT_INPUT(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		MATE.mt_input = ['ModEM','csv format']
		MATE.csv_file_type = ['Depth is top of the layer','Depth is a data point']

		mt_layout = QFormLayout(self)

		self.mt_input_btn = QPushButton('MT Model Type')
		self.mt_input_textbox = QLineEdit(MATE.mt_input[MATE.mt_input_selection])
		self.mt_input_textbox.setEnabled(False)
		self.mt_input_btn.clicked.connect(self.mt_input_func)

		self.csv_file_type_btn = QPushButton('CSV File Type')
		self.csv_file_type_btn_txt = QLineEdit(MATE.csv_file_type[MATE.csv_file_selection])
		self.csv_file_type_btn_txt.setEnabled(False)
		self.csv_file_type_btn.clicked.connect(self.csv_file_func)

		mt_layout.addRow(self.mt_input_btn,self.mt_input_textbox)
		mt_layout.addRow(self.csv_file_type_btn,self.csv_file_type_btn_txt)

		self.mt_infobtn = QPushButton('Info')
		self.mt_infobtn.clicked.connect(self.mt_info)
		mt_layout.addRow(self.mt_infobtn)

	def mt_input_func(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Model type", MATE.mt_input, 0, False)

		if ok and item:
			self.mt_input_textbox.setText(item)

		MATE.mt_input_selection = MATE.mt_input.index(item)

	def csv_file_func(self):

		if MATE.mt_input_selection == 0:
			QMessageBox.about(self, "Warning!", "In order to choose this option, -csv format- has to be selected as input method ")
		else:

			item, ok = QInputDialog.getItem(self, "select input dialog",
				"CSV plot type", MATE.csv_file_type, 0, False)

			if ok and item:
				self.csv_file_type_btn_txt.setText(item)

			MATE.csv_file_selection = MATE.csv_file_type.index(item)

	def mt_info(self):

		str_mt_upload = "The user has to select what is the upload method here."\
		"-CSV File Type- indicates how the depth of the layers is handled:"\
		" It can either indicate absolute depth value or depth according to the top of the layer."
		QMessageBox.about(self, "Info on this", str_mt_upload)

class MODEM_CURVE(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		model_curve_layout = QFormLayout(self)

		self.mt_plot_sel = QPushButton('Depth of section')
		self.mt_plot_sel_textbox = QLineEdit(str(MATE.plot_sel_modem))
		self.mt_plot_sel_textbox.setEnabled(False)
		self.mt_plot_sel.clicked.connect(self.get_plot_sel)
		model_curve_layout.addRow(self.mt_plot_sel,self.mt_plot_sel_textbox)

		self.mt_plot_action = QPushButton('Plot Model Section')
		self.mt_plot_action.clicked.connect(self.plot_modem_model)
		model_curve_layout.addRow(self.mt_plot_action)

		self.mt_data_sel_btn = QPushButton('MT Data selection')
		self.mt_data_sel_btn.clicked.connect(self.mt_data_sel)
		model_curve_layout.addRow(self.mt_data_sel_btn)

		self.mt_data_action = QPushButton('Select MT Data')
		self.mt_data_action.clicked.connect(self.mt_data_handle)
		model_curve_layout.addRow(self.mt_data_action)

		self.mt_error_handle_btn = QPushButton('Error Handling')
		self.mt_error_handle_btn.clicked.connect(self.mt_error_handle)
		model_curve_layout.addRow(self.mt_error_handle_btn)

		self.mt_write_data_btn = QPushButton('Write MT profile')
		self.mt_write_data_btn.clicked.connect(self.mt_write_data_handle)
		model_curve_layout.addRow(self.mt_write_data_btn)

		self.mt_data_submit = QPushButton('Submit Selected Data')
		self.mt_data_submit.clicked.connect(self.submit_modem_data)
		model_curve_layout.addRow(self.mt_data_submit)

		self.mt_sel_pop = None
		self.mt_handle_pop = None
		self.mt_err_handle_pop = None

	def get_plot_sel(self):

		text, ok = QInputDialog.getText(self, 'Plotting Depth', 'Enter the value in (km):')
		if ok:
			self.mt_plot_sel_textbox.setText(str(text))
			MATE.plot_sel_modem = float(text)

	def mt_data_sel(self):

		if self.mt_sel_pop is None:
			self.mt_sel_pop = MT_SEL()
			self.mt_sel_pop.setGeometry(QtCore.QRect(100, 100, 100, 100))
		self.mt_sel_pop.show()

	def mt_data_handle(self):

		self.mt_handle_pop = MT_HAND()
		self.mt_handle_pop.setGeometry(QtCore.QRect(100, 100, 300, 100))
		self.mt_handle_pop.show()

	def plot_modem_model(self):

		plt.close('all')
		self.mt_fig = plt.figure(figsize = (10,7))
		self.ax_mt = plt.subplot(111)

		#Finding the index of the wanted depth.

		idx_depth = (np.abs(np.asarray(MATE.z_mesh_center)-MATE.plot_sel_modem)).argmin()

		res_array = np.asarray(list(itertools.chain(*MATE.rho[idx_depth])))

		p = PatchCollection(MATE.rectobj_list,linewidth = 1,norm=colors.LogNorm())
		p.set_array(res_array)
		p.set_cmap('jet_r')
		p.set_clim([1,1e4])

		self.ax_mt.add_collection(p)
		plt.colorbar(p,label = 'Log Resistivity')
		self.ax_mt.set_xlabel('Longitude')
		self.ax_mt.set_ylabel('Latitude')
		self.ax_mt.tick_params(axis='both', which='major', labelsize=8)
		self.ax_mt.grid(which = 'both')
		self.ax_mt.set_xlim((MATE.min_y_grid_cum,MATE.max_y_grid_cum))
		self.ax_mt.set_ylim((MATE.min_x_grid_cum,MATE.max_x_grid_cum))
		self.ax_mt.scatter(MATE.station_posy,MATE.station_posx,marker = 'v',color = 'k',s = 1.5)
		self.ax_mt.set_xlabel('Easting')
		self.ax_mt.set_ylabel('Northing')
		self.ax_mt.set_title('Note down a station number or an (x,y) position.')

		for i in range(0,len(MATE.station_posx)):
			self.ax_mt.text(MATE.station_posy[i],MATE.station_posx[i],str(i),color = 'k',fontsize = 9)

		plt.show()

	def define_profile(self):

		idx_x_list = []
		idx_y_list = []

		if MATE.curve_method == 0:

			idx_x = (np.abs(np.asarray(MATE.x_mesh_center) - MATE.station_posx[MATE.station_name_select])).argmin() #minus one bc resist. is defined by the previous node
			idx_y = (np.abs(np.asarray(MATE.y_mesh_center) - MATE.station_posy[MATE.station_name_select])).argmin()
			idx_x_list.append(idx_x)
			idx_y_list.append(idx_y)

		elif MATE.curve_method == 1:

			idx_x = (np.abs(np.asarray(MATE.x_mesh_center) - MATE.posx_sel)).argmin() #minus one bc resist. is defined by the previous node
			idx_y = (np.abs(np.asarray(MATE.y_mesh_center) - MATE.posy_sel)).argmin()
			idx_x_list.append(idx_x)
			idx_y_list.append(idx_y)

		elif MATE.curve_method == 2:

			rrr = []
			b = MATE.text_curve.splitlines()
			for i in range(0,len(b)):
				rrr.append(b[i].split(','))
			text_curve_list = list(itertools.chain(*rrr))

			station_no_list = []

			for i in range(0,len(text_curve_list)):
				if text_curve_list[i].find(':') > 0:
					indexpos = int(text_curve_list[i].index(':'))
					for idxx in range(int(text_curve_list[i][0:indexpos]),int(text_curve_list[i][indexpos+1:len(text_curve_list[i])])):
						station_no_list.append(idxx)
				else:
					station_no_list.append(int(text_curve_list[i]))

			for i in range(0,len(station_no_list)):
				idx_x = (np.abs(np.asarray(MATE.x_mesh_center) - MATE.station_posx[station_no_list[i]])).argmin() #minus one bc resist. is defined by the previous node
				idx_y = (np.abs(np.asarray(MATE.y_mesh_center) - MATE.station_posy[station_no_list[i]])).argmin()
				idx_x_list.append(idx_x)
				idx_y_list.append(idx_y)

		MATE.z_depth_plot_list = []
		MATE.res_profile_plot_list = []

		for stat in range(0,len(idx_x_list)):

			MATE.res_profile = []

			for i in range(0,len(MATE.rho)):
				if MATE.curve_method == 2:
					MATE.res_profile.append(MATE.rho[i][idx_y_list[stat]][idx_x_list[stat]])
				else:
					MATE.res_profile.append(MATE.rho[i][idx_y][idx_x])

			MATE.res_profile_plot = []

			for i in range(0,len(MATE.res_profile)):
				for j in range(0,2):
					MATE.res_profile_plot.append(MATE.res_profile[i])

			MATE.res_profile_plot = np.asarray(MATE.res_profile_plot)

			MATE.z_depth_plot = []

			for i in range(0,len(MATE.z_depth)):
				if (i == 0) or (i == len(MATE.z_depth)-1):
					MATE.z_depth_plot.append(MATE.z_depth[i])
				else:
					for j in range(0,2):
						MATE.z_depth_plot.append(MATE.z_depth[i])

			MATE.z_depth_plot = np.asarray(MATE.z_depth_plot) / 1000.0

			MATE.z_depth_plot_list.append(MATE.z_depth_plot)
			MATE.res_profile_plot_list.append(MATE.res_profile_plot)

	def mt_error_handle(self):

		if self.mt_err_handle_pop is None:
			self.mt_err_handle_pop = MT_ERR()
			self.mt_err_handle_pop.setGeometry(QtCore.QRect(100, 100, 100, 100))
		self.mt_err_handle_pop.show()

	def mt_write_data_handle(self):

		if len(MATE.z_depth_plot_list) == 0:
			QMessageBox.about(self, "Warning!", "A profile has to be submitted first to be written.")
		else:
			if len(MATE.z_depth_plot_list) == 1:
				self.write_file_mt_save_name = QFileDialog.getSaveFileName(self, 'Save File')
				if self.write_file_mt_save_name[0] != '':
					self.write_file_mt_save_name = str(self.write_file_mt_save_name[0])
					self.dir_path_mt_write = self.write_file_mt_save_name[:self.write_file_mt_save_name.rfind('/')+1]
					self.write_mt_file_name = self.write_file_mt_save_name[self.write_file_mt_save_name.rfind('/')+1:]
					lines_mt_write = ['DepthTop,DepthBottom,ResMIN,ResMAX,Res\n']
					for i in range(1,len(MATE.z_depth)):
						line = ','.join((str('%4.2f' % float(MATE.z_depth[i]/1e3)),str('%4.2f' % MATE.res_profile[i-1]),str('%4.2f' % MATE.res_profile[i-1]),str('%4.2f' % MATE.res_profile[i-1]),'\n'))
						lines_mt_write.append(line)

					filesave_mt_profile = open(os.path.join(self.dir_path_mt_write, (self.write_mt_file_name+'_profile.csv')) ,'w')
					filesave_mt_profile.writelines(lines_mt_write)
					filesave_mt_profile.close()

					QMessageBox.about(self, "Info", "Files are saved in the dir:  " + str(self.dir_path_mt_write))

			else:
				QMessageBox.about(self, "Warning!", "Only singular profiles can be written")

	def handle_error(self):

		if (MATE.curve_method == 0) or (MATE.curve_method == 1):
			MATE.mt_model_max = 10.0**(np.log10(MATE.res_profile_plot_list[0]) + (MATE.mt_err_val * np.log(10.0) * np.log10(MATE.res_profile_plot_list[0])))
			MATE.mt_model_min = 10.0**(np.log10(MATE.res_profile_plot_list[0]) - (MATE.mt_err_val * np.log(10.0) * np.log10(MATE.res_profile_plot_list[0])))
			MATE.mt_model_errs = True

	def submit_modem_data(self):

		self.define_profile()
		if MATE.modem_mt_err_method == 0:
			self.handle_error()
		MATE.ModEM_data_submit = True

class MT_SEL(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		mt_sel_layout = QVBoxLayout(self)

		self.btn_curve_1 = QRadioButton("Station-based")
		self.btn_curve_1.toggled.connect(lambda:self.btnstate_curve(self.btn_curve_1))
		self.btn_curve_2 = QRadioButton("Coordinate-based")
		self.btn_curve_2.toggled.connect(lambda:self.btnstate_curve(self.btn_curve_2))
		self.btn_curve_3 = QRadioButton("Array of stations")
		self.btn_curve_3.toggled.connect(lambda:self.btnstate_curve(self.btn_curve_3))

		if MATE.curve_method == 0:
			self.btn_curve_1.setChecked(True)
		elif MATE.curve_method == 1:
			self.btn_curve_2.setChecked(True)
		elif MATE.curve_method == 2:
			self.btn_curve_3.setChecked(True)

		mt_sel_layout.addWidget(self.btn_curve_1)
		mt_sel_layout.addWidget(self.btn_curve_2)
		mt_sel_layout.addWidget(self.btn_curve_3)

	def btnstate_curve(self,b):

		if b.text() == "Station-based":
			if b.isChecked() == True:
				MATE.curve_method = 0
		elif b.text() == "Coordinate-based":
			if b.isChecked() == True:
				MATE.curve_method = 1
		elif b.text() == "Array of stations":
			if b.isChecked() == True:
				MATE.curve_method = 2

class MT_HAND(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		mt_hand_layout = QFormLayout(self)

		if MATE.curve_method == 0:

			self.station_select_button = QPushButton('Select Station')
			self.station_select_button_text = QLineEdit(MATE.station_name[MATE.station_name_select])
			self.station_select_button_text.setEnabled(False)
			self.station_select_button.clicked.connect(self.mt_station_select)
			mt_hand_layout.addRow(self.station_select_button,self.station_select_button_text)

		elif MATE.curve_method == 1:

			self.lat_select_button = QPushButton('Enter Y')
			self.lon_select_button = QPushButton('Enter X')
			self.lat_select_button_text = QLineEdit(str(0.0))
			self.lat_select_button_text.setEnabled(False)
			self.lon_select_button_text = QLineEdit(str(0.0))
			self.station_select_button_text.setEnabled(False)
			self.lat_select_button.clicked.connect(self.mt_posx_select)
			self.lon_select_button.clicked.connect(self.mt_posy_select)
			mt_hand_layout.addRow(self.lat_select_button,self.lat_select_button_text)
			mt_hand_layout.addRow(self.lon_select_button,self.lon_select_button_text)

		elif MATE.curve_method == 2:

			self.textEdit_curve = QTextEdit()
			self.textEdit_curve.setText('')
			mt_hand_layout.addWidget(self.textEdit_curve)

			self.lodge_button_curve = QPushButton('Submit Data')
			self.lodge_button_curve.clicked.connect(self.lodge_curve)
			mt_hand_layout.addWidget(self.lodge_button_curve)

	def mt_station_select(self):

		item, ok = QInputDialog.getItem(self, "Select Station",
			"Select station", MATE.st_item_list, 0, False)

		if ok and item:
			self.station_select_button_text.setText(item)

		MATE.station_name_select = MATE.st_item_list.index(item)

	def mt_posx_select(self):

		text, ok = QInputDialog.getText(self, 'N-S position of the point', 'Enter the value in m (read it from the plot):')
		if ok:

			self.lat_select_button_text.setText(str(text))
			MATE.posx_sel = float(text) * 1000.0

	def mt_posy_select(self):

		text, ok = QInputDialog.getText(self, 'E-W position of the point', 'Enter the value in m (read it from the plot):')
		if ok:

			self.lon_select_button_text.setText(str(text))
			MATE.posy_sel = float(text) * 1000.0

	def lodge_curve(self):

		text_take = self.textEdit_curve.toPlainText()
		MATE.text_curve = text_take
		MATE.lodge_curve_check = True

class MT_ERR(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		MATE.mterr_method_list = ["Single error value", "Csv error entry"]

		mt_err_layout = QFormLayout(self)

		self.mt_err_label = QLabel(self)
		self.mt_err_label.setText('Errors included?')
		mt_err_layout.addRow(self.mt_err_label)

		self.btn_mterr_1 = QRadioButton("True")
		self.btn_mterr_1.toggled.connect(lambda:self.btnstate_mterr(self.btn_mterr_1))
		self.btn_mterr_2 = QRadioButton("False")
		self.btn_mterr_2.toggled.connect(lambda:self.btnstate_mterr(self.btn_mterr_2))
		mt_err_layout.addRow(self.btn_mterr_1,self.btn_mterr_2)

		if MATE.modem_mt_err_method == 0:
			self.btn_mterr_1.setChecked(True)
		elif MATE.modem_mt_err_method == 1:
			self.btn_mterr_2.setChecked(True)

		self.mterr_submit_button = QPushButton('Submit Method')
		self.mterr_submit_button_txt = QLineEdit(MATE.mt_err_val_str)
		self.mterr_submit_button_txt.setEnabled(False)

		self.mterr_submit_button.clicked.connect(self.mterr_submit_value)
		mt_err_layout.addRow(self.mterr_submit_button,self.mterr_submit_button_txt)

	def btnstate_mterr(self,b):

		if b.text() == "True":
			if b.isChecked() == True:
				MATE.modem_mt_err_method = 0
		elif b.text() == "False":
			if b.isChecked() == True:
				MATE.modem_mt_err_method = 1

	def get_mterr_method(self):

		if MATE.modem_mt_err_method == 1:
			QMessageBox.about(self, "Warning!", "Error handling requires method to be selected as True.")
		else:
			item, ok = QInputDialog.getItem(self, "Select MT error handling method",
				"Select MT error handling method", MATE.mterr_method_list, 0, False)

			if ok and item:
				self.mterr_method_select_button_text.setText(item)

			MATE.mt_err_method = MATE.mterr_method_list.index(item)

	def mterr_submit_value(self):

		if MATE.modem_mt_err_method == 1:
			QMessageBox.about(self, "Warning!", "Error handling requires method to be selected as True.")

		else:

			text, ok = QInputDialog.getText(self, 'Value-based error', 'Enter the value in (log-units resistivity):')
			if ok:
				try:
					float(text)
					self.mterr_submit_button_txt.setText(str(text))
					MATE.mt_err_val = float(text)
					MATE.mt_err_val = np.ones(2 * MATE.z_number) * MATE.mt_err_val
				except ValueError:
					QMessageBox.about(self, "Warning!", "Enter a number that can be converted to floating point.")

class SOL_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		sol_pop_layout = QFormLayout(self)

		self.sol_label = QLabel(self)
		self.sol_label.setText('Plot Solubilities?')
		self.sol_radio_1 = QRadioButton("Yes")
		self.sol_radio_1.toggled.connect(lambda:self.btnstate_sol(self.sol_radio_1))
		self.sol_radio_2 = QRadioButton("No")
		self.sol_radio_2.toggled.connect(lambda:self.btnstate_sol(self.sol_radio_2))

		if MATE.sol_plot == True:
			self.sol_radio_1.setChecked(True)
		elif MATE.sol_plot == False:
			self.sol_radio_2.setChecked(True)

		sol_pop_layout.addRow(self.sol_label)
		sol_pop_layout.addRow(self.sol_radio_1,self.sol_radio_2)


		self.sol_model_select_button = QPushButton('Select Model')
		self.sol_model_select_button_text = QLineEdit(MATE.name_ol_sol[MATE.sol_method])
		self.sol_model_select_button_text.setEnabled(False)
		self.sol_model_select_button.clicked.connect(self.get_sol_model)
		sol_pop_layout.addRow(self.sol_model_select_button,self.sol_model_select_button_text)

		self.sol_model_use_button = QPushButton('Use as the Water Distr.')
		self.sol_model_use_button_txt = QLineEdit(MATE.sol_model_pref[MATE.sol_model_pref_select])
		self.sol_model_use_button_txt.setEnabled(False)
		self.sol_model_use_button.clicked.connect(self.get_sol_model_use)
		sol_pop_layout.addRow(self.sol_model_use_button,self.sol_model_use_button_txt)

		self.sol_infobtn = QPushButton('Info')
		self.sol_infobtn.clicked.connect(self.sol_info)
		sol_pop_layout.addRow(self.sol_infobtn)

	def btnstate_sol(self,b):

		if b.text() == "Yes":
			if b.isChecked() == True:
				MATE.sol_plot = True
		elif b.text() == "No":
			if b.isChecked() == True:
				MATE.sol_plot = False

	def get_sol_model(self):

		item, ok = QInputDialog.getItem(self, "Select Olivine Solubility Model",
			"Select Olivine Solubility Model", MATE.name_ol_sol, 0, False)

		if ok and item:
			self.sol_model_select_button_text.setText(item)

		MATE.sol_method = MATE.name_ol_sol.index(item)

	def get_sol_model_use(self):

		if MATE.sol_plot == False:

			QMessageBox.about(self, "Warning!", "You first have to activate the solubility models to be calculated.")

		else:

			item, ok = QInputDialog.getItem(self, "Solubility as Representative",
				"Do you want to use the solubility models to represent the water distribution?", MATE.sol_model_pref, 0, False)

			if ok and item:
				self.sol_model_use_button_txt.setText(item)

			MATE.sol_model_pref_select = MATE.sol_model_pref.index(item)

	def sol_info(self):

		str_cap = "Nominally anhydrous minerals have pressure- and temperature-sensitive water solubility limits."\
		" Different experiments have placed different constraints on olivine water storage capacities. Here, the user"\
		" can choose whether to plot those storage capacities and choose which experimental model is going to be used\n\n."\
		" The storage capacities of the other minerals will be calculated via water-partitioning coefficients.\n\n"\
		" Some calculations require the equation of state for pure water to be calculated and may therefore take a few moments\n\n."\
		" The user can also select the olivine solubility model to use it as water distribution in the mantle, by changing the option in"\
		" -Use As Water Distr.-."
		QMessageBox.about(self, "Info on this", str_cap)


class AMP_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		amp_pop_layout = QFormLayout(self)

		self.amp_stab_btn = QPushButton('Amphibole Stability')
		self.amp_stab_btn.clicked.connect(self.get_amp_stab)
		self.amp_stab_btn_textbox = QLineEdit(MATE.amph_stab_list[MATE.amph_stab_select])
		self.amp_stab_btn_textbox.setEnabled(False)
		amp_pop_layout.addRow(self.amp_stab_btn,self.amp_stab_btn_textbox)

	def get_amp_stab(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Amphibole Stability Model", MATE.amph_stab_list, 0, False)

		if ok and item:
			self.amp_stab_btn_textbox.setText(item)

		MATE.amph_stab_select = MATE.amph_stab_list.index(item)

class SP_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		sp_pop_layout = QFormLayout(self)

		self.sp_radio_1 = QRadioButton('No-Cr Transition - Klemme and ONeill (2001)')
		self.sp_radio_1.toggled.connect(lambda:self.btnstate_sp(self.sp_radio_1))
		self.sp_radio_2 = QRadioButton('Cr-Saturated Manual Entry')
		self.sp_radio_2.toggled.connect(lambda:self.btnstate_sp(self.sp_radio_2))

		if MATE.spinel_stab_select == 1:
			self.sp_radio_1.setChecked(True)
		elif MATE.spinel_stab_select == 2:
			self.sp_radio_2.setChecked(True)

		sp_pop_layout.addRow(self.sp_radio_1)
		sp_pop_layout.addRow(self.sp_radio_2)

		self.sp_stab_btn = QPushButton('Manual Entry')
		self.sp_stab_btn.clicked.connect(self.get_sp_stab)
		self.sp_stab_btn_textbox = QLineEdit(str(MATE.P_sp_manual))
		self.sp_stab_btn_textbox.setEnabled(False)
		sp_pop_layout.addRow(self.sp_stab_btn,self.sp_stab_btn_textbox)

		self.sp_infobtn = QPushButton('Info')
		self.sp_infobtn.clicked.connect(self.sp_info)
		sp_pop_layout.addRow(self.sp_infobtn)

	def btnstate_sp(self,b):

		if b.text() == "No-Cr Transition - Klemme and ONeill (2001)":
			if b.isChecked() == True:
				MATE.spinel_stab_select = 1
		elif b.text() == "Cr-Saturated Manual Entry":
			if b.isChecked() == True:
				MATE.spinel_stab_select = 2

	def get_sp_stab(self):

		if MATE.spinel_stab_select == 1:
			QMessageBox.about(self, "Warning!", "Manual entry requires -Cr-Saturated Manual Entry- option to be selected.")
		else:

			text, ok = QInputDialog.getText(self, 'Sp-Gt transition in GPa', 'Enter the value in GPa')
			if ok:
				if text is None:
					QMessageBox.about(self, "Warning!", "Enter a value.")
				else:
					try:
						float(text)
						MATE.P_sp_manual = float(text)
						self.sp_stab_btn_textbox.setText(str(text))
					except ValueError:
						QMessageBox.about(self, "Warning!", "Enter a number that can be converted to floating point.")

	def sp_info(self):

		str_spinel = "Spinel stability is heavily modified by Cr in spinel. Cr-poor conditions have good"\
		" constraints from the study Klemme and ONeill (2004). However, one has to enter the Cr-rich conditions"\
		"qualitatively by looking in the area where xenoliths studies were made and enter a value in GPa."
		QMessageBox.about(self, "Info on this", str_spinel)

class GSIZE_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		gsize_pop_layout = QFormLayout(self)

		self.part_gb_btn = QPushButton('Grain Boundary Partition')
		self.part_gb_btn_text = QLineEdit(str(MATE.D_gb))
		self.part_gb_btn_text.setEnabled(False)
		self.part_gb_btn.clicked.connect(self.get_d_part)

		self.ol_gb_btn = QPushButton('Ol GB Model')
		self.ol_gb_btn_text = QLineEdit(str(MATE.GB_ol_list[MATE.GB_ol_select]))
		self.ol_gb_btn_text.setEnabled(False)
		self.ol_gb_btn.clicked.connect(self.get_ol_gb)

		gsize_pop_layout.addRow(self.part_gb_btn,self.part_gb_btn_text)
		gsize_pop_layout.addRow(self.ol_gb_btn,self.ol_gb_btn_text)

	def get_d_part(self):

		text, ok = QInputDialog.getText(self, 'Grain Boundary Partition', 'Enter the of grain boundary partitioning rate')
		if ok:
			try:
				float(text)
				self.part_gb_btn_text.setText(str(text))
				MATE.D_gb = float(text)
			except ValueError:
				QMessageBox.about(self,"Warning!","Please enter a value that can be converted to floating number.")

	def get_ol_gb(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
		"Olivine Grain Boundary Diffusion Model", MATE.GB_ol_list, 0, False)

		if ok and item:
			self.ol_gb_btn_text.setText(item)

		MATE.GB_ol_select = MATE.GB_ol_list.index(item)


class ADD_WATER_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		addwater_layout = QFormLayout(self)

		self.add_water_label = QLabel(self)
		self.add_water_label.setText('Enter vertical variation in?')

		addwater_layout.addRow(self.add_water_label)

		self.b1_water = QRadioButton("P (GPa)")
		self.b1_water.toggled.connect(lambda:self.btnstate_water(self.b1_water))
		self.b2_water = QRadioButton("Depth (km)")
		self.b2_water.toggled.connect(lambda:self.btnstate_water(self.b2_water))
		addwater_layout.addRow(self.b1_water,self.b2_water)

		if MATE.add_water_method == 0:
			self.b1_water.setChecked(True)
		elif MATE.add_water_method == 1:
			self.b2_water.setChecked(True)

		self.water_openfile = QPushButton('Open Water File')
		self.water_openfile.clicked.connect(self.open_waterfile)
		addwater_layout.addRow(self.water_openfile)

	def btnstate_water(self,b):

			if b.text() == "P (GPa)":
				if b.isChecked() == True:
					MATE.add_water_method = 0
			elif b.text() == "Depth (km)":
				if b.isChecked() == True:
					MATE.add_water_method = 1

	def open_waterfile(self):

		self.water_file_name = QFileDialog.getOpenFileName(self, 'Open File')

		if self.water_file_name[0] != '':

			text_file = open(str(self.water_file_name[0]),'rt',encoding = "utf8")
			text_csv = csv.reader(text_file,delimiter = ',')
			data_text = []
			for row in text_csv:
				data_text.append(row)
			data_text = list(filter(None,data_text))
			MATE.P_depth_water = []
			MATE.H_water = []
			MATE.H_water_err = []
			MATE.water_mineral = []
			try:
				for i in range(1,len(data_text)):
					try:
						MATE.P_depth_water.append(float(data_text[i][0]))
						MATE.H_water.append(float(data_text[i][1]))
						if len(data_text[1]) != 2:
							MATE.H_water_err.append(float(data_text[i][2]))
						else:
							MATE.H_water_err.append(0.0)
						if len(data_text[1]) !=3:
							MATE.water_mineral.append(data_text[i][3])
						else:
							MATE.water_mineral.append('NotGiven')
					except ValueError:
						QMessageBox.about(self,'Warning!','There is an element in the file that can not be transformed into floating number...')
						return
			except IndexError:
				QMessageBox.about(self,'Warning!','Structure of the csv file seems to be wrong.')
				return

			MATE.water_file_read = True
			QMessageBox.about(self,'Success',str(self.water_file_name[0]) + ' file was succesfully imported to the program!')

		else:
			pass

class SELECT_SOLIDUS_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		solidus_layout = QFormLayout(self)

		self.solidus_dry_selection_btn = QPushButton('Dry Solidus Model')
		self.solidus_dry_selection_text_box = QLineEdit(str(MATE.solidus_dry_model_names[MATE.solidus_dry_model_selection]))
		self.solidus_dry_selection_text_box.setEnabled(False)
		self.solidus_dry_selection_btn.clicked.connect(self.dry_solidus_model_get)

		self.solidus_wet_selection_btn = QPushButton('Wet Solidus Model')
		self.solidus_wet_selection_text_box = QLineEdit(str(MATE.solidus_wet_model_names[MATE.solidus_wet_model_selection]))
		self.solidus_wet_selection_text_box.setEnabled(False)
		self.solidus_wet_selection_btn.clicked.connect(self.wet_solidus_model_get)

		self.solidus_carbon_selection_btn = QPushButton('Carbon Solidus Model')
		self.solidus_carbon_selection_text_box = QLineEdit(str(MATE.solidus_carbon_model_names[MATE.solidus_carbon_model_selection]))
		self.solidus_carbon_selection_text_box.setEnabled(False)
		self.solidus_carbon_selection_btn.clicked.connect(self.carbon_solidus_model_get)

		solidus_layout.addRow(self.solidus_dry_selection_btn,self.solidus_dry_selection_text_box)
		solidus_layout.addRow(self.solidus_wet_selection_btn,self.solidus_wet_selection_text_box)
		solidus_layout.addRow(self.solidus_carbon_selection_btn,self.solidus_carbon_selection_text_box)

	def dry_solidus_model_get(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Dry Solidus Model", MATE.solidus_dry_model_names, 0, False)

		if ok and item:
			self.solidus_dry_selection_text_box.setText(item)

		MATE.solidus_dry_model_selection = MATE.solidus_dry_model_names.index(item)

	def wet_solidus_model_get(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Wet Solidus Model", MATE.solidus_wet_model_names, 0, False)

		if ok and item:
			self.solidus_wet_selection_text_box.setText(item)

		MATE.solidus_wet_model_selection = MATE.solidus_wet_model_names.index(item)

	def carbon_solidus_model_get(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Carbon Solidus Model", MATE.solidus_carbon_model_names, 0, False)

		if ok and item:
			self.solidus_carbon_selection_text_box.setText(item)

		MATE.solidus_carbon_model_selection = MATE.solidus_carbon_model_names.index(item)
		
class SELECT_SOLIDUS_PLOT_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		solidus_plot_layout = QFormLayout(self)
					
		bg1 = QButtonGroup(self)
		
		self.wg_1988_label = QLabel(self)
		self.wg_1988_label.setText('Plot Wallace & Green (1988) Peridotite Oxidised Solidus?')
		self.wg_1988_btn_True = QRadioButton("True")
		self.wg_1988_btn_True.toggled.connect(lambda:self.btnstate_wg1988_inp(self.wg_1988_btn_True))
		self.wg_1988_btn_False = QRadioButton("False")
		self.wg_1988_btn_False.toggled.connect(lambda:self.btnstate_wg1988_inp(self.wg_1988_btn_False))
		
		if MATE.solidus_wg_plot == True:
			self.wg_1988_btn_True.setChecked(True)
		elif MATE.solidus_wg_plot == False:
			self.wg_1988_btn_False.setChecked(True)
			
		bg2 = QButtonGroup(self)
		
		self.foley_2022_label = QLabel(self)
		self.foley_2022_label.setText('Plot Foley et al. (2022) Hydrous Pyroxenite Solidus?')
		self.foley_2022_btn_True = QRadioButton("True")
		self.foley_2022_btn_True.toggled.connect(lambda:self.btnstate_foley2022_inp(self.foley_2022_btn_True))
		self.foley_2022_btn_False = QRadioButton("False")
		self.foley_2022_btn_False.toggled.connect(lambda:self.btnstate_foley2022_inp(self.foley_2022_btn_False))
		
		if MATE.solidus_foley_plot == True:
			self.foley_2022_btn_True.setChecked(True)
		elif MATE.solidus_foley_plot == False:
			self.foley_2022_btn_False.setChecked(True)
			
			
		bg3 = QButtonGroup(self)
		
		self.green_2010_label = QLabel(self)
		self.green_2010_label.setText('Plot Green et al. (2010) Hydrous Peridotite Solidus (180 ppm wt H2O)?')
		self.green_2010_btn_True = QRadioButton("True")
		self.green_2010_btn_True.toggled.connect(lambda:self.btnstate_green2010_inp(self.green_2010_btn_True))
		self.green_2010_btn_False = QRadioButton("False")
		self.green_2010_btn_False.toggled.connect(lambda:self.btnstate_green2010_inp(self.green_2010_btn_False))
		
		if MATE.solidus_green2010_plot == True:
			self.green_2010_btn_True.setChecked(True)
		elif MATE.solidus_green2010_plot == False:
			self.green_2010_btn_False.setChecked(True)
					
		bg1.addButton(self.wg_1988_btn_True)
		bg1.addButton(self.wg_1988_btn_False)
		
		bg2.addButton(self.foley_2022_btn_True)
		bg2.addButton(self.foley_2022_btn_False)
		
		bg3.addButton(self.green_2010_btn_True)
		bg3.addButton(self.green_2010_btn_False)
		
		solidus_plot_layout.addRow(self.wg_1988_label)
		solidus_plot_layout.addRow(self.wg_1988_btn_True, self.wg_1988_btn_False)
		solidus_plot_layout.addRow(self.foley_2022_label)
		solidus_plot_layout.addRow(self.foley_2022_btn_True, self.foley_2022_btn_False)
		solidus_plot_layout.addRow(self.green_2010_label)
		solidus_plot_layout.addRow(self.green_2010_btn_True, self.green_2010_btn_False)

	def btnstate_wg1988_inp(self,b):

		if b.text() == "True":
			if b.isChecked() == True:
				MATE.solidus_wg_plot = True
		elif b.text() == "False":
			if b.isChecked() == True:
				MATE.solidus_wg_plot = False
				
	def btnstate_foley2022_inp(self,b):

		if b.text() == "True":
			if b.isChecked() == True:
				MATE.solidus_foley_plot = True
		elif b.text() == "False":
			if b.isChecked() == True:
				MATE.solidus_foley_plot = False
				
	def btnstate_green2010_inp(self,b):

		if b.text() == "True":
			if b.isChecked() == True:
				MATE.solidus_green2010_plot = True
		elif b.text() == "False":
			if b.isChecked() == True:
				MATE.solidus_green2010_plot = False

class SELECT_MELT_FRAC_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		figureprop_layout = QFormLayout(self)

		self.melt_frac_eq_btn = QPushButton('Melt Fraction Estimate Function')
		self.melt_frac_eq_btn_txt = QLineEdit(str(MATE.melt_fraction_function_names[MATE.melt_fraction_function_selection]))
		self.melt_frac_eq_btn_txt.setEnabled(False)
		self.melt_frac_eq_btn.clicked.connect(self.get_melt_frac_eq)

		figureprop_layout.addRow(self.melt_frac_eq_btn,self.melt_frac_eq_btn_txt)

	def get_melt_frac_eq(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
			"Melt Fraction Function", MATE.melt_fraction_function_names, 0, False)

		if ok and item:
			self.melt_frac_eq_btn_txt.setText(item)

		MATE.melt_fraction_function_selection = MATE.melt_fraction_function_names.index(item)

class FIGPROP_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		figureprop_layout = QFormLayout(self)

		self.plot_style_btn = QPushButton('Plot Style')
		self.plot_style_btn_txt = QLineEdit(str(MATE.plot_style_list[MATE.plot_style_selection]))
		self.plot_style_btn_txt.setEnabled(False)
		self.plot_style_btn.clicked.connect(self.get_plot_style)

		self.trange_btn = QPushButton('T-Ranges')
		self.trange_btn_txt = QLineEdit(str(MATE.trange_list[MATE.trange_method]))
		self.trange_btn_txt.setEnabled(False)
		self.trange_btn.clicked.connect(self.get_trange)

		self.sol_plot_type_btn = QPushButton('Solubility Plot Style')
		self.sol_plot_type_btn_txt = QLineEdit(str(MATE.sol_plot_type_list[MATE.sol_plot_method]))
		self.sol_plot_type_btn_txt.setEnabled(False)
		self.sol_plot_type_btn.clicked.connect(self.get_sol_plot_type)

		self.sol_plot_scale_type_btn = QPushButton('Solubility Plot Scale')
		self.sol_plot_scale_type_btn_txt = QLineEdit(str(MATE.sol_plot_scale_list[MATE.sol_plot_scale_method]))
		self.sol_plot_scale_type_btn_txt.setEnabled(False)
		self.sol_plot_scale_type_btn.clicked.connect(self.get_sol_plot_scale_type)

		self.bulk_water_plot_btn = QPushButton('Plot Bulk Water Content')
		self.bulk_water_plot_btn_txt = QLineEdit(str(MATE.bulk_water_method_list[MATE.bulk_water_method]))
		self.bulk_water_plot_btn_txt.setEnabled(False)
		self.bulk_water_plot_btn.clicked.connect(self.get_bulk_water_method)

		self.water_x_lim_btn = QPushButton('Water Content Upper Limit')
		self.water_x_lim_btn_txt = QLineEdit(str(MATE.waterplotlim_up))
		self.water_x_lim_btn_txt.setEnabled(False)
		self.water_x_lim_btn.clicked.connect(self.get_waterplotlim_up)

		self.geotherm_x_lim_btn = QPushButton('Geotherm Plot Upper Limit')
		self.geotherm_x_lim_btn_txt = QLineEdit(str(MATE.geotherm_up))
		self.geotherm_x_lim_btn_txt.setEnabled(False)
		self.geotherm_x_lim_btn.clicked.connect(self.get_geotherm_up)

		self.condrange_btn = QPushButton('Conductivity Range')
		self.condrange_btn_txt = QLineEdit(str(MATE.condrange_list[MATE.condrange_method]))
		self.condrange_btn_txt.setEnabled(False)
		self.condrange_btn.clicked.connect(self.get_condrange)

		self.condlinestyle_btn = QPushButton('Conductivity Linestyle')
		self.condlinestyle_btn_txt = QLineEdit(str(MATE.condlinestyle_list[MATE.condlinestyle_select]))
		self.condlinestyle_btn_txt.setEnabled(False)
		self.condlinestyle_btn.clicked.connect(self.get_condlinestyle)

		self.condlinewidth_btn = QPushButton('Conductivity Linewidth')
		self.condlinewidth_btn_txt = QLineEdit(str(MATE.condlinewidth))
		self.condlinewidth_btn_txt.setEnabled(False)
		self.condlinewidth_btn.clicked.connect(self.get_condlinewidth)

		self.condplotlim_up_btn = QPushButton('Conductivity Upper Plot Limiit')
		self.condplotlim_up_btn_txt = QLineEdit(str(MATE.condplotlim_up))
		self.condplotlim_up_btn_txt.setEnabled(False)
		self.condplotlim_up_btn.clicked.connect(self.get_condplotlim_up)

		self.condplotlim_down_btn = QPushButton('Conductivity Lower Plot Limiit')
		self.condplotlim_down_btn_txt = QLineEdit(str(MATE.condplotlim_down))
		self.condplotlim_down_btn_txt.setEnabled(False)
		self.condplotlim_down_btn.clicked.connect(self.get_condplotlim_down)

		self.boundsbackgr_btn = QPushButton('Plot Bounds Background')
		self.boundsbackgr_btn_txt = QLineEdit(MATE.boundslist[MATE.bounds_select])
		self.boundsbackgr_btn_txt.setEnabled(False)
		self.boundsbackgr_btn.clicked.connect(self.get_boundsbackgr)

		figureprop_layout.addRow(self.plot_style_btn,self.plot_style_btn_txt)
		figureprop_layout.addRow(self.trange_btn,self.trange_btn_txt)
		figureprop_layout.addRow(self.sol_plot_type_btn,self.sol_plot_type_btn_txt)
		figureprop_layout.addRow(self.sol_plot_scale_type_btn,self.sol_plot_scale_type_btn_txt)
		figureprop_layout.addRow(self.water_x_lim_btn,self.water_x_lim_btn_txt)
		figureprop_layout.addRow(self.geotherm_x_lim_btn,self.geotherm_x_lim_btn_txt)
		figureprop_layout.addRow(self.condrange_btn,self.condrange_btn_txt)
		figureprop_layout.addRow(self.condlinestyle_btn,self.condlinestyle_btn_txt)
		figureprop_layout.addRow(self.condlinewidth_btn,self.condlinewidth_btn_txt)
		figureprop_layout.addRow(self.condplotlim_up_btn,self.condplotlim_up_btn_txt)
		figureprop_layout.addRow(self.condplotlim_down_btn,self.condplotlim_down_btn_txt)
		figureprop_layout.addRow(self.boundsbackgr_btn,self.boundsbackgr_btn_txt)

	def get_plot_style(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
		"Plot style selection", MATE.plot_style_list, 0, False)

		if ok and item:
			self.plot_style_btn_txt.setText(item)

		MATE.plot_style_selection = MATE.plot_style_list.index(item)

	def get_trange(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
		"Do you want to plot T-ranges of conductivity models?", MATE.trange_list, 0, False)

		if ok and item:
			self.trange_btn_txt.setText(item)

		MATE.trange_method = MATE.trange_list.index(item)

	def get_sol_plot_type(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
		"What is the style for the plots for the solubility figure?", MATE.sol_plot_type_list, 0, False)

		if ok and item:
			self.sol_plot_type_btn_txt.setText(item)

		MATE.sol_plot_method = MATE.sol_plot_type_list.index(item)

	def get_sol_plot_scale_type(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
		"What is the style for the plots for the solubility figure?", MATE.sol_plot_scale_list, 0, False)

		if ok and item:
			self.sol_plot_type_btn_txt.setText(item)

		MATE.sol_plot_scale_method = MATE.sol_plot_scale_list.index(item)

	def get_bulk_water_method(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
		"Do you want to plot bulk water content on the figure?", MATE.bulk_water_method_list, 0, False)

		if ok and item:
			self.bulk_water_plot_btn_txt.setText(item)

		MATE.bulk_water_method = MATE.bulk_water_method_list.index(item)

	def get_condrange(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
		"Do you want to plot the ranges of conductivity allowed by experimental uncertainties?", MATE.condrange_list, 0, False)

		if ok and item:
			self.condrange_btn_txt.setText(item)

		MATE.condrange_method = MATE.condrange_list.index(item)

	def get_condlinestyle(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
		"What would be the linestyle of the conductivity plot for the next iteration?", MATE.condlinestyle_list, 0, False)

		if ok and item:
			self.condlinestyle_btn_txt.setText(item)

		MATE.condlinestyle_select = MATE.condlinestyle_list.index(item)

	def get_condlinewidth(self):

		text, ok = QInputDialog.getText(self, 'Conductivity linewidth', 'What would be the linewidth of the conductivity plot for the next iteration?')
		if ok:
			try:
				float(text)
				self.condlinewidth_btn_txt.setText(str(text))
				MATE.condlinewidth = float(text)
			except ValueError:
				QMessageBox.about(self,"Warning!","Please enter a value that can be converted to floating number.")

	def get_waterplotlim_up(self):

		text, ok = QInputDialog.getText(self, 'X-limit of the water plot', 'X-limit of the water plot from max in ppm')
		if ok:
			try:
				float(text)
				self.water_x_lim_btn_txt.setText(str(text))
				MATE.waterplotlim_up = float(text)
			except ValueError:
				QMessageBox.about(self,"Warning!","Please enter a value that can be converted to floating number.")

	def get_geotherm_up(self):

		text, ok = QInputDialog.getText(self, 'X-limit of the geotherm plot', 'X-limit of the geotherm plot from max in C')
		if ok:
			try:
				float(text)
				self.geotherm_x_lim_btn_txt.setText(str(text))
				MATE.geotherm_up = float(text)
				MATE.geotherm_asked = True
			except ValueError:
				QMessageBox.about(self,"Warning!","Please enter a value that can be converted to floating number.")

	def get_condplotlim_up(self):

		text, ok = QInputDialog.getText(self, 'X-limit of the resistivity plot from max (ohm m)', 'X-limit of the resistivity plot from max in log- (ohm m)')
		if ok:
			try:
				float(text)
				self.condplotlim_up_btn_txt.setText(str(text))
				MATE.condplotlim_up = float(text)
			except ValueError:
				QMessageBox.about(self,"Warning!","Please enter a value that can be converted to floating number.")

	def get_condplotlim_down(self):

		text, ok = QInputDialog.getText(self, 'X-limit of the resistivity plot from min (ohm m)', 'X-limit of the resistivity plot from min log- (ohm m)')
		if ok:
			try:
				float(text)
				self.condplotlim_down_btn_txt.setText(str(text))
				MATE.condplotlim_down = float(text)
			except ValueError:
				QMessageBox.about(self,"Warning!","Please enter a value that can be converted to floating number.")

	def get_boundsbackgr(self):

		item, ok = QInputDialog.getItem(self, "select input dialog",
		"Enter the selection for background extremal bounds to plot.", MATE.boundslist, 0, False)

		if ok and item:
			self.boundsbackgr_btn_txt.setText(item)

		MATE.bounds_select = MATE.boundslist.index(item)

class W_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		w_layout = QVBoxLayout(self)

		self.w_inp_temp_radio_1 = QRadioButton("Model")
		self.w_inp_temp_radio_1.toggled.connect(lambda:self.btnstate_w_inp(self.w_inp_temp_radio_1))
		self.w_inp_temp_radio_2 = QRadioButton("Maximum bound of the model")
		self.w_inp_temp_radio_2.toggled.connect(lambda:self.btnstate_w_inp(self.w_inp_temp_radio_2))
		self.w_inp_temp_radio_3 = QRadioButton("Minimum bound of the model")
		self.w_inp_temp_radio_3.toggled.connect(lambda:self.btnstate_w_inp(self.w_inp_temp_radio_3))

		if MATE.w_inp_method == '0':
			self.w_inp_temp_radio_1.setChecked(True)
		elif MATE.w_inp_method == '1':
			self.w_inp_temp_radio_2.setChecked(True)
		elif MATE.w_inp_method == '2':
			self.w_inp_temp_radio_3.setChecked(True)

		w_layout.addWidget(self.w_inp_temp_radio_1)
		w_layout.addWidget(self.w_inp_temp_radio_2)
		w_layout.addWidget(self.w_inp_temp_radio_3)

	def btnstate_w_inp(self,b):

		if b.text() == "Model":
			if b.isChecked() == True:
				MATE.w_inp_method = '0'
		elif b.text() == "Maximum bound of the model":
			if b.isChecked() == True:
				MATE.w_inp_method = '1'
		elif b.text() == "Minimum bound of the model":
			if b.isChecked() == True:
				MATE.w_inp_method = '2'

class COND_UNCERT_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		cond_uncert_layout = QVBoxLayout(self)

		self.cond_uncert_radio_1 = QRadioButton("Model")
		self.cond_uncert_radio_1.toggled.connect(lambda:self.btnstate_cond_inp(self.cond_uncert_radio_1))
		self.cond_uncert_radio_2 = QRadioButton("Maximum bound of the model")
		self.cond_uncert_radio_2.toggled.connect(lambda:self.btnstate_cond_inp(self.cond_uncert_radio_2))
		self.cond_uncert_radio_3 = QRadioButton("Minimum bound of the model")
		self.cond_uncert_radio_3.toggled.connect(lambda:self.btnstate_cond_inp(self.cond_uncert_radio_3))

		if MATE.cond_uncert_method == '0':
			self.cond_uncert_radio_1.setChecked(True)
		elif MATE.cond_uncert_method == '1':
			self.cond_uncert_radio_2.setChecked(True)
		elif MATE.cond_uncert_method == '2':
			self.cond_uncert_radio_3.setChecked(True)

		cond_uncert_layout.addWidget(self.cond_uncert_radio_1)
		cond_uncert_layout.addWidget(self.cond_uncert_radio_2)
		cond_uncert_layout.addWidget(self.cond_uncert_radio_3)

	def btnstate_cond_inp(self,b):

		if b.text() == "Model":
			if b.isChecked() == True:
				MATE.cond_uncert_method = '0'
		elif b.text() == "Maximum bound of the model":
			if b.isChecked() == True:
				MATE.cond_uncert_method = '1'
		elif b.text() == "Minimum bound of the model":
			if b.isChecked() == True:
				MATE.cond_uncert_method = '2'

class WAT_SOLV_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		wat_solv_layout = QFormLayout(self)

		self.wat_search_btn = QPushButton('Water search reduction ratio')
		self.wat_search_btn_txt = QLineEdit(str(MATE.solver_search_ratio))
		self.wat_search_btn_txt.setEnabled(False)
		self.wat_search_btn.clicked.connect(self.get_water_solver_search_ratio)

		self.wat_search_incr_btn = QPushButton('Water search increment start (ppm)')
		self.wat_search_incr_btn_txt = QLineEdit(str(MATE.water_search_increment_start))
		self.wat_search_incr_btn_txt.setEnabled(False)
		self.wat_search_incr_btn.clicked.connect(self.get_water_search_increment_start)

		wat_solv_layout.addRow(self.wat_search_btn,self.wat_search_btn_txt)
		wat_solv_layout.addRow(self.wat_search_incr_btn,self.wat_search_incr_btn_txt)

	def get_water_solver_search_ratio(self):

		text, ok = QInputDialog.getText(self, 'Enter the water solver reduction ratio', 'Enter the water solver reduction ratio')
		if ok:
			try:
				float(text)
				self.wat_search_btn_txt.setText(str(text))
				MATE.solver_search_ratio = float(text)
			except ValueError:
				QMessageBox.about(self,"Warning!","Please enter a value that can be converted to floating number.")

	def get_water_search_increment_start(self):

		text, ok = QInputDialog.getText(self, 'Enter the water search increment start', 'Enter the water search increment start')
		if ok:
			try:
				float(text)
				self.wat_search_incr_btn_txt.setText(str(text))
				MATE.water_search_increment_start = float(text)
			except ValueError:
				QMessageBox.about(self,"Warning!","Please enter a value that can be converted to floating number.")

class XEN_SOLV_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		xen_solv_layout = QFormLayout(self)

		self.xen_solution_down_lim_btn = QPushButton('Heat flow search start')
		self.xen_solution_down_lim_btn_txt = QLineEdit(str(MATE.heat_flow_search_start))
		self.xen_solution_down_lim_btn_txt.setEnabled(False)
		self.xen_solution_down_lim_btn.clicked.connect(self.get_xen_solution_down)

		self.xen_solution_up_lim_btn = QPushButton('Heat flow search end')
		self.xen_solution_up_lim_btn_txt = QLineEdit(str(MATE.heat_flow_search_end))
		self.xen_solution_up_lim_btn_txt.setEnabled(False)
		self.xen_solution_up_lim_btn.clicked.connect(self.get_xen_solution_up)

		self.xen_solution_increment_btn = QPushButton('Heat flow search increment')
		self.xen_solution_increment_btn_txt = QLineEdit(str(MATE.heat_flow_search_incr))
		self.xen_solution_increment_btn_txt.setEnabled(False)
		self.xen_solution_increment_btn.clicked.connect(self.get_xen_solution_incr)

		xen_solv_layout.addRow(self.xen_solution_down_lim_btn,self.xen_solution_down_lim_btn_txt)
		xen_solv_layout.addRow(self.xen_solution_up_lim_btn,self.xen_solution_up_lim_btn_txt)
		xen_solv_layout.addRow(self.xen_solution_increment_btn,self.xen_solution_increment_btn_txt)

	def get_xen_solution_down(self):

		text, ok = QInputDialog.getText(self, 'Enter the Heat Flow search starting point in mW/m^3', 'Enter the Heat Flow search starting point in mW/m^3')
		if ok:
			try:
				float(text)
				self.xen_solution_down_lim_btn_txt.setText(str(text))
				MATE.heat_flow_search_start = float(text)
			except ValueError:
				QMessageBox.about(self,"Warning!","Please enter a value that can be converted to floating number.")


	def get_xen_solution_up(self):

		text, ok = QInputDialog.getText(self, 'Enter the Heat Flow search ending point in mW/m^3', 'Enter the Heat Flow search ending point in mW/m^3')
		if ok:
			try:
				float(text)
				self.xen_solution_up_lim_btn_txt.setText(str(text))
				MATE.heat_flow_search_end = float(text)
			except ValueError:
				QMessageBox.about(self,"Warning!","Please enter a value that can be converted to floating number.")

	def get_xen_solution_incr(self):

		text, ok = QInputDialog.getText(self, 'Enter the Heat Flow search increment in mW/m^3', 'Enter the Heat Flow search increment in mW/m^3')
		if ok:
			try:
				float(text)
				self.xen_solution_increment_btn_txt.setText(str(text))
				MATE.heat_flow_search_incr = float(text)
			except ValueError:
				QMessageBox.about(self,"Warning!","Please enter a value that can be converted to floating number.")

class MELT_FRAC_POP(QWidget):

	def __init__(self):

		QWidget.__init__(self)

		melt_frac_solver_layout = QVBoxLayout(self)

		bg1 = QButtonGroup(self)

		self.melt_frac_btn_1 = QRadioButton("Melt is solved where water cannot explain")
		self.melt_frac_btn_1.toggled.connect(lambda:self.btnstate_melt_frac_method_inp(self.melt_frac_btn_1))

		if MATE.watermelt_solve_method == 0:
			self.melt_frac_btn_1.setChecked(True)

		bg1.addButton(self.melt_frac_btn_1)
		melt_frac_solver_layout.addWidget(self.melt_frac_btn_1)

	def btnstate_melt_frac_method_inp(self,b):

		if b.text() == "Melt is solved where water cannot explain":
			if b.isChecked() == True:
				MATE.watermelt_solve_method = 0

def main():

	app = QApplication(sys.argv)
	GUI = MATE()
	sys.exit(app.exec_())

if __name__ == '__main__':
	main()
